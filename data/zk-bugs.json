[
  {
    "title": "N_BYTES parameters are not checked to prevent overflow",
    "source": "Trail Of Bits",
    "date": "2023-12-10",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "low",
    "difficulty": "low",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-5",
    "target_file": "circuits/src/evm_circuit/util/math_gadget/{constant_division,lt}.rs",
    "content": [
      {
        "type": "text",
        "text": "The ConstantDivisionGadget and LtGadget circuits implement operations on multi-byte integers: division by a constant value and comparison, respectively. Each circuit has a generic parameter N_BYTES representing the number of bytes used. However, each of these circuits has additional implied restrictions on N_BYTES required to prevent unexpected behavior due to overflowing field elements"
      },
      {
        "type": "text",
        "text": "In ConstantDivisionGadget (shown in figure 5.1), the quotient value is constrained to be less than 256^N_BYTES, but the expression quotient.expr()*denominator.expr() may overflow if denominator is sufficiently large (e.g., if denominator is 1024 and N_BYTES is 31. The comment highlighted in figure 5.2 provides sufficient conditions to prevent overflow, but these are not fully enforced either in the circuit or in assertions at circuit construction time"
      },
      {
        "type": "code",
        "code": "let quotient = cb.query_cell_with_type(CellType::storage_for_expr(&numerator)); let remainder = cb.query_cell_with_type(CellType::storage_for_expr(&numerator)); // Require that remainder < denominator cb.range_lookup(remainder.expr(), denominator); // Require that quotient < 256**N_BYTES // so we can't have any overflow when doing `quotient * denominator`. let quotient_range_check = RangeCheckGadget::construct(cb, quotient.expr()); // Check if the division was done correctly cb.require_equal( \"numerator-remainder == quotient ⋅ denominator\", numerator-remainder.expr(), quotient.expr() * denominator.expr(), );",
        "language": "rust",
        "description": "Figure 5.1:zkevm-circuits/src/evm_circuit/util/math_gadget/constant_division.rs#33-48"
      },
      {
        "type": "code",
        "code": "/// Returns (quotient: numerator/denominator, remainder: numerator%denominator),\n/// with `numerator` an expression and `denominator` a constant.\n/// Input requirements:\n///-`quotient < 256**N_BYTES`\n///-`quotient * denominator < field size`\n///-`remainder < denominator` requires a range lookup table for `denominator`\n#[derive(Clone, Debug)]\npub struct ConstantDivisionGadget<F, const N_BYTES: usize> {\n ",
        "language": "rust",
        "description": "Figure 5.2:zkevm-circuits/src/evm_circuit/util/math_gadget/constant_division.rs#13-20"
      },
      {
        "type": "text",
        "text": "In LtGadget (shown in figure 5.3), values of N_BYTES above 31 will cause lt to be an unconstrained Boolean, since a malicious prover can set diff to the representation of (rhs-lhs) even if rhs < lhs"
      },
      {
        "type": "code",
        "code": "let lt = cb.query_bool();\nlet diff = cb.query_bytes();\nlet range = pow_of_two(N_BYTES * 8);\n// The equation we require to hold: `lhs-rhs == diff-(lt * range)`.\ncb.require_equal(\n \"lhs-rhs == diff-(lt ⋅ range)\",\n lhs-rhs,\n from_bytes::expr(&diff)-(lt.expr() * range),\n );\n",
        "language": "rust",
        "description": "Figure 5.3:zkevm-circuits/src/evm_circuit/util/math_gadget/lt.rs#37–46"
      },
      {
        "type": "code",
        "code": "/// Returns `1` when `lhs < rhs`, and returns `0` otherwise.\n/// lhs and rhs `< 256**N_BYTES`\n/// `N_BYTES` is required to be `<= MAX_N_BYTES_INTEGER` to prevent overflow:\n/// values are stored in a single field element and two of these are added\n/// together.\n/// The equation that is enforced is `lhs-rhs == diff-(lt * range)`.\n/// Because all values are `<= 256**N_BYTES` and `lt` is boolean, `lt` can only\n/// be `1` when `lhs < rhs`.\n#[derive(Clone, Debug)]\npub struct LtGadget<F, const N_BYTES: usize> {",
        "language": "rust",
        "description": "Figure 5.4:zkevm-circuits/src/evm_circuit/util/math_gadget/lt.rs#14–23"
      },
      {
        "type": "code",
        "code": "pub(crate) fn expr<F: FieldExt, E: Expr<F>>(bytes: &[E])-> Expression<F> {\ndebug_assert!(\n bytes.len() <= MAX_N_BYTES_INTEGER,\n \"Too many bytes to compose an integer in field\"\n );",
        "language": "rust",
        "description": "Figure 5.5: zkevm-circuits/src/evm_circuit/util.rs#528–532"
      }
    ],
    "impact": "A developer who is unaware of these issues uses the ConstantDivisionGadget or LtGadget circuit with values of N_BYTES that are too large, causing potentially underconstrained circuits.",
    "recommendation": "Short term, add explicit checks at circuit construction time to ensure that N_BYTES is limited to values that prevent overflow. Long term, consider performing these validations at compile time with static_assertions or asserts in a const context.",
    "auditFirm": "Trail of Bits",
    "publishDate": "2023-12-10",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "Differences in shared code between zkevm-circuits and halo2-lib",
    "source": "Trail Of Bits",
    "date": "2023-12-10",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "medium",
    "difficulty": "high",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-6",
    "target_file": "Several files",
    "content": [
      {
        "type": "text",
        "text": "The codebase contains code that is also present in the halo2-lib codebase (not through a dependency) and it does not match in all cases. For example, the several constraint_builder functions use the debug_assert!() macro for important validations, which will not perform those checks in release mode."
      },
      {
        "type": "code",
        "code": "pub(crate) fn condition<R>(\n &mut self,\n condition: Expression<F>,\n constraint: impl FnOnce(&mut Self)-> R,\n )-> R {\n debug_assert!(\n self.condition.is_none(),\n \"Nested condition is not supported\"\n );\n self.condition = Some(condition);\n let ret = constraint(self);\n self.condition = None;\n ret\n }",
        "language": "rust",
        "description": "Figure 6.1:evm_circuit/util/constraint_builder.rs#L216-L229"
      },
      {
        "type": "code",
        "code": "pub(crate) fn validate_degree(&self, degree: usize, name: &'static str) {\n if self.max_degree > 0 {\n debug_assert!(\n degree <= self.max_degree,\n \"Expression {} degree too high: {} > {}\",\n name,\n degree,\n self.max_degree,\n );\n }\n }",
        "language": "rust",
        "description": "Figure 6.2:evm_circuit/util/constraint_builder.rs#L246-L256"
      },
      {
        "type": "code",
        "code": "pub(crate) fn validate_degree(&self, degree: usize, name: &'static str) {// We need to subtract IMPLICIT_DEGREE from MAX_DEGREE because all expressions\n // will be multiplied by state selector and q_step/q_step_first\n // selector.\n debug_assert!(\n degree <= MAX_DEGREE- IMPLICIT_DEGREE,\n \"Expression {} degree too high: {} > {}\",\n name,\n degree,\n MAX_DEGREE- IMPLICIT_DEGREE,\n );\n }",
        "language": "rust",
        "description": "Figure 6.3: evm_circuit/util/constraint_builder.rs#L1370-L1381"
      },
      {
        "type": "text",
        "text": "The codebase also includes the log2_ceil function in zkevm-circuits/src/util.rs, which miscomputes its result on a zero input—the behavior has been fixed in PR #37 for halo2-lib"
      }
    ],
    "impact": "",
    "recommendation": "Short term, fix the issues in common with the halo2-lib codebase. Also, check all uses of debug_assert throughout the codebase and ensure that they are not used to validate critical invariants, as they will not run in release mode. Long term, minimize duplicate code by refactoring the constraint builder codebase.",
    "auditFirm": "Trail of Bits",
    "publishDate": "2023-12-10",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "Underconstrained warm status on CALL opcodes allows gas cost forgery",
    "source": "Trail Of Bits",
    "date": "2023-12-10",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "high",
    "difficulty": "medium",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-7",
    "target_file": "zkevm-circuits/src/evm_circuit/execution/callop.rs",
    "content": [
      {
        "type": "text",
        "text": "An underconstrained variable in the CallOpGadget allows an attacker to prove the execution of a transaction with incorrect gas costs by setting an address as cold when it should become warm."
      },
      {
        "type": "text",
        "text": "The CallOpGadget implements the CALL, CALLCODE, DELEGATECALL, and STATICCALL EVM opcodes. The gas cost of these opcodes depends on whether the callee address is warm. Additionally, the implementation of these opcodes must make the address warm so that future calls to the same address cost less gas. However, the variable that controls the address's new warm status is not constrained and is referenced only in the write to the RW table."
      },
      {
        "type": "code",
        "code": "// Add callee to access list\nlet is_warm = cb.query_bool();\nlet is_warm_prev = cb.query_bool();\ncb.account_access_list_write(\ntx_id.expr(),\ncall_gadget.callee_address_expr(),\nis_warm.expr(),\nis_warm_prev.expr(),\nSome(&mut reversion_info),\n);",
        "language": "rust",
        "description": "Figure 7.1: zkevm-circuits/src/evm_circuit/execution/callop.rs#L129-L138"
      },
      {
        "type": "text",
        "text": "This means that a malicious prover can make the is_warm variable equal false, causing a called address to actually become cold during the execution of a CALL, instead of warm as in the EVM specification"
      },
      {
        "type": "text",
        "text": "A constraint on the RW table, requiring that the initial value of the access list elements is always false, prevents another possible scenario where the is_warm_prev value could be defined as warm even though the address had not been accessed before"
      }
    ],
    "impact": "A malicious prover generates a proof of execution for a transaction involving two CALL opcodes to the same address that results in different gas costs from the EVM specification: in the first CALL opcode execution, the prover sets the address as cold instead of warm, causing the wrong gas calculation for the second call. The prover submits that proof, the results of which will not match the correct EVM semantics, leading to state divergence and loss of funds",
    "recommendation": "Short term, add constraints to ensure that the callee address becomes warm on the CALL opcodes, by constraining is_warm to be true.",
    "auditFirm": "Trail of Bits",
    "publishDate": "2023-12-10",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  }
]