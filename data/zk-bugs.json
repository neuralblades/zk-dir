[
    {
      "title": "ModGadget is underconstrained and allows incorrect MULMOD operations to be proven",
      "source": "Trail Of Bits",
      "date": "2023-12-10",
      "protocol": "Scroll ZkEVM",
      "protocol_type": "ZKEVM",
      "tags": [],
      "frameworks": [],
      "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
      "scope": [
        {
          "name": "zkevm-circuits",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
          "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
        },
        {
          "name": "snark-verifier code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
          "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
        },
        {
          "name": "modexp",
          "description": "",
          "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
          "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
        },
        {
          "name": "halo2-lib code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
          "commit_hash": "a805052->b1d1567"
        },
        {
          "name": "Bytecode circuit",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
          "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
        }
      ],
      "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
      "severity": "high",
      "difficulty": "medium",
      "type": "data validation",
      "finding_id": "TOB-SCROLL-1",
      "target_file": "zkevm-circuits/src/evm_circuit/util/math_gadget/modulo.rs",
      "content": [
        {
          "type": "text",
          "text": "The ModGadget circuit computes the modulo operation, a mod n, with the caveat that the result should be 0 whenever n is 0. However, an incorrect constraint allows a proof that that a mod 0 == a. This causes incorrect EVM semantics for the MULMOD opcode, allowing an attacker to prove that ab mod 0 == ab. According to the EVM semantics, the correct result is 0"
        },
        {
          "type": "text",
          "text": "The ModGadget circuit implementation uses a witness value, a_or_zero, that is supposed to take the value of a when n is nonzero or 0 when n is 0. The code comments indicate that the following constraint ensures that a_or_zero satisfies this condition, but the constraint also allows the case a_or_zero == a and n == 0:"
        },
        {
          "type": "code",
          "code": "/// Constraints for the words a, n, r:\n/// a mod n = r, if n!=0\n/// r = 0, if n==0\n///\n/// We use the auxiliary a_or_zero word, whose value is constrained to be:\n/// a_or_zero = a if n!=0, 0 if n==0. This allows to use the equation\n/// k * n + r = a_or_zero to verify the modulus, which holds with r=0 in the\n/// case of n=0. Unlike the usual k * n + r = a, which forces r = a when n=0,\n/// this equation assures that r<n or r=n=0.\n...\nimpl<F: Field> ModGadget<F> {\n  pub(crate) fn construct(cb: &mut ConstraintBuilder<F>, words: [&util::Word<F>;\n    3]) -> Self {\n    let (a, n, r) = (words[0], words[1], words[2]);\n    let k = cb.query_word_rlc();\n    let a_or_zero = cb.query_word_rlc();\n    let n_is_zero = IsZeroGadget::construct(cb, sum::expr(&n.cells));\n    let a_or_is_zero = IsZeroGadget::construct(cb, sum::expr(&a_or_zero.cells));\n    let mul_add_words = MulAddWordsGadget::construct(cb, [&k, n, r,\n      &a_or_zero]);\n    let eq = IsEqualGadget::construct(cb, a.expr(), a_or_zero.expr());\n    let lt = LtWordGadget::construct(cb, r, n);\n    // Constrain the aux variable a_or_zero to be =a or =0 if n==0:\n    // (a == a_or_zero) ^ (n == 0 & a_or_zero == 0)\n    cb.add_constraint(\n      \" (1 - (a == a_or_zero)) * ( 1 - (n == 0) * (a_or_zero == 0)\",\n      (1.expr() - eq.expr()) * (1.expr() - n_is_zero.expr() *\n      a_or_is_zero.expr()),\n    );\n  }",
          "language": "rust",
          "description": "Figure 1.1: evm_circuit/util/math_gadget/modulo.rs#L10-L44"
        },
        {
          "type": "text",
          "text": "To correctly constrain the a_or_zero variable, rewrite the constraint as the following: [1 - ((n==0)*(a_or_zero==0) + (1 - n==0) * (a_or_zero == a)))] == 0 This constraint results in the following truth table:"
        },
        {
          "type": "text",
          "text": "Figure 1.2 shows how ModGadget is used to constrain the results of the MULMOD opcode. Since the constraints are satisfied by setting a_reduced == a instead of a_reduced == 0, when ùëé ¬∑ ùëè < 2^256 , the result can be set to by setting . k1 = k2 = d = 0, e = r =  a . b"
        },
        {
          "type": "code",
          "code": "// 1. k1 * n + a_reduced == a\nlet modword = ModGadget::construct(cb, [&a, &n, &a_reduced]);\n// 2. a_reduced * b + 0 == d * 2^256 + e\nlet mul512_left = MulAddWords512Gadget::construct(cb, [&a_reduced, &b, &d, &e],\n  None);\n// 3. k2 * n + r == d * 2^256 + e\nlet mul512_right = MulAddWords512Gadget::construct(cb, [&k, &n, &d, &e], Some(&r));\n// (r < n ) or n == 0\nlet n_is_zero = IsZeroGadget::construct(cb, sum::expr(&n.cells));\nlet lt = LtWordGadget::construct(cb, &r, &n);\ncb.add_constraint(\n  \" (1 - (r < n) - (n==0)) \",\n  1.expr() - lt.expr() - n_is_zero.expr(),\n);",
          "language": "rust",
          "description": "Figure 1.2: zkevm-circuits/src/evm_circuit/execution/mulmod.rs#58‚Äì73"
        }
      ],
      "impact": "A malicious prover interprets two bytes in an RLP-serialized data structure as a value less than 128, causing later fields in the data structure to be deserialized starting at an incorrect offset. The prover submits that proof, the results of which will not match the correct EVM semantics, leading to state divergence and loss of funds.",
      "recommendation": "Short term, fix the constraint; extend the assign function to receive the a_or_zero witness. Add tests for this finding. Long term, add determinacy testing to any gadgets that constrain nondeterministic witnesses",
      "auditFirm": "Trail of Bits",
      "publishDate": "2023-12-10",
      "reportSource": {
        "name": "Nullity00",
        "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
      }
    },
    {
      "title": "TheRlpU64Gadget is underconstrained when is_lt_128 is false",
      "source": "Trail Of Bits",
      "date": "2023-12-10",
      "protocol": "Scroll ZkEVM",
      "protocol_type": "ZKEVM",
      "tags": [],
      "frameworks": [],
      "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
      "scope": [
        {
          "name": "zkevm-circuits",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
          "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
        },
        {
          "name": "snark-verifier code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
          "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
        },
        {
          "name": "halo2-lib code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
          "commit_hash": "a805052->b1d1567"
        },
        {
          "name": "Bytecode circuit",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
          "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
        }
      ],
      "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
      "severity": "high",
      "difficulty": "medium",
      "type": "data validation",
      "finding_id": "TOB-SCROLL-2",
      "target_file": "zkevm-circuits/src/evm_circuit/util/math_gadget/rlp.rs",
      "content": [
        {
          "type": "text",
          "text": "The RlpU64Gadget constrains witness values to match the output of a correct RLP encoding. Since the length and value of the RLP-encoded value depend on the value being less than 128, the is_lt_128 flag is part of the witness. A range check ensures that if is_lt_128 is true, then the value is actually below 128. However, there is no constraint ensuring that value is above 127 when is_lt_128 is false:"
        },
        {
          "type": "code",
          "code": "let is_lt_128 = cb.query_bool();\n cb.condition(is_lt_128.expr(), |cb| {\n cb.range_lookup(value, 128);\n });",
          "language": "rust",
          "description": "Figure 2.1: evm_circuit/util/math_gadget/rlp.rs#L67-L70"
        },
        {
          "type": "text",
          "text": "This means that a malicious prover could have a value smaller than 128 but set is_lt_128 to false, leading to an incorrect length and RLP-encoded output:"
        }
      ],
      "impact": "A malicious prover interprets two bytes in an RLP-serialized data structure as a value less than 128, causing later fields in the data structure to be deserialized starting at an incorrect offset. The prover then uses this incorrectly deserialized data structure to prove an invalid state transition, leading to state divergence and potential loss of funds.",
      "recommendation": "Short term, add a constraint to ensure that the value is above 127 when is_lt_128 is false. Long term, add negative tests ensuring that mismatched witnesses value and is_lt_128 do not satisfy the circuit constraints",
      "auditFirm": "Trail of Bits",
      "publishDate": "2023-12-10",
      "reportSource": {
        "name": "Nullity00",
        "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
      }
    }
]