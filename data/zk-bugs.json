[
    {
      "title": "ModGadget is underconstrained and allows incorrect MULMOD operations to be proven",
      "source": "Trail Of Bits",
      "protocol": "Scroll ZkEVM",
      "protocol_type": "ZKEVM",
      "tags": [],
      "frameworks": [],
      "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
      "scope": [
        {
          "name": "zkevm-circuits",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
          "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
        },
        {
          "name": "snark-verifier code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
          "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
        },
        {
          "name": "modexp",
          "description": "",
          "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
          "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
        },
        {
          "name": "halo2-lib code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
          "commit_hash": "a805052->b1d1567"
        },
        {
          "name": "Bytecode circuit",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
          "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
        }
      ],
      "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
      "severity": "high",
      "difficulty": "medium",
      "type": "data validation",
      "finding_id": "TOB-SCROLL-1",
      "target_file": "zkevm-circuits/src/evm_circuit/util/math_gadget/modulo.rs",
      "content": [
        {
          "type": "text",
          "text": "The ModGadget circuit computes the modulo operation, a mod n, with the caveat that the result should be 0 whenever n is 0. However, an incorrect constraint allows a proof that that a mod 0 == a. This causes incorrect EVM semantics for the MULMOD opcode, allowing an attacker to prove that ab mod 0 == ab. According to the EVM semantics, the correct result is 0"
        },
        {
          "type": "text",
          "text": "The ModGadget circuit implementation uses a witness value, a_or_zero, that is supposed to take the value of a when n is nonzero or 0 when n is 0. The code comments indicate that the following constraint ensures that a_or_zero satisfies this condition, but the constraint also allows the case a_or_zero == a and n == 0:"
        },
        {
          "type": "code",
          "code": "/// Constraints for the words a, n, r:\n/// a mod n = r, if n!=0\n/// r = 0, if n==0\n///\n/// We use the auxiliary a_or_zero word, whose value is constrained to be:\n/// a_or_zero = a if n!=0, 0 if n==0. This allows to use the equation\n/// k * n + r = a_or_zero to verify the modulus, which holds with r=0 in the\n/// case of n=0. Unlike the usual k * n + r = a, which forces r = a when n=0,\n/// this equation assures that r<n or r=n=0.\n...\nimpl<F: Field> ModGadget<F> {\n  pub(crate) fn construct(cb: &mut ConstraintBuilder<F>, words: [&util::Word<F>;\n    3]) -> Self {\n    let (a, n, r) = (words[0], words[1], words[2]);\n    let k = cb.query_word_rlc();\n    let a_or_zero = cb.query_word_rlc();\n    let n_is_zero = IsZeroGadget::construct(cb, sum::expr(&n.cells));\n    let a_or_is_zero = IsZeroGadget::construct(cb, sum::expr(&a_or_zero.cells));\n    let mul_add_words = MulAddWordsGadget::construct(cb, [&k, n, r,\n      &a_or_zero]);\n    let eq = IsEqualGadget::construct(cb, a.expr(), a_or_zero.expr());\n    let lt = LtWordGadget::construct(cb, r, n);\n    // Constrain the aux variable a_or_zero to be =a or =0 if n==0:\n    // (a == a_or_zero) ^ (n == 0 & a_or_zero == 0)\n    cb.add_constraint(\n      \" (1 - (a == a_or_zero)) * ( 1 - (n == 0) * (a_or_zero == 0)\",\n      (1.expr() - eq.expr()) * (1.expr() - n_is_zero.expr() *\n      a_or_is_zero.expr()),\n    );\n  }",
          "language": "rust",
          "description": "Figure 1.1: evm_circuit/util/math_gadget/modulo.rs#L10-L44"
        },
        {
          "type": "text",
          "text": "To correctly constrain the a_or_zero variable, rewrite the constraint as the following: [1 - ((n==0)*(a_or_zero==0) + (1 - n==0) * (a_or_zero == a)))] == 0 This constraint results in the following truth table:"
        },
        {
          "type": "text",
          "text": "Figure 1.2 shows how ModGadget is used to constrain the results of the MULMOD opcode. Since the constraints are satisfied by setting a_reduced == a instead of a_reduced == 0, when ùëé ¬∑ ùëè < 2^256 , the result can be set to by setting . k1 = k2 = d = 0, e = r =  a . b"
        },
        {
          "type": "code",
          "code": "// 1. k1 * n + a_reduced == a\nlet modword = ModGadget::construct(cb, [&a, &n, &a_reduced]);\n// 2. a_reduced * b + 0 == d * 2^256 + e\nlet mul512_left = MulAddWords512Gadget::construct(cb, [&a_reduced, &b, &d, &e],\n  None);\n// 3. k2 * n + r == d * 2^256 + e\nlet mul512_right = MulAddWords512Gadget::construct(cb, [&k, &n, &d, &e], Some(&r));\n// (r < n ) or n == 0\nlet n_is_zero = IsZeroGadget::construct(cb, sum::expr(&n.cells));\nlet lt = LtWordGadget::construct(cb, &r, &n);\ncb.add_constraint(\n  \" (1 - (r < n) - (n==0)) \",\n  1.expr() - lt.expr() - n_is_zero.expr(),\n);",
          "language": "rust",
          "description": "Figure 1.2: zkevm-circuits/src/evm_circuit/execution/mulmod.rs#58‚Äì73"
        }
      ],
      "impact": "A malicious prover interprets two bytes in an RLP-serialized data structure as a value less than 128, causing later fields in the data structure to be deserialized starting at an incorrect offset. The prover submits that proof, the results of which will not match the correct EVM semantics, leading to state divergence and loss of funds.",
      "recommendation": "Short term, fix the constraint; extend the assign function to receive the a_or_zero witness. Add tests for this finding. Long term, add determinacy testing to any gadgets that constrain nondeterministic witnesses",
      "auditFirm": "Trail of Bits",
      "publishDate": "10/12/2023",
      "reportSource": {
        "name": "Nullity00",
        "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
      }
    },
    {
      "title": "TheRlpU64Gadget is underconstrained when is_lt_128 is false",
      "source": "Trail Of Bits",
      "protocol": "Scroll ZkEVM",
      "protocol_type": "ZKEVM",
      "tags": [],
      "frameworks": [],
      "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
      "scope": [
        {
          "name": "zkevm-circuits",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
          "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
        },
        {
          "name": "snark-verifier code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
          "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
        },
        {
          "name": "halo2-lib code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
          "commit_hash": "a805052->b1d1567"
        },
        {
          "name": "Bytecode circuit",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
          "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
        }
      ],
      "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
      "severity": "high",
      "difficulty": "medium",
      "type": "data validation",
      "finding_id": "TOB-SCROLL-2",
      "target_file": "zkevm-circuits/src/evm_circuit/util/math_gadget/rlp.rs",
      "content": [
        {
          "type": "text",
          "text": "The RlpU64Gadget constrains witness values to match the output of a correct RLP encoding. Since the length and value of the RLP-encoded value depend on the value being less than 128, the is_lt_128 flag is part of the witness. A range check ensures that if is_lt_128 is true, then the value is actually below 128. However, there is no constraint ensuring that value is above 127 when is_lt_128 is false:"
        },
        {
          "type": "code",
          "code": "let is_lt_128 = cb.query_bool();\n cb.condition(is_lt_128.expr(), |cb| {\n cb.range_lookup(value, 128);\n });",
          "language": "rust",
          "description": "Figure 2.1: evm_circuit/util/math_gadget/rlp.rs#L67-L70"
        },
        {
          "type": "text",
          "text": "This means that a malicious prover could have a value smaller than 128 but set is_lt_128 to false, leading to an incorrect length and RLP-encoded output:"
        }
      ],
      "impact": "A malicious prover interprets two bytes in an RLP-serialized data structure as a value less than 128, causing later fields in the data structure to be deserialized starting at an incorrect offset. The prover then uses this incorrectly deserialized data structure to prove an invalid state transition, leading to state divergence and potential loss of funds.",
      "recommendation": "Short term, add a constraint to ensure that the value is above 127 when is_lt_128 is false. Long term, add negative tests ensuring that mismatched witnesses value and is_lt_128 do not satisfy the circuit constraints",
      "auditFirm": "Trail of Bits",
      "publishDate": "10/12/2023",
      "reportSource": {
        "name": "Nullity00",
        "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
      }
    },
    {
      "title": "The BLOCKHASH opcode is underconstrained and allows the hash of any block to be computed",
      "source": "Trail Of Bits",
      "protocol": "Scroll ZkEVM",
      "protocol_type": "ZKEVM",
      "tags": [],
      "frameworks": [],
      "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
      "scope": [
        {
          "name": "zkevm-circuits",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
          "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
        },
        {
          "name": "snark-verifier code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
          "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
        },
        {
          "name": "modexp",
          "description": "",
          "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
          "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
        },
        {
          "name": "halo2-lib code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
          "commit_hash": "a805052->b1d1567"
        },
        {
          "name": "Bytecode circuit",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
          "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
        }
      ],
      "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
      "severity": "high",
      "difficulty": "medium",
      "type": "data validation",
      "finding_id": "TOB-SCROLL-3",
      "target_file": "zkevm-circuits/src/evm_circuit/util/math_gadget/rlp.rs",
      "content": [
        {
          "type": "text",
          "text": "The BLOCKHASH opcode returns the hash of the block identified by the stack argument, block_number, provided that it is one of the 256 most recent complete blocks. However, the implementation allows a malicious prover to provide a non-zero result even when the provided block number is not among the 256 most recent blocks, contradicting the EVM specification"
        },
        {
          "type": "text",
          "text": "To validate that block_number is among the 256 most recent blocks, the implementation checks that current_block_number - block_number < 257, where current_block_number is supposed to be the block number of the current block. However, current_block_number is unconstrained and could take any value."
        },
        {
          "type": "code",
          "code": "impl<F: Field> ExecutionGadget<F> for BlockHashGadget<F> {\n    const NAME: &'static str = \"BLOCKHASH\";\n    const EXECUTION_STATE: ExecutionState = ExecutionState::BLOCKHASH;\n\n    fn configure(cb: &mut ConstraintBuilder<F>) -> Self {\n        let current_block_number = cb.query_cell();\n        let block_number = WordByteCapGadget::construct(cb, current_block_number.expr());\n        cb.stack_pop(block_number.original_word());\n\n        // FIXME\n        // cb.block_lookup(\n        //     BlockContextFieldTag::Number.expr(),\n        //     cb.curr.state.block_number.expr(),\n        //     current_block_number.expr(),\n        // );\n\n        let block_hash = cb.query_word_rlc();\n        let diff_lt = LtGadget::construct(\n            cb,\n            current_block_number.expr(),\n            (NUM_PREV_BLOCK_ALLOWED + 1).expr() + block_number.valid_value(),\n        );\n        // ... You can continue indenting the rest of your code here.\n    }\n}",
          "language": "rust",
          "description": "Figure 3.1: zkevm-circuits/src/evm_circuit/execution/blockhash.rs#L33-L4"
        },
        {
          "type": "text",
          "text": "A malicious prover could provide an invalid current_block_number and return the hash of any block present in the block lookup table, independent of its block number."
        }
      ],
      "impact": "A malicious prover generates a proof of execution for a transaction involving the BLOCKHASH opcode that results in a nonzero hash for an older block. The prover submits that proof, the results of which will not match the correct EVM semantics, leading to state divergence and loss of funds.",
      "recommendation": "Short term, add the missing lookup constraint for the current_block_number witness. Long term, track and triage FIXME and TODO items in a centralized issue tracking system, such as GitHub issues. Add failing tests when security-relevant TODO items are identified.",
      "auditFirm": "Trail of Bits",
      "publishDate": "10/12/2023",
      "reportSource": {
        "name": "Nullity00",
        "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
      }
    },
    {
      "title": "zkevm-circuits crate depends on an outdated version of halo2-ecc",
      "source": "Trail Of Bits",
      "protocol": "Scroll ZkEVM",
      "protocol_type": "ZKEVM",
      "tags": [],
      "frameworks": [],
      "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
      "scope": [
        {
          "name": "zkevm-circuits",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
          "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
        },
        {
          "name": "snark-verifier code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
          "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
        },
        {
          "name": "modexp",
          "description": "",
          "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
          "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
        },
        {
          "name": "halo2-lib code diff",
          "description": "",
          "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
          "commit_hash": "a805052->b1d1567"
        },
        {
          "name": "Bytecode circuit",
          "description": "",
          "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
          "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
        }
      ],
      "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
      "severity": "medium",
      "difficulty": "medium",
      "type": "Patching",
      "finding_id": "TOB-SCROLL-4",
      "target_file": "zkevm-circuits/{Cargo.toml,src/tx_circuit/sign_verify.rs",
      "content": [
        {
          "type": "text",
          "text": "The zkevm-circuits crate depends on the halo2-ecc library in Scroll's fork of halo2-lib, which provides halo2 circuits for elliptic curve and finite field operations. As illustrated in figure 4.1, this crate depends on the halo2-ecc-snark-verifier-0323 tag, which currently points to commit d24871338ade7dd56362de517b718ba14f3e7b90"
        },
        {
          "type": "code",
          "code": "halo2-ecc = { git = \"https://github.com/scroll-tech/halo2-lib\", branch = \"halo2-ecc-snark-verifier-0323\", default-features=false, features=[\"halo2-pse\",\"display\"] }.",
          "language": "rust",
          "description": "Figure 4.1:zkevm-circuits/Cargo.toml#32‚Äì33"
        },
        {
          "type": "text",
          "text": "The Scroll fork of halo2-lib is closely related to the upstream halo2-lib library. In particular, the v0.3.0 version of halo2-ecc (commit c31a30bcaff384b0c3aa7c823dd343f5c85da69e) has a common ancestor commit of 4338af81bb2de4f278467e5c484e067c064cc66b with the Scroll version"
        },
        {
          "type": "text",
          "text": "The upstream library has various fixes and improvements that should be incorporated. Some notable existing fixes include the following: FpChip::assert_equal has had a soundness-related typo fixed (PR#18) ecdsa_verify_no_pubkey_check no longer rejects certain valid signatures (PR#36). While FpChip::assert_equal does not currently appear to be used, the SignVerifyChip circuit uses the ecdsa_verify_no_pubkey_check function, as shown in figure 4.3."
        },
        {
          "type": "code",
          "code": "// returns the verification result of ecdsa signature\n// WARNING: this circuit does not enforce the returned value to be true\n// make sure the caller checks this result!\nlet ecdsa_is_valid = ecdsa_verify_no_pubkey_check::<F, Fp, Fq, Secp256k1Affine>(\n    &ecc_chip.field_chip,\n    ctx,\n    &pk_assigned,\n    &integer_r,\n    &integer_s,\n    &msg_hash,\n    4,\n    4\n);",
          "language": "rust",
          "description": "Figure 4.3:zkevm-circuits/src/tx_circuit/sign_verify.rs#386‚Äì39"
        },
        {
          "type": "text",
          "text": "SignVerify is then used to check signatures on EVM transactions, as shown in figure 4.4, and because of the pre-patch behavior, an adversary can generate a correctly signed transaction that will nevertheless fail signature verification"
        },
        {
          "type": "code",
          "code": "#[cfg(feature = \"enable-sign-verify\")] { let assigned_sig_verifs = self.sign_verify .assign(&config.sign_verify, layouter, &sign_datas, challenges)?; self.sign_verify.assert_sig_is_valid( &config.sign_verify, layouter, assigned_sig_verifs.as_slice(), )?; self.assign( config, challenges, layouter, assigned_sig_verifs, Vec::new(), &padding_txs, )?; }",
          "language": "rust",
          "description": "Figure 4.4:zkevm-circuits/src/tx_circuit.rs#1804‚Äì1822"
        }
      ],
      "impact": "An adversary creates a transaction with a valid signature that the old implementation would reject and submits it to Ethereum. Ethereum accepts the transaction, but the Scroll zkEVM is unable to accept it, stalling the zkEVM and creating a denial of service that may freeze user funds.",
      "recommendation": "Short term, review the security implications of this outdated version of halo2-ecc on the zkEVM codebase. Then, either update to a more recent version of halo2-lib that incorporates upstream fixes or backport those fixes to Scroll's fork. Long term, keep all dependencies up to date whenever possible. For any dependencies that have been forked from the upstream version, develop a plan to port any upstream security updates onto that fork.",
      "auditFirm": "Trail of Bits",
      "publishDate": "10/12/2023",
      "reportSource": {
        "name": "Nullity00",
        "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
      }
    },
    {
    "title": "N_BYTES parameters are not checked to prevent overflow",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-5",
    "target_file": "circuits/src/evm_circuit/util/math_gadget/{constant_division,lt}.rs",
    "content": [
      {
        "type": "text",
        "text": "The ConstantDivisionGadget and LtGadget circuits implement operations on multi-byte integers: division by a constant value and comparison, respectively. Each circuit has a generic parameter N_BYTES representing the number of bytes used. However, each of these circuits has additional implied restrictions on N_BYTES required to prevent unexpected behavior due to overflowing field elements"
      },
      {
        "type": "text",
        "text": "In ConstantDivisionGadget (shown in figure 5.1), the quotient value is constrained to be less than 256^N_BYTES, but the expression quotient.expr()*denominator.expr() may overflow if denominator is sufficiently large (e.g., if denominator is 1024 and N_BYTES is 31. The comment highlighted in figure 5.2 provides sufficient conditions to prevent overflow, but these are not fully enforced either in the circuit or in assertions at circuit construction time"
      },
      {
        "type": "code",
        "code": "let quotient = cb.query_cell_with_type(CellType::storage_for_expr(&numerator)); let remainder = cb.query_cell_with_type(CellType::storage_for_expr(&numerator)); // Require that remainder < denominator cb.range_lookup(remainder.expr(), denominator); // Require that quotient < 256**N_BYTES // so we can't have any overflow when doing `quotient * denominator`. let quotient_range_check = RangeCheckGadget::construct(cb, quotient.expr()); // Check if the division was done correctly cb.require_equal( \"numerator-remainder == quotient ‚ãÖ denominator\", numerator-remainder.expr(), quotient.expr() * denominator.expr(), );",
        "language": "rust",
        "description": "Figure 5.1:zkevm-circuits/src/evm_circuit/util/math_gadget/constant_division.rs#33-48"
      },
      {
        "type": "code",
        "code": "/// Returns (quotient: numerator/denominator, remainder: numerator%denominator),\n/// with `numerator` an expression and `denominator` a constant.\n/// Input requirements:\n///-`quotient < 256**N_BYTES`\n///-`quotient * denominator < field size`\n///-`remainder < denominator` requires a range lookup table for `denominator`\n#[derive(Clone, Debug)]\npub struct ConstantDivisionGadget<F, const N_BYTES: usize> {\n ",
        "language": "rust",
        "description": "Figure 5.2:zkevm-circuits/src/evm_circuit/util/math_gadget/constant_division.rs#13-20"
      },
      {
        "type": "text",
        "text": "In LtGadget (shown in figure 5.3), values of N_BYTES above 31 will cause lt to be an unconstrained Boolean, since a malicious prover can set diff to the representation of (rhs-lhs) even if rhs < lhs"
      },
      {
        "type": "code",
        "code": "let lt = cb.query_bool();\nlet diff = cb.query_bytes();\nlet range = pow_of_two(N_BYTES * 8);\n// The equation we require to hold: `lhs-rhs == diff-(lt * range)`.\ncb.require_equal(\n \"lhs-rhs == diff-(lt ‚ãÖ range)\",\n lhs-rhs,\n from_bytes::expr(&diff)-(lt.expr() * range),\n );\n",
        "language": "rust",
        "description": "Figure 5.3:zkevm-circuits/src/evm_circuit/util/math_gadget/lt.rs#37‚Äì46"
      },
      {
        "type": "code",
        "code": "/// Returns `1` when `lhs < rhs`, and returns `0` otherwise.\n/// lhs and rhs `< 256**N_BYTES`\n/// `N_BYTES` is required to be `<= MAX_N_BYTES_INTEGER` to prevent overflow:\n/// values are stored in a single field element and two of these are added\n/// together.\n/// The equation that is enforced is `lhs-rhs == diff-(lt * range)`.\n/// Because all values are `<= 256**N_BYTES` and `lt` is boolean, `lt` can only\n/// be `1` when `lhs < rhs`.\n#[derive(Clone, Debug)]\npub struct LtGadget<F, const N_BYTES: usize> {",
        "language": "rust",
        "description": "Figure 5.4:zkevm-circuits/src/evm_circuit/util/math_gadget/lt.rs#14‚Äì23"
      },
      {
        "type": "code",
        "code": "pub(crate) fn expr<F: FieldExt, E: Expr<F>>(bytes: &[E])-> Expression<F> {\ndebug_assert!(\n bytes.len() <= MAX_N_BYTES_INTEGER,\n \"Too many bytes to compose an integer in field\"\n );",
        "language": "rust",
        "description": "Figure 5.5: zkevm-circuits/src/evm_circuit/util.rs#528‚Äì532"
      }
    ],
    "impact": "A developer who is unaware of these issues uses the ConstantDivisionGadget or LtGadget circuit with values of N_BYTES that are too large, causing potentially underconstrained circuits.",
    "recommendation": "Short term, add explicit checks at circuit construction time to ensure that N_BYTES is limited to values that prevent overflow. Long term, consider performing these validations at compile time with static_assertions or asserts in a const context.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "Differences in shared code between zkevm-circuits and halo2-lib",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "medium",
    "difficulty": "high",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-6",
    "target_file": "Several files",
    "content": [
      {
        "type": "text",
        "text": "The codebase contains code that is also present in the halo2-lib codebase (not through a dependency) and it does not match in all cases. For example, the several constraint_builder functions use the debug_assert!() macro for important validations, which will not perform those checks in release mode."
      },
      {
        "type": "code",
        "code": "pub(crate) fn condition<R>(\n &mut self,\n condition: Expression<F>,\n constraint: impl FnOnce(&mut Self)-> R,\n )-> R {\n debug_assert!(\n self.condition.is_none(),\n \"Nested condition is not supported\"\n );\n self.condition = Some(condition);\n let ret = constraint(self);\n self.condition = None;\n ret\n }",
        "language": "rust",
        "description": "Figure 6.1:evm_circuit/util/constraint_builder.rs#L216-L229"
      },
      {
        "type": "code",
        "code": "pub(crate) fn validate_degree(&self, degree: usize, name: &'static str) {\n if self.max_degree > 0 {\n debug_assert!(\n degree <= self.max_degree,\n \"Expression {} degree too high: {} > {}\",\n name,\n degree,\n self.max_degree,\n );\n }\n }",
        "language": "rust",
        "description": "Figure 6.2:evm_circuit/util/constraint_builder.rs#L246-L256"
      },
      {
        "type": "code",
        "code": "pub(crate) fn validate_degree(&self, degree: usize, name: &'static str) {// We need to subtract IMPLICIT_DEGREE from MAX_DEGREE because all expressions\n // will be multiplied by state selector and q_step/q_step_first\n // selector.\n debug_assert!(\n degree <= MAX_DEGREE- IMPLICIT_DEGREE,\n \"Expression {} degree too high: {} > {}\",\n name,\n degree,\n MAX_DEGREE- IMPLICIT_DEGREE,\n );\n }",
        "language": "rust",
        "description": "Figure 6.3: evm_circuit/util/constraint_builder.rs#L1370-L1381"
      },
      {
        "type": "text",
        "text": "The codebase also includes the log2_ceil function in zkevm-circuits/src/util.rs, which miscomputes its result on a zero input‚Äîthe behavior has been fixed in PR #37 for halo2-lib"
      }
    ],
    "impact": "",
    "recommendation": "Short term, fix the issues in common with the halo2-lib codebase. Also, check all uses of debug_assert throughout the codebase and ensure that they are not used to validate critical invariants, as they will not run in release mode. Long term, minimize duplicate code by refactoring the constraint builder codebase.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "Underconstrained warm status on CALL opcodes allows gas cost forgery",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "high",
    "difficulty": "medium",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-7",
    "target_file": "zkevm-circuits/src/evm_circuit/execution/callop.rs",
    "content": [
      {
        "type": "text",
        "text": "An underconstrained variable in the CallOpGadget allows an attacker to prove the execution of a transaction with incorrect gas costs by setting an address as cold when it should become warm."
      },
      {
        "type": "text",
        "text": "The CallOpGadget implements the CALL, CALLCODE, DELEGATECALL, and STATICCALL EVM opcodes. The gas cost of these opcodes depends on whether the callee address is warm. Additionally, the implementation of these opcodes must make the address warm so that future calls to the same address cost less gas. However, the variable that controls the address's new warm status is not constrained and is referenced only in the write to the RW table."
      },
      {
        "type": "code",
        "code": "// Add callee to access list\nlet is_warm = cb.query_bool();\nlet is_warm_prev = cb.query_bool();\ncb.account_access_list_write(\ntx_id.expr(),\ncall_gadget.callee_address_expr(),\nis_warm.expr(),\nis_warm_prev.expr(),\nSome(&mut reversion_info),\n);",
        "language": "rust",
        "description": "Figure 7.1: zkevm-circuits/src/evm_circuit/execution/callop.rs#L129-L138"
      },
      {
        "type": "text",
        "text": "This means that a malicious prover can make the is_warm variable equal false, causing a called address to actually become cold during the execution of a CALL, instead of warm as in the EVM specification"
      },
      {
        "type": "text",
        "text": "A constraint on the RW table, requiring that the initial value of the access list elements is always false, prevents another possible scenario where the is_warm_prev value could be defined as warm even though the address had not been accessed before"
      }
    ],
    "impact": "A malicious prover generates a proof of execution for a transaction involving two CALL opcodes to the same address that results in different gas costs from the EVM specification: in the first CALL opcode execution, the prover sets the address as cold instead of warm, causing the wrong gas calculation for the second call. The prover submits that proof, the results of which will not match the correct EVM semantics, leading to state divergence and loss of funds",
    "recommendation": "Short term, add constraints to ensure that the callee address becomes warm on the CALL opcodes, by constraining is_warm to be true.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "RW table constants must match exactly when the verification key is created",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-8",
    "target_file": "RW table",
    "content": [
      {
        "type": "text",
        "text": "Nearly all runtime state of EVM program execution is tracked and validated in a lookup table referred to as the RW table. This table enforces correct initialization and coherency of read and write operations for addressable parts of the state, including the stack, memory, and account storage, as well as inputs and outputs such as the transaction access list and the transaction log."
      },
      {
        "type": "text",
        "text": "The zkEVM circuit enforces correct memory operation results for EVM opcodes by performing lookups into this table. However, these lookups enforce only the existence of such rows, and for correct execution, it is vital that the reads and writes present in the table are coherent with the external state, coherent with each other, and coherent with the execution trace."
      },
      {
        "type": "text",
        "text": "These global constraints on the RW table are enforced through three major checks: lexicographic ordering of the table, structural properties on the sorted table, and tracking a running count of RW lookups. These checks are sufficient to guarantee RW table correctness, assuming certain properties of fixed rows, constants, or the circuit itself. However, these properties are not currently explicitly enforced at circuit-construction time."
      }
    ],
    "impact": "An incorrect version of the zkEVM circuit is used to generate a verification key that fails to enforce key assumptions. A malicious prover then crafts an RW table that leads to incorrect execution of a transaction, causing state divergence and potential loss of funds.",
    "recommendation": "Short term, add assert!(...) calls to enforce correct correspondence between rw_table.q_enable, lexicographic_ordering_selector, and max_rws. Long term, review and document assumptions made about all circuit constants. When possible, use techniques such as assertions to check these assumptions at circuit-construction time.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "The CREATE and CREATE2 opcodes can be called within a static context",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "high",
    "difficulty": "medium",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-9",
    "target_file": "zkevm-circuits/src/evm_circuit/execution/create.rs",
    "content": [
      {
        "type": "text",
        "text": "The CREATE and CREATE2 opcodes are missing a constraint that prevents them from being called in the context of a static call. This allows for a state-changing operation that is not allowed by the EVM specification."
      },
      {
        "type": "text",
        "text": "In the context of a STATICCALL, the state cannot be modified. As a result, state-changing opcodes like CREATE, CREATE2, LOGX, SSTORE, and CALL are forbidden when the argument value differs from 0, according to the EVM specification. However, the current implementation of the CREATE and CREATE2 opcodes does not have a check to ensure that the calling context has permission to change the state. By contrast, the other implementations of state-changing opcodes have the following check:"
      },
      {
        "type": "code",
        "code": "// constrain not in static call\nlet is_static = cb.call_context(None, CallContextFieldTag::IsStatic);\ncb.require_zero(\"is_static is false\", is_static.expr());",
        "language": "rust",
        "description": "Figure 9.1: zkevm-circuits/src/evm_circuit/execution/sstore.rs#L57-L59"
      },
      {
        "type": "text",
        "text": "Without this validation in place, a malicious prover could generate a proof of execution for a transaction involving the CREATE opcode within the context of a STATICCALL, leading to state divergence."
      },
      {
        "type": "text",
        "text": "Note that the SELFDESTRUCT opcode is disabled, but is also subject to the non-static constraint according to the Ethereum Yellow Paper. This should be taken into account if the opcode is implemented in the future."
      }
    ],
    "impact": "Alice deploys a constant-function automated market maker (AMM) smart contract AliceMM to the Scroll zkEVM. In each AMM transaction, AliceMM receives funds in token type A (or B), then calculates the exchange rate, then sends funds in token type B (or A). To calculate the exchange rate, AliceMM calls Bob's ComplicatedMath contract. Alice knows about reentrancy attacks and is careful to call ComplicatedMath only with STATICCALL. However, Bob has deployed a malicious version of ComplicatedMath that uses CREATE to call AliceMM in a reentrant fashion. Bob calls AliceMM with a malicious transaction that manipulates the exchange rate, then drains the contract of token A in exchange for a tiny amount of token B, resulting in loss of funds.",
    "recommendation": "Short term, add the constraint to validate that the execution context does not allow state-changing operations. Long term, add tests for the CREATE, CREATE2, LOGX, SSTORE, and CALL opcodes when called within a STATICCALL.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "ResponsibleOpcode table incorrectly handles CREATE and CREATE2",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-10",
    "target_file": "zkevm-circuits/src/evm_circuit/step.rs",
    "content": [
      {
        "type": "text",
        "text": "The ResponsibleOpcode table is used to attribute different execution states to particular sets of opcodes. For many opcodes, this table is the primary source of truth for which state they transition to. The SameContextGadget enforces that executing opcodes correctly use the corresponding state. For example, it enforces that the ADD opcode uses the ADD_SUB state."
      },
      {
        "type": "code",
        "code": "cb.add_lookup(\n \"Responsible opcode lookup\",\n Lookup::Fixed {\n tag: FixedTableTag::ResponsibleOpcode.expr(),\n values: [\n cb.execution_state().as_u64().expr(),\n opcode.expr(),\n 0.expr(),\n ],\n },\n );",
        "language": "rust",
        "description": "Figure 10.1: zkevm-circuits/src/evm_circuit/util/common_gadget.rs#48‚Äì58"
      },
      {
        "type": "text",
        "text": "This table is populated via the ExecutionState::responsible_opcodes method, which also is used for reporting execution statistics. This method does not handle the CREATE2 state, and incorrectly reports both CREATE and CREATE2 as the responsible opcodes for the CREATE state, as shown in figure 10.2:"
      },
      {
        "type": "code",
        "code": "Self::CREATE => vec![OpcodeId::CREATE, OpcodeId::CREATE2]",
        "language": "rust",
        "description": "Figure 10.2: zkevm-circuits/src/evm_circuit/step.rs#304"
      },
      {
        "type": "text",
        "text": "Since the CREATE and CREATE2 opcodes constrain the execution state in a way that does not use SameContextGadget, this does not cause any soundness issues. However, if a similar error were made for another opcode or state in the table, the resulting circuit may be either incomplete or underconstrained."
      }
    ],
    "impact": "",
    "recommendation": "Short term, fix the data in this table by correctly mapping the CREATE and CREATE2 states to the CREATE and CREATE2 opcodes, respectively. Long term, develop tests to check the consistency of the opcode table against the execution behavior.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "Elliptic curve parameters omitted from Fiat-Shamir",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "informational",
    "difficulty": "N/A",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL-11",
    "target_file": "Several files",
    "content": [
      {
        "type": "text",
        "text": "The Fiat-Shamir code in the snark-verifier patch does not incorporate the elliptic curve parameters into the transcript. Points are incorporated into the transcript using only the x and y coordinates, with no reference to the associated curve, and we are not able to find any instances where the curve parameters are explicitly added to a Fiat-Shamir transcript."
      },
      {
        "type": "code",
        "code": "fn common_ec_point(&mut self, ec_point: &C)-> Result<(), Error> {\n let coordinates =\n Option::<Coordinates<C>>::from(ec_point.coordinates()).ok_or_else(|| {\n Error::Transcript(\n io::ErrorKind::Other,\n \"Cannot write points at infinity to the transcript\".to_string(),\n )\n })?;\n [coordinates.x(), coordinates.y()].map(|coordinate| {\n self.buf.extend(coordinate.to_repr().as_ref().iter().rev().cloned());\n });\n Ok(())\n }",
        "language": "rust",
        "description": "Figure 11.1:snark-verifier/src/system/halo2/transcript/evm.rs#L173-L187"
      },
      {
        "type": "text",
        "text": "Non-interactive proofs must commit exactly to the statement being proven before any challenges are generated. If a prover can equivocate about attributes of the statement (e.g., which elliptic curve the points are supposed to be on), a proof for one statement may be passed off as a proof for another, as in the FrozenHeart class of vulnerabilities."
      },
      {
        "type": "text",
        "text": "The snark-verifier code is intended to be curve-agnostic, so a proof generated using one curve may be verified using a different elliptic curve that shares only the points present in the transcript, leading to identical challenge values but a different statement."
      },
      {
        "type": "text",
        "text": "In general, two different elliptic curves can share only a limited number of points, so the existing code may implicitly commit to the curve being used. However, we have not determined the exact threshold, and a detailed security proof should be done if that property is relied upon."
      },
      {
        "type": "text",
        "text": "In the Scroll zkEVM system, the prover and verifier use a fixed set of curve parameters, so it is not possible to convince Scroll software to accept a proof using another curve."
      }
    ],
    "impact": "",
    "recommendation": "Short term, include the curve parameters at the beginning of the Fiat-Shamir transcript. Long term, always consider including all public parameters of the system in the Fiat-Shamir transformations.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "The gas cost for the CALL opcode is underconstrained",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "high",
    "difficulty": "medium",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-12",
    "target_file": "zkevm-circuits/src/evm_circuit/execution/callop.rs",
    "content": [
      {
        "type": "text",
        "text": "The gas cost of the CALL-like opcodes (CALL, CALLCODE, DELEGATECALL, and STATICCALL) is not constrained, allowing a malicious prover to spend as much gas as desired in certain conditions. This allows free gas CALL operations if the prover sets this value to zero, or it can cause the transaction execution to terminate after the execution of the current opcode by defining a high gas cost. Both options could cause a state divergence from an execution following the EVM specification."
      },
      {
        "type": "text",
        "text": "Figure 12.1 shows the code that gets the witness cell step_gas_cost and then uses it unconstrained to set the gas cost of the current opcode. This happens when the call precheck conditions are valid (i.e., the call depth is valid, and the caller balance is enough to transfer the call value), and the called address has no associated code:"
      },
      {
        "type": "code",
        "code": "let step_gas_cost = cb.query_cell();\nlet memory_expansion = call_gadget.memory_expansion.clone();\ncb.condition(\n and::expr([\n no_callee_code.expr(),\n not::expr(is_precompile.expr()),\n is_precheck_ok.expr(),\n ]),\n |cb| {\n // Save caller's call state\n for field_tag in [\n CallContextFieldTag::LastCalleeId,\n CallContextFieldTag::LastCalleeReturnDataOffset,\n CallContextFieldTag::LastCalleeReturnDataLength,\n ] {\n cb.call_context_lookup(true.expr(), None, field_tag, 0.expr());\n }\n },\n );\ncb.condition(\n and::expr([is_precompile.expr(), is_precheck_ok.expr()]),\n |cb| {\n // Save caller's call state for (field_tag, value) in [\n (CallContextFieldTag::LastCalleeId, callee_call_id.expr()),\n (CallContextFieldTag::LastCalleeReturnDataOffset, 0.expr()),\n (\n CallContextFieldTag::LastCalleeReturnDataLength,\n return_data_len.expr(),\n ),\n ] {\n cb.call_context_lookup(true.expr(), None, field_tag, value);\n }\n },\n );\ncb.condition(\n and::expr([call_gadget.is_empty_code_hash.expr(), is_precheck_ok.expr()]),\n |cb| {\n // For CALLCODE opcode, it has an extra stack pop `value` and one account\n read\n // for caller balance (+2).\n //\n // For DELEGATECALL opcode, it has two extra call context lookups for\n current\n // caller address and value (+2).\n //\n // No extra lookups for STATICCALL opcode.\n let transfer_rwc_delta =\n is_call.expr() * not::expr(transfer.value_is_zero.expr()) * 2.expr();\n let rw_counter_delta = 21.expr()\n + is_call.expr() * 1.expr()\n + transfer_rwc_delta.clone()\n + is_callcode.expr()\n + is_delegatecall.expr() * 2.expr()\n + precompile_memory_writes;\n cb.require_step_state_transition(StepStateTransition {\n rw_counter: Delta(rw_counter_delta),\n program_counter: Delta(1.expr()),\n stack_pointer: Delta(stack_pointer_delta.expr()),\n gas_left: Delta(-step_gas_cost.expr()),\n",
        "language": "rust",
        "description": "Figure 12.1:zkevm-circuits/src/evm_circuit/execution/callop.rs#L255-L314"
      }
    ],
    "impact": "A malicious prover generates and submits a proof of execution for a transaction involving a CALL to an address with empty code that would normally exhaust the transaction's gas. By defining the gas cost as zero, the transaction succeeds. However, this execution does not match the correct EVM semantics, leading to state divergence and loss of funds",
    "recommendation": "Short term, add constraints to correctly compute the gas cost for the call opcodes. Long term, add negative tests ensuring that EVM traces gas costs do not satisfy the circuit constraints.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "Unconstrained opcodes allow nondeterministic execution",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "high",
    "difficulty": "medium",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-13",
    "target_file": "zkevm-circuits/src/evm_circuit/execution/{return_revert.rs,error_code_store.rs,error_invalid_creation_code.rs,error_precompile_failed.rs}",
    "content": [
      {
        "type": "text",
        "text": "Several opcodes are missing constraints that ensure the correct correspondence between execution state and opcode, allowing a malicious prover to hijack the transaction execution."
      },
      {
        "type": "text",
        "text": "The Scroll zkEVM circuit checks the correct execution of a transaction by verifying a prover-generated execution trace. This execution trace consists of a series of states, each represented by a constructor of the ExecutionState enum. Each state corresponds to an 'execution gadget' in the circuit, which checks preconditions and enforces correct updates to EVM data structures such as memory and storage."
      },
      {
        "type": "text",
        "text": "In the Scroll codebase, the correspondence between the execution state and opcode is enforced entirely by these gadgets. Most execution gadgets use a SameContextGadget to check that the current (execution state, opcode) pair appears in the Responsible Opcode table. Execution gadgets that do not use SameContextGadget must check that the current opcode is correct for the current state through other means."
      },
      {
        "type": "code",
        "code": "cb.add_lookup(\n \"Responsible opcode lookup\",\n Lookup::Fixed {\n tag: FixedTableTag::ResponsibleOpcode.expr(),\n values: [\n cb.execution_state().as_u64().expr(),\n opcode.expr(),\n 0.expr(),\n ],\n },\n );",
        "language": "rust",
        "description": "Figure 13.1:zkevm-circuits/src/evm_circuit/util/common_gadget.rs#48‚Äì58"
      },
      {
        "type": "text",
        "text": "Because checking the opcode/state correspondence is the responsibility of each execution gadget, if any execution gadget fails to properly constrain the opcode, a malicious prover can replace another execution step with that gadget's execution state."
      },
      {
        "type": "text",
        "text": "For example, the ReturnRevertGadget does not enforce that the opcode is either RETURN or REVERT. A malicious prover can replace any execution state with a RETURN_REVERT state, causing the execution to halt at an arbitrary point, and potentially returning data depending on the values currently on the stack and in memory. If the transaction creates a contract, a malicious prover can replace the code being deployed with values available in memory at other points in the initcode's execution."
      },
      {
        "type": "code",
        "code": "impl<F: Field> ExecutionGadget<F> for ReturnRevertGadget<F> {\n const NAME: &'static str = \"RETURN_REVERT\";\n const EXECUTION_STATE: ExecutionState = ExecutionState::RETURN_REVERT;\n fn configure(cb: &mut ConstraintBuilder<F>)-> Self {\n let opcode = cb.query_cell();\n cb.opcode_lookup(opcode.expr(), 1.expr());\n let offset = cb.query_cell_phase2();\n let length = cb.query_word_rlc();\n cb.stack_pop(offset.expr());\n cb.stack_pop(length.expr());\n let range = MemoryAddressGadget::construct(cb, offset, length);\n let is_success = cb.call_context(None, CallContextFieldTag::IsSuccess);\n cb.require_boolean(\"is_success is boolean\", is_success.expr());\n // cb.require_equal(\n// \"if is_success, opcode is RETURN. if not, opcode is REVERT\",\n// opcode.expr(),\n// is_success.expr() * OpcodeId::RETURN.expr()\n// + not::expr(is_success.expr()) * OpcodeId::REVERT.expr(),\n// );\n ",
        "language": "rust",
        "description": "Figure 13.3: zkevm-circuits/src/evm_circuit/execution/return_revert.rs#55‚Äì77"
      },
      {
        "type": "text",
        "text": "In total, four gadgets were found that do not constrain the opcode to match the current execution state: ErrorCodeStoreGadget, ErrorPrecompileFailedGadget, ErrorInvalidCreationCodeGadget, and ReturnRevertGadget."
      }
    ],
    "impact": "Suppose a bridge between two blockchains uses the Scroll zkEVM to bridge assets between them. Alice crafts a transaction which, when an opcode such as an ADD is instead executed as a RETURN, will erroneously withdraw funds from the bridge. She generates a malicious execution trace and submits a zkEVM proof to the bridge, which allows her to drain the bridge of funds.",
    "recommendation": "Short term, add the missing opcode checks to ErrorCodeStoreGadget, ErrorPrecompileFailedGadget, ErrorInvalidCreationCodeGadget, and ReturnRevertGadget. Long term, consider redesigning the way that opcodes map to states. The current design means that any execution gadget that fails to constrain the opcode will cause nondeterministic execution. If, instead, each execution gadget has an enable input, and the EVM circuit deterministically selects which gadget(s) have enable == 1, an underconstrained execution gadget can affect only the behavior of opcodes that are supposed to use that gadget.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "Nondeterministic execution of ReturnDataCopyGadget and ErrorReturnDataOutOfBoundGadget",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "high",
    "difficulty": "high",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-14",
    "target_file": "zkevm-circuits/src/evm_circuit/execution/returndatacopy.rs",
    "content": [
      {
        "type": "text",
        "text": "The gadget that implements the successful execution of the RETURNDATACOPY opcode is underconstrained, allowing a malicious prover to successfully execute the opcode when it is in an error condition for particular opcode inputs. This allows the prover to cause state divergence from a correct EVM execution."
      },
      {
        "type": "text",
        "text": "The error gadget implementation constrains the trace to have at least one true error condition for the RETURNDATACOPY opcode. These constraints check overflow conditions on the stack values and their sum."
      },
      {
        "type": "code",
        "code": "// Check if `data_offset` is Uint64 overflow.\nlet data_offset_larger_u64 = sum::expr(&data_offset.cells[N_BYTES_U64..]);\nlet is_data_offset_within_u64 = IsZeroGadget::construct(cb, data_offset_larger_u64);\n// Check if `remainder_end` is Uint64 overflow.\nlet sum = AddWordsGadget::construct(cb, [data_offset, size], remainder_end.clone());\nlet is_end_u256_overflow = sum.carry().as_ref().unwrap();\nlet remainder_end_larger_u64 = sum::expr(&remainder_end.cells[N_BYTES_U64..]);\nlet is_remainder_end_within_u64 = IsZeroGadget::construct(cb,\nremainder_end_larger_u64);\n// check if `remainder_end` exceeds return data length.\nlet is_remainder_end_exceed_len = LtGadget::construct(\ncb,\nreturn_data_length.expr(),\nfrom_bytes::expr(&remainder_end.cells[..N_BYTES_U64]),\n);\n// Need to check if `data_offset + size` is U256 overflow via `AddWordsGadget`\ncarry. If\n// yes, it should be also an error of return data out of bound.\ncb.require_equal(\n\"Any of [data_offset > u64::MAX, data_offset + size > U256::MAX, remainder_end >\nu64::MAX, remainder_end > return_data_length] occurs\",\nor::expr([\n// data_offset > u64::MAXnot::expr(is_data_offset_within_u64.expr()),\n// data_offset + size > U256::MAX\nis_end_u256_overflow.expr(),\n// remainder_end > u64::MAX\nnot::expr(is_remainder_end_within_u64.expr()),\n// remainder_end > return_data_length\nis_remainder_end_exceed_len.expr(),\n]),\n1.expr(),\n);",
        "language": "rust",
        "description": "Figure 14.1: evm_circuit/execution/error_return_data_oo_bound.rs#L68-L101"
      },
      {
        "type": "text",
        "text": "On the successful execution path, these conditions are not checked to be false. In fact, if data_offset = WORD_CELL_MAX, size = 0, and return_data_size < 232, the ReturnDataCopyGadget constraints are satisfied. This case is an error state because data_offset is larger than u64::MAX."
      },
      {
        "type": "code",
        "code": "// 3. contraints for copy: copy overflow check\n// i.e., offset + size <= return_data_size\nlet in_bound_check = RangeCheckGadget::construct(\ncb,\nreturn_data_size.expr()- (from_bytes::expr(&data_offset.cells) + from_bytes::expr(&size.cells)),\n);\n// 4. memory copy\n// Construct memory address in the destination (memory) to which we copy memory.\nlet dst_memory_addr = MemoryAddressGadget::construct(cb, dest_offset, size);\n// Calculate the next memory size and the gas cost for this memory\n// access. This also accounts for the dynamic gas required to copy bytes to\n// memory.\nlet memory_expansion = MemoryExpansionGadget::construct(cb,\n[dst_memory_addr.address()]);\nlet memory_copier_gas = MemoryCopierGasGadget::construct(\ncb,\ndst_memory_addr.length(),\nmemory_expansion.gas_cost(),\n);\nlet copy_rwc",
        "language": "rust",
        "description": "Figure 14.2: evm_circuit/execution/returndatacopy.rs#L99-L141"
      },
      {
        "type": "text",
        "text": "In sum, the prover could decide whether the execution would correctly halt with the ErrorReturnDataOutOfBoundGadget error or if it would successfully execute the RETURNDATACOPY opcode."
      }
    ],
    "impact": "A malicious prover generates and submits a proof of execution for a transaction involving a RETURNDATACOPY with particular arguments. Due to the missing validations on the successful execution state, the prover could choose to successfully execute the opcode, or halt the execution, leading to state divergence and loss of funds.",
    "recommendation": "Short term, add constraints to ensure that the successful execution state is disjoint from the error execution state. Long term, investigate other error states and their associated opcode implementations to guarantee that their execution state is disjoint and cannot be chosen by a malicious prover.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "Many RW counter updates are magic numbers",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-15",
    "target_file": "zkevm-circuits/src/evm_circuit/execution/",
    "content": [
      {
        "type": "text",
        "text": "The zkEVM circuit checks memory read and write operations in a transaction's execution trace by performing lookups into the RW table. Within the circuit, updates to the state variable, which tracks the total number of read/write operations, are frequently specified with a manual count. That manual process is error-prone and difficult to check, and it can be replaced with a calculated value in all cases we have seen."
      },
      {
        "type": "text",
        "text": "The read-write consistency checks in the zkEVM circuit require the overall block to have a correct count of the total number of lookups into the RW table. If that count is incorrect, a malicious prover can insert extraneous write operations into the table and choose an arbitrary result for any memory read. Each execution gadget is individually responsible for creating a StepStateTransition that enforces the correct update of the rw_counter field of StepState."
      },
      {
        "type": "code",
        "code": "// ADD: Pop a and b from the stack, push c on the stack\n// SUB: Pop c and b from the stack, push a on the stack\ncb.stack_pop(select::expr(is_sub.expr().0, c.expr(), a.expr()));\ncb.stack_pop(b.expr());\ncb.stack_push(select::expr(is_sub.expr().0, a.expr(), c.expr()));\n// State transition\nlet step_state_transition = StepStateTransition {\nrw_counter: Delta(3.expr()),\nprogram_counter: Delta(1.expr()),\nstack_pointer: Delta(1.expr()),\ngas_left: Delta(-OpcodeId::ADD.constant_gas_cost().expr()),\n..StepStateTransition::default()\n};\nlet same_context = SameContextGadget::construct(cb, opcode, step_state_transition);",
        "language": "rust",
        "description": "Figure 15.1:The rw_counter update in AddSubGadget(zkevm-circuits/src/evm_circuit/execution/add_sub.rs#51‚Äì65)"
      },
      {
        "type": "text",
        "text": "Many execution gadgets have much more complicated rw_counter updates, which are difficult to check for correctness. For example, ErrorInvalidOpcodeGadget does not seem to contain any RW lookups at all, but provides the value 2 to CommonErrorGadget, while ErrorWriteProtectionGadget seems to have either one or four RW lookups depending on the value of is_call, yet provides a 0 to CommonErrorGadget."
      },
      {
        "type": "text",
        "text": "In general, the process of counting the number of RW lookups in any given gadget is both subtle and tedious when done manually, but cases that use ConstraintBuilder::rw_counter_offset to determine that offset are effectively trivial when checking for correctness."
      }
    ],
    "impact": "",
    "recommendation": "Short term, replace magic-number RW counter updates with computed values, such as those provided by ConstraintBuilder::rw_counter_offset. Long term, consider redesigning the API for building StepStateTransitions. Since all RW lookups are performed via the ConstraintBuilder API, updates to simple counter-style state variables, such as the stack pointer and the RW counter, can typically be computed rather than manually specified. If the easy-to-calculate fields are always computed, that core computation can be checked for correctness; as a result, all uses will be correct by construction.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "Native PCS accumulation deciders accept an empty vector",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "medium",
    "difficulty": "low",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-16",
    "target_file": "snark-verifier/src/pcs/{kzg,ipa}/decider.rs",
    "content": [
      {
        "type": "text",
        "text": "Both the KZG and IPA native decide_all implementations accept an empty vector of accumulators. This can allow an attacker to bypass verification by submitting an empty vector."
      },
      {
        "type": "code",
        "code": "fn decide_all(\n dk: &Self::DecidingKey,\n accumulators: Vec<IpaAccumulator<C, NativeLoader>>, \n )-> bool {\n !accumulators\n .into_iter()\n .any(|accumulator| !Self::decide(dk, accumulator))\n ",
        "language": "rust",
        "description": "Figure 16.1:snark-verifier/src/pcs/kzg/decider.rs#L54-L69"
      },
      {
        "type": "text",
        "text": "This function contrasts with the EVM loader implementation that asserts that the accumulator vector is non-empty:"
      },
      {
        "type": "code",
        "code": "fn decide_all(\n dk: &Self::DecidingKey,\n mut accumulators: Vec<KzgAccumulator<M::G1Affine, Rc<EvmLoader>>>,\n )-> Result<(), Error> {\n assert!(!accumulators.is_empty());\n",
        "language": "rust",
        "description": "Figure 16.2:snark-verifier/src/pcs/kzg/decider.rs#L120-L124"
      }
    ],
    "impact": "An attacker is able to control the arguments to decide_all and pass an empty vector, causing the verification function to accept an invalid proof.",
    "recommendation": "Short term, add an assertion that validates that the vector is non-empty. Long term, add negative tests for verification and validation functions, ensuring that wrong or invalid arguments are not accepted.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "The ErrorOOGSloadSstore and the ErrorOOGLog gadgets have redundant table lookups",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-17",
    "target_file": "zkevm-circuits/src/evm_circuit/execution/{error_oog_sload_sstore,error_oog_log}.rs",
    "content": [
      {
        "type": "text",
        "text": "Both the ErrorOOGSloadSstore and the ErrorOOGLog gadgets do an RW table lookup to check whether the current call is within a static context. However, the lookup result is not used in any subsequent constraint, making the lookup redundant."
      },
      {
        "type": "code",
        "code": "// constrain not in static call\nlet is_static_call = cb.call_context(None, CallContextFieldTag::IsStatic);\n//cb.require_zero(\"is_static_call is false in LOGN\", is_static_call.expr());",
        "language": "rust",
        "description": "Figure 17.1:evm_circuit/execution/error_oog_log.rs#L53-L55."
      },
      {
        "type": "text",
        "text": "The commented-out constraint would provide a clear state distinction between the ErrorOOGLogGadget error case and the ErrorWriteProtectionGadget, preventing an attacker from arbitrarily choosing one of the error states at will."
      },
      {
        "type": "text",
        "text": "As far as we know, in this case, these two different error execution states do not translate to diverging EVM states; thus, this finding's severity is informational."
      }
    ],
    "impact": "",
    "recommendation": "Short term, decide whether to remove the RW table lookup or to uncomment the non-static environment constraint in both the ErrorOOGSloadSstore and ErrorOOGLog gadgets. Investigate all commented-out constraints and remove them from the codebase, or enable them if they are necessary.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "The State circuit does not enforce transaction receipt constraints",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-18",
    "target_file": "zkevm-circuits/src/state_circuit/constraint_builder.rs",
    "content": [
      {
        "type": "text",
        "text": "The implementation of the State circuit does not enforce transaction receipt constraints. Currently, these have an unsatisfiable constraint (1 == 0), and the function that implements them, build_tx_receipt_constraints, is not called in the ConstraintBuilder::build function."
      },
      {
        "type": "code",
        "code": "fn build_tx_receipt_constraints(&mut self, q: &Queries<F>) {\n // TODO: implement TxReceipt constraints\n self.require_equal(\"TxReceipt rows not implemented\", 1.expr(), 0.expr());\n self.require_equal(\n \"state_root is unchanged for TxReceipt\",\n q.state_root(),\n q.state_root_prev(),\n );\n self.require_zero(\n \"value_prev_column is 0 for TxReceipt\",\n q.value_prev_column(),\n );\n }",
        "language": "rust",
        "description": "Figure 18.1:state_circuit/constraint_builder.rs#L511-L524."
      }
    ],
    "impact": "",
    "recommendation": "Short term, implement the transaction receipt constraints and add them to the constraint builder build function. Long term, enable the dead_code compiler lint by removing the `#![allow(dead_code)]` line in zkevm-circuits/src/lib.rs and fix all warnings.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "The EXP opcode has an unused witness",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-20",
    "target_file": "zkevm-circuits/src/evm_circuit/execution/exp.rs",
    "content": [
      {
        "type": "text",
        "text": "The EXP opcode defines a witness that is used only in a constraint requiring its value to be zero. The constraint label suggests that it was used to validate the base_sq witness value at some point in the code development, but this is now done in the exponentiation table circuit."
      },
      {
        "type": "code",
        "code": "let zero_rlc = cb.query_word_rlc();\n cb.require_zero(\n \"base * base + c == base^2 (c == 0)\",\n sum::expr(&zero_rlc.cells),\n );",
        "language": "rust",
        "description": "Figure 20.1: evm_circuit/execution/exp.rs#L93-L97."
      }
    ],
    "impact": "",
    "recommendation": "Short term, remove the zero_rlc variable and its constraint from the EXP opcode gadget.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "The bn_to_field function silently truncates big integers",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "low",
    "difficulty": "low",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-21",
    "target_file": "misc-precompiled-circuit/src/utils/mod.rs",
    "content": [
      {
        "type": "text",
        "text": "The `bn_to_field` function converts arbitrary length integers into a field element. However, if the byte representation of the integers is larger than 64 bytes, the big integer bytes will be silently truncated. This means that any two integers with the same 512 least significant bits will lead to the same field element."
      },
      {
        "type": "code",
        "code": "pub fn bn_to_field<F: FieldExt>(bn: &BigUint)-> F {\n let mut bytes = bn.to_bytes_le();\n bytes.resize(64, 0);\n F::from_bytes_wide(&bytes.try_into().unwrap())\n }",
        "language": "rust",
        "description": "Figure 21.1: src/utils/mod.rs#L10-L15."
      },
      {
        "type": "text",
        "text": "Instead, the function should check whether the big integer fits into the field capacity by using the F::capacity constant. This would guarantee a faithful representation of the big integer into the field element and a successful reconversion back to the BigUint type."
      },
      {
        "type": "text",
        "text": "Note that the `from_bytes_wide` function will also reduce the element modulo the field order so that it is represented as a field element."
      }
    ],
    "impact": "An attacker provides two big integers with the same 512 least significant bits to the `bn_to_field` function, causing it to return the same element. When these elements are used in future operations, they will lead to the same result, even though they were different.",
    "recommendation": "Short term, add documentation to the function explaining the intended behavior; add checks that validate that the big integer is representable in the chosen field.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "The field_to_bn function depends on implementation-specific details of the underlying field",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "low",
    "difficulty": "high",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-22",
    "target_file": "misc-precompiled-circuit/src/utils/mod.rs",
    "content": [
      {
        "type": "text",
        "text": "The implementation of the field_to_bn function calls the to_repr function on the value of the input f when constructing the little-endian binary representation of the input f."
      },
      {
        "type": "code",
        "code": "pub fn field_to_bn<F: FieldExt>(f: &F)-> BigUint {\n let bytes = f.to_repr();\n BigUint::from_bytes_le(bytes.as_ref())\n }",
        "language": "rust",
        "description": "Figure 22.1:The implementation of field_to_bn expects to_repr to return a little-endian representation of the value of f.(src/utils/mod.rs#L5-L8)."
      },
      {
        "type": "text",
        "text": "However, according to the documentation of the PrimeField trait, the endianness returned by PrimeField::to_repr is implementation-dependent and may be different depending on the underlying field."
      },
      {
        "type": "code",
        "code": "/// Converts an element of the prime field into the standard byte representation for\n/// this field.\n///\n/// The endianness of the byte representation is implementation-specific. Generic\n/// encodings of field elements should be treated as opaque.\nfn to_repr(&self)-> Self::Repr;",
        "language": "rust",
        "description": "Figure 22.2:The value returned by to_repr is implementation-dependent and should be treated as opaque by the user."
      }
    ],
    "impact": "The field_to_bn function is reused with a scalar field F that uses a different internal representation of the elements of F. The resulting big integer might not correspond to the same field element.",
    "recommendation": "Short term, implement a function that assuredly returns a little-endian representation of the field element. Long term, review the use of third-party APIs to ensure that the codebase does not depend on the internal representation of data.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "The values of the bytecode table tag column are not constrained to be HEADER or BYTE",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "informational",
    "difficulty": "high",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-23",
    "target_file": "zkevm-circuits/src/bytecode_circuit/circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The bytecode table has a column that indicates the TAG of each row. Currently, the TAG cells are assigned only a HEADER or a BYTE value. However, the circuit does not constrain the TAG value of each row to accept only these values. This missing constraint does not cause a direct soundness issue because of other indirect constraints and how the bytecode circuit is implemented, but future code refactorings could cause the issue to become exploitable."
      },
      {
        "type": "text",
        "text": "If a malicious prover were to provide a non-Boolean value, since the `not::expr` and  `and::expr` functions operate under the assumption that their input values are Boolean, the circuit could have soundness issues. However, this would require satisfying multiple constraints simultaneously, which makes it difficult to exploit in the current implementation."
      }
    ],
    "impact": "Anticipating a future addition to the TAG enum, a developer decides to reimplement the is_header, is_byte, and transition selectors by requiring that the TAG cell value equals the desired enum value. If they omit the check that the TAG value must be restricted to the enum's value set, a malicious prover would be able to break the transition constraints by inserting a row with a tag value different from HEADER or BYTE.",
    "recommendation": "Short term, require that the TAG column is Boolean in the constraint system. Long term, document which constraints need to be changed in case the BytecodeFieldTag enum is extended. Add stricter types to the Boolean functions in gadgets/src/util.rs to prevent potential soundness issues.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "Unconstrained columns on the bytecode HEADER rows",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-24",
    "target_file": "zkevm-circuits/src/bytecode_circuit/{circuit/to_poseidon_hash.rs,circuit.rs}",
    "content": [
      {
        "type": "text",
        "text": "The bytecode table HEADER rows have two unconstrained columns, is_code and field_input, on the Poseidon bytecode extended columns. The lack of constraint on these columns does not seem to pose any soundness issue, but constraining these columns would serve as defense-in-depth, preventing the circuit's flexibility from allowing a malicious prover to exploit a soundness issue if a vulnerability is introduced in the future."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"Header row\", |meta| {\n    let mut cb = BaseConstraintBuilder::default();\n    cb.require_zero(\n        \"cur.index == 0\",\n        meta.query_advice(bytecode_table.index, Rotation::cur()),\n    );\n    cb.require_equal(\n        \"cur.value == cur.length\",\n        meta.query_advice(bytecode_table.value, Rotation::cur()),\n        meta.query_advice(length, Rotation::cur()),\n    );\n    cb.gate(and::expr(vec![\n        meta.query_fixed(q_enable, Rotation::cur()),\n        not::expr(meta.query_fixed(q_last, Rotation::cur())),\n        is_header(meta),\n    ]))\n});",
        "language": "rust",
        "description": "Figure 24.1:zkevm-circuits/src/bytecode_circuit/circuit.rs#L179-L201."
      }
    ],
    "impact": "",
    "recommendation": "Short term, add constraints for the is_code and the field_input rows in the HEADER rows of the bytecode table. Long term, document all table constraints and ensure that each type of row constrains all columns.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "decompose_limb does not work as intended",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-25",
    "target_file": "misc-precompiled-circuit/src/circuits/modexp.rs",
    "content": [
      {
        "type": "text",
        "text": "The for loop within decompose_limb requires bool_limbs to contain at least 31 elements to be correctly indexed from 0 to 30. Furthermore, if limbsize is large enough, then the truncate operation does not grow bool_limbs to the correct size, as to_radix_le produces a minimal Vec without any trailing zeroes."
      },
      {
        "type": "code",
        "code": "let mut bool_limbs = field_to_bn(&limb.value).to_radix_le(2);\nbool_limbs.truncate(limbsize);\nbool_limbs.reverse();\nlet mut v = F::zero();\nfor i in 0..27 {\n    let l0 = F::from_u128(bool_limbs[i] as u128);\n    let l1 = F::from_u128(bool_limbs[i+1] as u128);\n    let l2 = F::from_u128(bool_limbs[i+2] as u128);\n    let l3 = F::from_u128(bool_limbs[i+3] as u128);",
        "language": "rust",
        "description": "Figure 25.1: misc-precompiled-circuit/src/circuits/modexp.rs#L514-L522."
      },
      {
        "type": "text",
        "text": "Additionally, the Boolean limbs are not properly constrained to be Boolean, but this is mentioned in a 'TODO' comment."
      },
      {
        "type": "text",
        "text": "Overall, it can be concluded that the `decompose_limb` needs further development, but its intended purpose and usage within `mod_exp` is clear."
      }
    ],
    "impact": "",
    "recommendation": "Short term, correctly implement `decompose_limb`. This will allow for proper testing of the `mod_exp` circuit.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "Zero modulus will cause a panic",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "medium",
    "difficulty": "low",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-26",
    "target_file": "misc-precompiled-circuit/src/circuits/modexp.rs",
    "content": [
      {
        "type": "text",
        "text": "According to EVM specifications, if the modulus is zero, then the result of `mod_exp` is zero regardless of the input. The current `mod_exp` code relies on successive calls to `mod_mult` with the passed-in modulus, but the `mod_mult` function computes a quotient that will panic."
      },
      {
        "type": "code",
        "code": "let bn_quotient = bn_mult.clone().div(bn_modulus.clone()); //div_rem",
        "language": "rust",
        "description": "Figure 26.1: misc-precompiled-circuit/src/circuits/modexp.rs#L470."
      },
      {
        "type": "text",
        "text": "This results in differing behavior between the scroll `mod_exp` precompile and the standard EVM precompile, which may cause some existing systems that depend on this behavior to not work as intended."
      }
    ],
    "impact": "",
    "recommendation": "Short term, correctly handle the zero modulus case of mod_exp. Add tests to the `mod_exp` circuit, including some that exercise its edge cases: the zero exponent case and the zero modulus case.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title": "The ConstraintBuilder::condition API is dangerous",
    "source": "Trail Of Bits",
    "protocol": "Scroll ZkEVM",
    "protocol_type": "ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal", "Joe Doyle", "Opal Wright", "Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": "a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "informational",
    "difficulty": "high",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-27",
    "target_file": "Several files",
    "content": [
      {
        "type": "text",
        "text": "The ConstraintBuilder implements several useful ways of constructing constraints. One case is when constraints should be added and conditioned by a particular value. If the value is true, the constraints must be satisfied; otherwise, they do not need to be satisfied. However, a problem arises if a developer forgets to consider that a new ConstraintBuilder function is called within the context of a condition."
      },
      {
        "type": "text",
        "text": "All functions in the ConstraintBuilder API must consider the case where they are being called from inside a conditioned scope. If these functions add constraints or change values irrespective of the condition value, they will lead to unintended results."
      },
      {
        "type": "text",
        "text": "As an example, the opcode_lookup function updates the program_counter_offset regardless of the current condition value."
      },
      {
        "type": "code",
        "code": "pub(crate) fn opcode_lookup(&mut self, opcode: Expression<F>, is_code: Expression<F>) { self.opcode_lookup_at( self.curr.state.program_counter.expr() + self.program_counter_offset.expr(), opcode, is_code, ); self.program_counter_offset += 1; }",
        "language": "rust",
        "description": "Figure 27.1:evm_circuit/util/constraint_builder.rs#608‚Äì615."
      },
      {
        "type": "text",
        "text": "When used in a conditional context, the program_counter_offset will be incremented irrespective of the condition value."
      },
      {
        "type": "code",
        "code": "const NAME: &'static str = \"STOP\"; const EXECUTION_STATE: ExecutionState = ExecutionState::STOP; fn configure(cb: &mut ConstraintBuilder<F>)-> Self { let code_length = cb.query_cell(); cb.bytecode_length(cb.curr.state.code_hash.expr(), code_length.expr());  let is_within_range = LtGadget::construct(cb, cb.curr.state.program_counter.expr(), code_length.expr()); let opcode = cb.query_cell(); cb.condition(is_within_range.expr(), |cb| { cb.opcode_lookup(opcode.expr(), 1.expr()); }); }",
        "language": "rust",
        "description": "Figure 27.2: src/evm_circuit/execution/stop.rs#33‚Äì45."
      },
      {
        "type": "text",
        "text": "The provided argument to the ConstraintBuilder::condition function must also be ensured to be Boolean. Certain functions assume this, and they would have unexpected results otherwise."
      },
      {
        "type": "code",
        "code": "const NAME: &'static str = \"STOP\"; const EXECUTION_STATE: ExecutionState = ExecutionState::STOP; fn configure(cb: &mut ConstraintBuilder<F>)-> Self { let code_length = cb.query_cell(); cb.bytecode_length(cb.curr.state.code_hash.expr(), code_length.expr());  let is_within_range = LtGadget::construct(cb, cb.curr.state.program_counter.expr(), code_length.expr());  let opcode = cb.query_cell(); cb.condition(is_within_range.expr(), |cb| { cb.opcode_lookup(opcode.expr(), 1.expr()); }); }",
        "language": "rust",
        "description": "Figure 27.3: evm_circuit/util/constraint_builder.rs#1160‚Äì1169."
      },
      {
        "type": "text",
        "text": "The ConstraintBuilder::gate function is another dangerous pattern that should be reconsidered and documented. In its current state, the function clones all constraints and gates them with the provided selector, returning these new gated constraints. It does not change the current constraints, which might be an interpretation that a new developer might have about the function. We have not seen incorrect usage of this particular pattern."
      }
    ],
    "impact": "",
    "recommendation": "Short term, redesign the ConstraintBuilder API, especially with respect to the condition function. Add new Rust types to ensure that the condition expression is Boolean. Add the #[must_use] attribute to the ConstraintBuilder::gate function.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title":"The EXTCODECOPY opcode implementation does not work when the account address does not exist",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZkEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","Opal Wright","Will Song"],
    "scope": [
      {
        "name": "zkevm-circuits",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "commit_hash": "e8bcb23e1f303bd6e0dc52924b0ed85710b8a016"
      },
      {
        "name": "snark-verifier code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/snark-verifier/pull/2",
        "commit_hash": "a3d0a5ab48522bc533686da3ea8400282c91f536"
      },
      {
        "name": "modexp",
        "description": "",
        "repository": "https://github.com/scroll-tech/misc-precompiled-circuit/tree/05725ec61d52d29a063395b0a1130467bee0d2f1",
        "commit_hash": "05725ec61d52d29a063395b0a1130467bee0d2f1"
      },
      {
        "name": "halo2-lib code diff",
        "description": "",
        "repository": "https://github.com/scroll-tech/halo2-lib/pull/8",
        "commit_hash": " a805052->b1d1567"
      },
      {
        "name": "Bytecode circuit",
        "description": "",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/44000e55eddaec42da958f2555d9bdeec8b865c2/zkevm-circuits/src/bytecode_circuit",
        "commit_hash": "44000e55eddaec42da958f2555d9bdeec8b865c2"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL-28",
    "target_file": "zkevm-circuits/src/evm_circuit/execution/extcodecopy.rs",
    "content": [
      {
        "type": "text",
        "text": "The current implementation of the EXTCODECOPY opcode does not consider the case where the account address does not exist. This is documented in a code comment, so the Scroll team should be aware of it."   
      },  
                                                                                                                                  
      {
        "type":"code",
        "code":"// TODO: If external_address doesn't exist, we will get code_hash = 0. With  // this value, the bytecode_length lookup will not work, and the copy  // from code_hash = 0 will not work. We should use EMPTY_HASH when  // code_hash = 0. cb.bytecode_length(code_hash.expr(), code_size.expr());",
                                        
        "language":"rust",
        "description":"Figure 28.1: zkevm-circuits/src/evm_circuit/execution/extcodecopy.rs#84‚Äì88."
      }                           
    ],
    "impact":"",
    "recommendation":"Short term, implement the missing functionality. Add tests to ensure its correctness. Long term, look for all ‚ÄúTODO‚Äù items in the codebase and triage them into an organized issue tracker. Address these items in terms of priority.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-04-scroll-zkEVM-wave1-securityreview.pdf"
    }
  },
  {
    "title":"Lack of domain separation allows proof forgery",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "high",
    "difficulty": "medium",
    "type": "Cryptography",
    "finding_id": "TOB-ZKTRIE-1",
    "target_file": "trie/zk_trie_node.go",
    "content": [
      {
        "type": "text",
        "text": "Merkle trees are nested tree data structures in which the hash of each branch node depends upon the hashes of its children. The hash of each node is then assumed to uniquely represent the subtree of which that node is a root. However, that assumption may be false if a leaf node can have the same hash as a branch node. A general method for preventing leaf and branch nodes from colliding in this way is domain separation. That is, given a hash function ùêª, define the hash of a leaf to be ùêª(ùëì(ùëôùëíùëéùëì_ùëëùëéùë°ùëé)) and the hash of a branch to be ùêª(ùëî(ùëèùëüùëéùëõùëê‚Ñé_ùëëùëéùë°ùëé)), where ùëì and ùëî are encoding functions that can never return the same result (perhaps because ùëì‚Äôs return values all start with the byte 0 and ùëî‚Äôs all start with the byte 1). Without domain separation, a malicious entity may be able to insert a leaf into the tree that can be later used as a branch in a Merkle path."   
      },  

      {
        "type": "text",
        "text": "In zktrie, the hash for a node is defined by the NodeHash method, shown in figure 1.1. As shown in the highlighted portions, the hash of a branch node is HashElems(n.ChildL,n.ChildR), while the hash of a leaf node is HashElems(1,n.NodeKey,n.valueHash)."   
      },
                                                                                                                                  
      {
        "type": "code",
        "code": "// LeafHash computes the key of a leaf node given the hIndex and hValue of the\n// entry of the leaf.\nfunc LeafHash(k, v *zkt.Hash) (*zkt.Hash, error) {\n    return zkt.HashElems(big.NewInt(1), k.BigInt(), v.BigInt())\n}\n\n// NodeHash computes the hash digest of the node by hashing the content in a\n// specific way for each type of node. This key is used as the hash of the\n// Merkle tree for each node.\nfunc (n *Node) NodeHash() (*zkt.Hash, error) {\n    if n.nodeHash == nil { // Cache the key to avoid repeated hash computations.\n        // NOTE: We are not using the type to calculate the hash!\n        switch n.Type {\n        case NodeTypeParent: // H(ChildL || ChildR)\n            var err error\n            n.nodeHash, err = zkt.HashElems(n.ChildL.BigInt(), n.ChildR.BigInt())\n            if err != nil {\n                return nil, err\n            }\n        case NodeTypeLeaf:\n            var err error\n            n.valueHash, err = zkt.PreHandlingElems(n.CompressedFlags,\n                n.ValuePreimage)\n            if err != nil {\n                return nil, err\n            }\n            n.nodeHash, err = LeafHash(n.NodeKey, n.valueHash)\n            if err != nil {\n                return nil, err\n            }\n        case NodeTypeEmpty: // Zero\n            n.nodeHash = &zkt.HashZero\n        default:\n            n.nodeHash = &zkt.HashZero\n        }\n    }\n    return n.nodeHash, nil\n}",
        "language": "go",
        "description": "Figure 1.1: NodeHash and LeafHash (zktrie/trie/zk_trie_node.go#118‚Äì156)"
      },
      {
        "type": "text",
        "text": "The function HashElems used here performs recursive hashing in a binary-tree fashion. For the purpose of this finding, the key property is that HashElems(1,k,v) == H(H(1,k),v) and HashElems(n.ChildL,n.ChildR) == H(n.ChildL,n.ChildR), where H is the global two-input, one-output hash function. Therefore, a branch node b and a leaf node l where b.ChildL == H(1,l.NodeKey) and b.ChildR == l.valueHash will have equal hash values."
      },
      {
        "type": "text",
        "text": "This allows proof forgery and, for example, a malicious entity to insert a key that can be proved to be both present and nonexistent in the tree, as illustrated by the proof-of-concept test in figure 1.2."
      },
      {
        "type": "code",
        "code": "func TestMerkleTree_ForgeProof(t *testing.T) {\n    zkTrie := newTestingMerkle(t, 10)\n    t.Run(\"Testing for malicious proofs\", func(t *testing.T) {\n        // Find two distinct values k1,k2 such that the first step of\n        // the path has the sibling on the LEFT (i.e., path[0] ==\n        // false)\n        k1, k2 := (func() (zkt.Byte32, zkt.Byte32) {\n            k1 := zkt.Byte32{1}\n            k2 := zkt.Byte32{2}\n            k1_hash, _ := k1.Hash()\n            k2_hash, _ := k2.Hash()\n            for !getPath(1, zkt.NewHashFromBigInt(k1_hash)[:])[0] {\n                for i := len(k1); i > 0; i -= 1 {\n                    k1[i-1] += 1\n                    if k1[i-1] != 0 {\n                        break\n                    }\n                }\n                k1_hash, _ = k1.Hash()\n            }\n            for k1 == k2 || !getPath(1,\n                zkt.NewHashFromBigInt(k2_hash)[:])[0] {\n                for i := len(k2); i > 0; i -= 1 {\n                    k2[i-1] += 1\n                    if k2[i-1] != 0 {\n                        break\n                    }\n                }\n                k2_hash, _ = k2.Hash()\n            }\n            return k1, k2\n        })()\n        k1_hash_int, _ := k1.Hash()\n        k2_hash_int, _ := k2.Hash()\n        k1_hash := zkt.NewHashFromBigInt(k1_hash_int)\n        k2_hash := zkt.NewHashFromBigInt(k2_hash_int)\n        \n        // create a dummy value for k2, and use that to craft a\n        // malicious value for k1\n        k2_value := (&[2]zkt.Byte32{{2}})[:]  \n        k1_value, _ := NewLeafNode(k2_hash, 1, k2_value).NodeHash()\n        k1_value_array := \n            []zkt.Byte32{*zkt.NewByte32FromBytes(k1_value.Bytes())}\n        \n        // insert k1 into the trie with the malicious value\n        assert.Nil(t, zkTrie.TryUpdate(zkt.NewHashFromBigInt(k1_hash_int), 0,\n            k1_value_array))\n            \n        getNode := func(hash *zkt.Hash) (*Node, error) {\n            return zkTrie.GetNode(hash)\n        }\n        \n        // query an inclusion proof for k1\n        k1Proof, _, err := BuildZkTrieProof(zkTrie.rootHash, k1_hash_int, 10,\n            getNode)\n        assert.Nil(t, err)\n        assert.True(t, k1Proof.Existence)\n        \n        // check that inclusion proof against our root hash\n        k1_val_hash, _ := NewLeafNode(k1_hash, 0, k1_value_array).NodeHash()\n        k1Proof_root, _ := k1Proof.Verify(k1_val_hash, k1_hash)\n        assert.Equal(t, k1Proof_root, zkTrie.rootHash)\n        \n        // forge a non-existence proof\n        fakeNonExistProof := *k1Proof\n        fakeNonExistProof.Existence = false\n        \n        // The new non-existence proof needs one extra level, where\n        // the sibling hash is H(1,k1_hash)\n        fakeNonExistProof.depth += 1\n        zkt.SetBitBigEndian(fakeNonExistProof.notempties[:],\n            fakeNonExistProof.depth-1)\n        fakeSibHash, _ := zkt.HashElems(big.NewInt(1), k1_hash_int)\n        fakeNonExistProof.Siblings = append(fakeNonExistProof.Siblings,\n            fakeSibHash)\n            \n        // Construct the NodeAux details for the malicious leaf\n        k2_value_hash, _ := zkt.PreHandlingElems(1, k2_value)\n        k2_nodekey := zkt.NewHashFromBigInt(k2_hash_int)\n        fakeNonExistProof.NodeAux = &NodeAux{Key: k2_nodekey, Value: \n            k2_value_hash}\n            \n        // Check our non-existence proof against the root hash\n        fakeNonExistProof_root, _ := fakeNonExistProof.Verify(k1_val_hash,\n            k1_hash)\n        assert.Equal(t, fakeNonExistProof_root, zkTrie.rootHash)\n        \n        // fakeNonExistProof and k1Proof prove opposite things. k1\n        // is both in and not-in the tree!\n        assert.NotEqual(t, fakeNonExistProof.Existence, k1Proof.Existence)\n    })\n}",
        "language": "go",
        "description": "Figure 1.2: A proof-of-concept test case for proof forgery"
      }
    ],
    "impact": "Suppose Alice uses the zktrie to implement the Ethereum account table in a zkEVM-based bridge with trustless state updates. Bob submits a transaction that inserts specially crafted account data into some position in that tree. At a later time, Bob submits a transaction that depends on the result of an account table lookup. Bob generates two contradictory Merkle proofs and uses those proofs to create two zkEVM execution proofs that step to different final states. By submitting one proof each to the opposite sides of the bridge, Bob causes state divergence and a loss of funds.",
    "recommendation": "Short term, modify NodeHash to domain-separate leaves and branches, such as by changing the branch hash to zkt.HashElems(big.NewInt(2),n.ChildL.BigInt(), n.ChildR.BigInt()). Long term, fully document all data structure designs and requirements, and review all assumptions to ensure that they are well founded.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"Lack of proof validation causes denial of service on the verifier",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "medium",
    "difficulty": "low",
    "type": "Data Validation",
    "finding_id": "TOB-ZKTRIE-2",
    "target_file": "trie/zk_trie_impl.go",
    "content": [
      {
        "type": "text",
        "text": "The Merkle tree proof verifier assumes several well-formedness properties about the received proof and node arguments. If at least one of these properties is violated, the verifier will have a runtime error. The first property that must hold is that the node associated with the Merkle proof must be a leaf node (i.e., must contain a non-nil NodeKey field). If this is not the case, computing the rootFromProof for a nil NodeKey will cause a panic when computing the getPath function."   
      },  

      {
        "type": "text",
        "text": "Secondly, the Proof fields must be guaranteed to be consistent with the other fields. Assuming that the proof depth is correct will cause out-of-bounds accesses to both the NodeKey and the notempties field. Finally, the Siblings array length should also be validated; for example, the VerifyProofZkTrie will panic due to an out-of-bounds access if the proof.Siblings field is empty (highlighted in yellow in the rootFromProof function)."   
      },
                                                                                                                                  
      {
        "type": "code",
        "code": "// VerifyProof verifies the Merkle Proof for the entry and root.\nfunc VerifyProofZkTrie(rootHash *zkt.Hash, proof *Proof, node *Node) bool {\n    nodeHash, err := node.NodeHash()\n    if err != nil {\n        return false\n    }\n    rootFromProof, err := proof.Verify(nodeHash, node.NodeKey)\n    if err != nil {\n        return false\n    }\n    return bytes.Equal(rootHash[:], rootFromProof[:])\n}\n\n// Verify the proof and calculate the root, nodeHash can be nil when try to verify\n// a nonexistent proof\nfunc (proof *Proof) Verify(nodeHash, nodeKey *zkt.Hash) (*zkt.Hash, error) {\n    if proof.Existence {\n        if nodeHash == nil {\n            return nil, ErrKeyNotFound\n        }\n        return proof.rootFromProof(nodeHash, nodeKey)\n    } else {\n        if proof.NodeAux == nil {\n            return proof.rootFromProof(&zkt.HashZero, nodeKey)\n        } else {\n            if bytes.Equal(nodeKey[:], proof.NodeAux.Key[:]) {\n                return nil, fmt.Errorf(\"non-existence proof being checked against hIndex equal to nodeAux\")\n            }\n            midHash, err := LeafHash(proof.NodeAux.Key, proof.NodeAux.Value)\n            if err != nil {\n                return nil, err\n            }\n            return proof.rootFromProof(midHash, nodeKey)\n        }\n    }\n}\n\nfunc (proof *Proof) rootFromProof(nodeHash, nodeKey *zkt.Hash) (*zkt.Hash, error) {\n    sibIdx := len(proof.Siblings) - 1\n    path := getPath(int(proof.depth), nodeKey[:])\n    var siblingHash *zkt.Hash\n    var err error\n    \n    for lvl := int(proof.depth) - 1; lvl >= 0; lvl-- {\n        if zkt.TestBitBigEndian(proof.notempties[:], uint(lvl)) {\n            siblingHash = proof.Siblings[sibIdx]\n            sibIdx--\n        } else {\n            siblingHash = &zkt.HashZero\n        }\n        \n        if path[lvl] {\n            nodeHash, err = NewParentNode(siblingHash, nodeHash).NodeHash()\n            if err != nil {\n                return nil, err\n            }\n        } else {\n            nodeHash, err = NewParentNode(nodeHash, siblingHash).NodeHash()\n            if err != nil {\n                return nil, err\n            }\n        }\n    }\n    \n    return nodeHash, nil\n}",
        "language": "go",
        "description": "Figure 2.1: zktrie/trie/zk_trie_impl.go#595‚Äì660"
      }
    ],
    "impact": "An attacker crafts an invalid proof that causes the proof verifier to crash, causing a denial of service in the system.",
    "recommendation": "Short term, validate the proof structure before attempting to use its values. Add fuzz testing to the VerifyProofZkTrie function. Long term, add extensive tests and fuzz testing to functions interfacing with attacker-controlled values.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"Two incompatible ways to generate proofs",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "informational",
    "difficulty": "low",
    "type": "Data Validation",
    "finding_id": "TOB-ZKTRIE-3",
    "target_file": "trie/{zk_trie.go, zk_trie_impl.go}",
    "content": [
      {
        "type": "text",
        "text": "There are two incompatible ways to generate proofs."   
      },  

      {
        "type": "text",
        "text": "The first implementation (figure 3.1) writes to a given callback, effectively returning []bytes. It does not have a companion verification function; it has only positive tests (zktrie/trie/zk_trie_test.go#L93-L125); and it is accessible from the C function TrieProve and the Rust function prove."   
      },  

      {
        "type": "text",
        "text": "The second implementation (figure 3.2) returns a pointer to a Proof struct. It has a companion verification function (zktrie/trie/zk_trie_impl.go#L595-L632); it has positive and negative tests (zktrie/trie/zk_trie_impl_test.go#L484-L537); and it is not accessible from C or Rust."   
      },
                                                                                                                                  
      {
        "type": "code",
        "code": "// Prove is a simlified calling of ProveWithDeletion\nfunc (t *ZkTrie) Prove(key []byte, fromLevel uint, writeNode func(*Node) error) error {\n    return t.ProveWithDeletion(key, fromLevel, writeNode, nil)\n}\n\n// ProveWithDeletion constructs a merkle proof for key. The result contains all\n// encoded nodes on the path to the value at key. The value itself is also included in the last\n// node and can be retrieved by verifying the proof.\n//\n// If the trie does not contain a value for key, the returned proof contains all\n// nodes of the longest existing prefix of the key (at least the root node), ending\n// with the node that proves the absence of the key.\n//\n// If the trie contain value for key, the onHit is called BEFORE writeNode being called,\n// both the hitted leaf node and its sibling node is provided as arguments so caller\n// would receive enough information for launch a deletion and calculate the new root\n// base on the proof data\n// Also notice the sibling can be nil if the trie has only one leaf\nfunc (t *ZkTrie) ProveWithDeletion(key []byte, fromLevel uint, writeNode func(*Node) error, onHit func(*Node, *Node)) error {\n    [...]\n}",
        "language": "go",
        "description": "Figure 3.1: The first way to generate proofs (zktrie/trie/zk_trie.go#143‚Äì164)"
      },

      {
        "type": "code",
        "code": "// Proof defines the required elements for a MT proof of existence or\n// non-existence.\ntype Proof struct {\n    // existence indicates wether this is a proof of existence or\n    // non-existence.\n    Existence bool\n    // depth indicates how deep in the tree the proof goes.\n    depth uint\n    // notempties is a bitmap of non-empty Siblings found in Siblings.\n    notempties [zkt.HashByteLen - proofFlagsLen]byte\n    // Siblings is a list of non-empty sibling node hashes.\n    Siblings []*zkt.Hash\n    // NodeAux contains the auxiliary information of the lowest common ancestor\n    // node in a non-existence proof.\n    NodeAux *NodeAux\n}\n\n// BuildZkTrieProof prove uniformed way to turn some data collections into Proof struct\nfunc BuildZkTrieProof(rootHash *zkt.Hash, k *big.Int, lvl int, \n    getNode func(key *zkt.Hash) (*Node, error)) (*Proof, *Node, error) {\n    [...]\n}",
        "language": "go",
        "description": "Figure 3.2: The second way to generate proofs (zktrie/trie/zk_trie_impl.go#531‚Äì551)"
      }
    ],
    "impact": "",
    "recommendation": "Short term, decide on one implementation and remove the other implementation. Long term, ensure full test coverage in the chosen implementation; ensure the implementation has both positive and negative testing; and add fuzz testing to the proof verification routine.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"BuildZkTrieProof does not populate NodeAux.Value",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "low",
    "difficulty": "low",
    "type": "Testing",
    "finding_id": "TOB-ZKTRIE-4",
    "target_file": " trie/zk_trie_impl.go",
    "content": [
      {
        "type": "text",
        "text": "A nonexistence proof for some key k in a Merkle tree is a Merkle path from the root of the tree to a subtree, which would contain k if it were present but which instead is either an empty subtree or a subtree with a single leaf k2 where k != k2. In the zktrie codebase, that second case is handled by the NodeAux field in the Proof struct, as illustrated in figure 4.1."   
      },
                                                                                                                                  
      {
        "type": "code",
        "code": "// Verify the proof and calculate the root, nodeHash can be nil when try to verify\n// a nonexistent proof\nfunc (proof *Proof) Verify(nodeHash, nodeKey *zkt.Hash) (*zkt.Hash, error) {\n    if proof.Existence {\n        if nodeHash == nil {\n            return nil, ErrKeyNotFound\n        }\n        return proof.rootFromProof(nodeHash, nodeKey)\n    } else {\n        if proof.NodeAux == nil {\n            return proof.rootFromProof(&zkt.HashZero, nodeKey)\n        } else {\n            if bytes.Equal(nodeKey[:], proof.NodeAux.Key[:]) {\n                return nil, fmt.Errorf(\"non-existence proof being checked against hIndex equal to nodeAux\")\n            }\n            midHash, err := LeafHash(proof.NodeAux.Key, proof.NodeAux.Value)\n            if err != nil {\n                return nil, err\n            }\n            return proof.rootFromProof(midHash, nodeKey)\n        }\n    }\n}",
        "language": "go",
        "description": "Figure 4.1: The Proof.Verify method (zktrie/trie/zk_trie_impl.go#609‚Äì632)"
      },

      {
        "type": "text",
        "text": "When a non-inclusion proof is generated, the BuildZkTrieProof function looks up the other leaf node and uses its NodeKey and valueHash fields to populate the Key and Value fields of NodeAux, as shown in figure 4.2. However, the valueHash field of this node may be nil, causing NodeAux.Value to be nil and causing proof verification to crash with a nil pointer dereference error, which can be triggered by the test case shown in figure 4.3."
      },

      {
        "type": "code",
        "code": "n, err := getNode(nextHash)\nif err != nil {\n    return nil, nil, err\n}\n\nswitch n.Type {\ncase NodeTypeEmpty:\n    return p, n, nil\ncase NodeTypeLeaf:\n    if bytes.Equal(kHash[:], n.NodeKey[:]) {\n        p.Existence = true\n        return p, n, nil\n    }\n    // We found a leaf whose entry didn't match hIndex\n    p.NodeAux = &NodeAux{Key: n.NodeKey, Value: n.valueHash}\n    return p, n, nil\n}",
        "language": "go",
        "description": "Figure 4.2: Populating NodeAux (zktrie/trie/zk_trie_impl.go#560‚Äì574)"
      },

      {
        "type": "code",
        "code": "func TestMerkleTree_GetNonIncProof(t *testing.T) {\n    zkTrie := newTestingMerkle(t, 10)\n    t.Run(\"Testing for non-inclusion proofs\", func(t *testing.T) {\n        k := zkt.Byte32{1}\n        k_value := (&[1]zkt.Byte32{{1}})[:]        \n        k_other := zkt.Byte32{2}\n        k_hash_int, _ := k.Hash()\n        k_other_hash_int, _ := k_other.Hash()\n        k_hash := zkt.NewHashFromBigInt(k_hash_int)\n        k_other_hash := zkt.NewHashFromBigInt(k_other_hash_int)\n        \n        assert.Nil(t, zkTrie.TryUpdate(k_hash, 0, k_value))\n        \n        getNode := func(hash *zkt.Hash) (*Node, error) {\n            return zkTrie.GetNode(hash)\n        }\n        \n        proof, _, err := BuildZkTrieProof(zkTrie.rootHash, k_other_hash_int, 10, getNode)\n        assert.Nil(t, err)\n        assert.False(t, proof.Existence)\n        \n        proof_root, _ := proof.Verify(nil, k_other_hash)\n        assert.Equal(t, proof_root, zkTrie.rootHash)\n    })\n}",
        "language": "go",
        "description": "Figure 4.3: A test case that will crash with a nil dereference of NodeAux.Value"
      },
      {
        "type": "text",
        "text": "Adding a call to n.NodeHash() inside BuildZkTrieProof, as shown in figure 4.4, fixes this problem."
      },
      {
        "type": "code",
        "code": "n, err := getNode(nextHash)\nif err != nil {\n    return nil, nil, err\n}\nswitch n.Type {\ncase NodeTypeEmpty:\n    return p, n, nil\ncase NodeTypeLeaf:\n    if bytes.Equal(kHash[:], n.NodeKey[:]) {\n        p.Existence = true\n        return p, n, nil\n    }\n    // We found a leaf whose entry didn't match hIndex\n    p.NodeAux = &NodeAux{Key: n.NodeKey, Value: n.valueHash}\n    return p, n, nil\n}",
        "language": "go",
        "description": "Figure 4.4: Adding the highlighted n.NodeHash() call fixes this problem. (zktrie/trie/zk_trie_impl.go#560‚Äì574)"
      }
    ],
    "impact": "An adversary or ordinary user requests that the software generate and verify a non-inclusion proof, and the software crashes, leading to the loss of service.",
    "recommendation": "Short term, fix BuildZkTrieProof by adding a call to n.NodeHash(), as described above. Long term, ensure that all major code paths in important functions, such as proof generation and verification, are tested. The Go coverage analysis report generated by the command go test -cover -coverprofile c.out && go tool cover -html=c.out shows that this branch in Proof.Verify is not currently tested.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":" Leaf nodes with different values may have the same hash",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "high",
    "difficulty": "medium",
    "type": "Cryptography",
    "finding_id": "TOB-ZKTRIE-5",
    "target_file": "trie/zk_trie_node.go, types/util.go",
    "content": [
      {
        "type": "text",
        "text": "The hash value of a leaf node is derived from the hash of its key and its value. A leaf node‚Äôs value comprises up to 256 32-byte fields, and that value‚Äôs hash is computed by passing those fields to the HashElems function. HashElems hashes these fields in a Merkle tree‚Äìstyle binary tree pattern, as shown in figure 5.1."   
      },  
                                                                                                                                  
      {
        "type": "code",
        "code": "func HashElems(fst, snd *big.Int, elems ...*big.Int) (*Hash, error) {\n    l := len(elems)\n    baseH, err := hashScheme([]*big.Int{fst, snd})\n    if err != nil {\n        return nil, err\n    }\n    \n    if l == 0 {\n        return NewHashFromBigInt(baseH), nil\n    } else if l == 1 {\n        return HashElems(baseH, elems[0])\n    }\n    \n    tmp := make([]*big.Int, (l+1)/2)\n    for i := range tmp {\n        if (i+1)*2 > l {\n            tmp[i] = elems[i*2]\n        } else {\n            h, err := hashScheme(elems[i*2 : (i+1)*2])\n            if err != nil {\n                return nil, err\n            }\n            tmp[i] = h\n        }\n    }\n    \n    return HashElems(baseH, tmp[0], tmp[1:]...)\n}",
        "language": "go",
        "description": "Figure 5.1: Binary-tree hashing in HashElems (zktrie/types/util.go#9‚Äì36)"
      },

      {
        "type": "text",
        "text": "However, HashElems does not include the number of elements being hashed, so leaf nodes with different values may have the same hash, as illustrated in the proof-of-concept test case shown in figure 5.2."
      },  

      {
        "type": "code",
        "code": "func TestMerkleTree_MultiValue(t *testing.T) {\n    t.Run(\"Testing for value collisions\", func(t *testing.T) {\n        k := zkt.Byte32{1}\n        k_hash_int, _ := k.Hash()\n        k_hash := zkt.NewHashFromBigInt(k_hash_int)\n        \n        value1 := (&[3]zkt.Byte32{{1}, {2}, {3}})[:]        \n        value1_hash, _ := NewLeafNode(k_hash, 0, value1).NodeHash()\n        \n        first2_hash, _ := zkt.PreHandlingElems(0, value1[:2])\n        value2 := (&[2]zkt.Byte32{*zkt.NewByte32FromBytes(first2_hash.Bytes()),\n            {3}})[:]        \n        value2_hash, _ := NewLeafNode(k_hash, 0, value2).NodeHash()\n        \n        assert.NotEqual(t, value1, value2)\n        assert.NotEqual(t, value1_hash, value2_hash)\n    })\n}",
        "language": "go",
        "description": "Figure 5.2: A proof-of-concept test case for value collisions"
      }
    ],
    "impact": "An adversary inserts a maliciously crafted value into the tree and then creates a proof for a different, colliding value. This violates the security requirements of a Merkle tree and may lead to incorrect behavior such as state divergence.",
    "recommendation": "Short term, modify PrehandlingElems to prefix the ValuePreimage array with its length before being passed to HashElems. Long term, document and review all uses of hash functions to ensure that they commit to their inputs.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"Empty UpdatePreimage function body",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Auditing and Logging",
    "finding_id": "TOB-ZKTRIE-6",
    "target_file": "",
    "content": [
      {
        "type": "text",
        "text": "The UpdatePreimage function implementation for the Database receiver type is empty. Instead of an empty function body, the function should either panic with an unimplemented message or a message that is logged. This would prevent the function from being used without any warning."  
      },  
                                                                                                                                  
      {
        "type": "code",
        "code": "func (db *Database) UpdatePreimage([]byte, *big.Int) {}"      ,
        "language": "go",
        "description": "Figure 6.1: zktrie/trie/zk_trie_database.go#19"
      }
    ],
    "impact": "",
    "recommendation": "Short term, add an unimplemented message to the function body, through either a panic or message logging",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"CanonicalValue is not canonical",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Cryptography",
    "finding_id": "TOB-ZKTRIE-7",
    "target_file": "trie/zk_trie_node.go",
    "content": [
      {
        "type": "text",
        "text": "The CanonicalValue function does not uniquely generate a representation of Node structures, allowing different Nodes with the same CanonicalValue, and two nodes with the same NodeHash but different CanonicalValues."   
      },  

      {
        "type": "text",
        "text": "ValuePreimages in a Node can be either uncompressed or compressed (by hashing); the CompressedFlags value indicates which data is compressed."   
      },  

      {
        "type": "text",
        "text": "Only the first 24 fields can be compressed, so CanonicalValue truncates CompressedFlags to the first 24 bits. But NewLeafNode accepts any uint32 for the CompressedFlags field of a Node. Figure 7.3 shows how this can be used to construct two different Node structs that have the same CanonicalValue."   
      },
                                                                                                                                  
      {
        "type": "code",
        "code": "// CanonicalValue returns the byte form of a node required to be persisted, and\n// strip unnecessary fields from the encoding (current only KeyPreimage for Leaf node)\n// to keep a minimum size for content being stored in backend storage\nfunc (n *Node) CanonicalValue() []byte {\n    switch n.Type {\n    case NodeTypeParent: // {Type || ChildL || ChildR}\n        bytes := []byte{byte(n.Type)}\n        bytes = append(bytes, n.ChildL.Bytes()...)\n        bytes = append(bytes, n.ChildR.Bytes()...)\n        return bytes\n    case NodeTypeLeaf: // {Type || Data...}\n        bytes := []byte{byte(n.Type)}\n        bytes = append(bytes, n.NodeKey.Bytes()...)\n        tmp := make([]byte, 4)\n        compressedFlag := (n.CompressedFlags << 8) +\n            uint32(len(n.ValuePreimage))\n        binary.LittleEndian.PutUint32(tmp, compressedFlag)\n        bytes = append(bytes, tmp...)\n        for _, elm := range n.ValuePreimage {\n            bytes = append(bytes, elm[:]...)\n        }\n        bytes = append(bytes, 0)\n        return bytes\n    case NodeTypeEmpty: // { Type }\n        return []byte{byte(n.Type)}\n    default:\n        return []byte{}\n    }\n}",
        "language": "go",
        "description": "Figure 7.1: This figure shows the CanonicalValue computation. The highlighted code assumes that CompressedFlags is 24 bits. (zktrie/trie/zk_trie_node.go#187‚Äì214)"
      },

      {
        "type": "code",
        "code": "// NewLeafNode creates a new leaf node.\nfunc NewLeafNode(k *zkt.Hash, valueFlags uint32, valuePreimage []zkt.Byte32) *Node {\n    return &Node{\n        Type:           NodeTypeLeaf,\n        NodeKey:        k,\n        CompressedFlags: valueFlags,\n        ValuePreimage:  valuePreimage,\n    }\n}",
        "language": "go",
        "description": "Figure 7.2: Node construction in NewLeafNode (zktrie/trie/zk_trie_node.go#55‚Äì58)"
      },

      {
        "type": "code",
        "code": "// CanonicalValue implicitly truncates CompressedFlags to 24 bits. This test should\n// ideally fail.\nfunc TestZkTrie_CanonicalValue1(t *testing.T) {\n    key, err := hex.DecodeString(\"0000000000000000000000000000000000000000000000000000000000000000\")\n    assert.NoError(t, err)\n    \n    vPreimage := []zkt.Byte32{{0}}\n    k := zkt.NewHashFromBytes(key)\n    vFlag0 := uint32(0x00ffffff)\n    vFlag1 := uint32(0xffffffff)\n    \n    lf0 := NewLeafNode(k, vFlag0, vPreimage)\n    lf1 := NewLeafNode(k, vFlag1, vPreimage)\n    \n    // These two assertions should never simultaneously pass.\n    assert.True(t, lf0.CompressedFlags != lf1.CompressedFlags)\n    assert.True(t, reflect.DeepEqual(lf0.CanonicalValue(), lf1.CanonicalValue()))\n}",
        "language": "go",
        "description": "Figure 7.3: A test showing that one can construct different nodes with the same CanonicalValue"
      },

      {
        "type": "code",
        "code": "// PreHandlingElems turn persisted byte32 elements into field arrays for our hashElem\n// it also has the compressed byte32\nfunc PreHandlingElems(flagArray uint32, elems []Byte32) (*Hash, error) {\n    ret := make([]*big.Int, len(elems))\n    var err error\n    for i, elem := range elems {\n        if flagArray&(1<<i) != 0 {\n            ret[i], err = elem.Hash()\n            if err != nil {\n                return nil, err\n            }\n        } else {\n            ret[i] = new(big.Int).SetBytes(elem[:])\n        }\n    }\n    if len(ret) < 2 {\n        return NewHashFromBigInt(ret[0]), nil\n    }\n    return HashElems(ret[0], ret[1], ret[2:]...)\n}",
        "language": "go",
        "description": "Figure 7.4: The subroutine called in NodeHash that hashes uncompressed elements (zktrie/types/util.go#38‚Äì62)"
      },

      {
        "type": "text",
        "text": "Furthermore, CanonicalValue and NodeHash are inconsistent in their processing of uncompressed values. CanonicalValue uses them directly, while NodeHash hashes them. Figure 7.5 shows how this can be used to construct two Node structs that have the same NodeHash but different CanonicalValues."
      },

      {
        "type": "code",
        "code": "// CanonicalValue and NodeHash are not consistent\nfunc TestZkTrie_CanonicalValue2(t *testing.T) {\n    t.Run(\"Testing for value collisions\", func(t *testing.T) {\n        k := zkt.Byte32{1}\n        k_hash_int, _ := k.Hash()\n        k_hash := zkt.NewHashFromBigInt(k_hash_int)\n        \n        value1 := (&[2]zkt.Byte32{*zkt.NewByte32FromBytes(k_hash.Bytes()),\n            {3}})[:]        \n        value2 := (&[2]zkt.Byte32{{1}, {3}})[:]        \n        \n        leaf1 := NewLeafNode(k_hash, 0, value1)\n        leaf2 := NewLeafNode(k_hash, 1, value2)\n        \n        leaf1_node_hash, _ := leaf1.NodeHash()\n        leaf2_node_hash, _ := leaf2.NodeHash()\n        assert.Equal(t, leaf1_node_hash, leaf2_node_hash)\n        \n        leaf1_canonical := leaf1.CanonicalValue()\n        leaf2_canonical := leaf2.CanonicalValue()\n        assert.NotEqual(t, leaf1_canonical, leaf2_canonical)\n    })\n}",
        "language": "go",
        "description": "Figure 7.5: A test showing that CanonicalValue and NodeHash are inconsistent"
      }
    ],
    "impact": "",
    "recommendation": "Short term, have CanonicalValue validate all assumptions, and make CanonicalValue and NodeHash consistent. Long term, document all assumptions and use Go‚Äôs type system to enforce them.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"ToSecureKey and ToSecureKeyBytes implicitly truncate the key",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-ZKTRIE-8",
    "target_file": " types/util.go",
    "content": [
      {
        "type": "text",
        "text": "ToSecureKey and ToSecureKeyBytes accept a key of arbitrary length but implicitly truncate it to 32 bytes."   
      },  

      {
        "type": "text",
        "text": "ToSecureKey makes an underlying call to NewByte32FromBytesPaddingZero that truncates the key to its first 32 bytes. The ToSecureKeyBytes function also truncates the key because it calls ToSecureKey."   
      },  
                                                                                                                                  
      {
        "type": "code",
        "code": "// ToSecureKey turn the byte key into the integer represent of \"secured\" key\nfunc ToSecureKey(key []byte) (*big.Int, error) {\n    word := NewByte32FromBytesPaddingZero(key)\n    return word.Hash()\n}",
        "language": "go",
        "description": "Figure 8.1: ToSecureKey accepts a key of arbitrary length. (zktrie/types/util.go#93‚Äì97)"
      },

      {
        "type": "code",
        "code": "// create bytes32 with zeropadding to shorter bytes, or truncate it\nfunc NewByte32FromBytesPaddingZero(b []byte) *Byte32 {\n    byte32 := new(Byte32)\n    copy(byte32[:], b)\n    return byte32\n}",
        "language": "go",
        "description": "Figure 8.2: But NewByte32FromBytesPaddingZero truncates the key to the first 32 bytes. (zktrie/types/byte32.go#35‚Äì40)"
      },

      {
        "type": "code",
        "code": "// ToSecureKeyBytes turn the byte key into a 32-byte \"secured\" key, which\n// represented a big-endian integer\nfunc ToSecureKeyBytes(key []byte) (*Byte32, error) {\n    k, err := ToSecureKey(key)\n    if err != nil {\n        return nil, err\n    }\n    return NewByte32FromBytes(k.Bytes()), nil\n}",
        "language": "go",
        "description": "Figure 8.3: ToSecureKeyBytes accepts a key of arbitrary length and calls ToSecureKey on it. (zktrie/types/util.go#99‚Äì107)"
      },

      {
        "type": "code",
        "code": "// zkt.ToSecureKey implicitly truncates keys to 32 bytes. This test should ideally fail.\nfunc TestZkTrie_ToSecureKeyTruncation(t *testing.T) {\n    key1, err := hex.DecodeString(\"00000000000000000000000000000000000000000000000000000000000000011\")\n    assert.NoError(t, err)\n    \n    key2, err := hex.DecodeString(\"00000000000000000000000000000000000000000000000000000000000000022\")\n    assert.NoError(t, err)\n    \n    assert.NotEqual(t, key1, key2)\n    \n    skey1, err := zkt.ToSecureKey(key1)\n    assert.NoError(t, err) // This should fail\n    \n    skey2, err := zkt.ToSecureKey(key2)\n    assert.NoError(t, err) // This should fail\n    \n    assert.True(t, skey1.Cmp(skey2) == 0) // If above don't fail, this should fail\n}",
        "language": "go",
        "description": "Figure 8.4: A test showing the truncation of keys longer than 32 bytes"
      }
    ],
    "impact": "",
    "recommendation": "Short term, fix the ToSecureKey and ToSecureKeyBytes functions so that they do not truncate keys that are longer than 32 bytes, and instead hash all the bytes. If this behavior is not desired, ensure that the functions return an error if given a key longer than 32 bytes. Long term, add fuzz tests to public interfaces like TryGet, TryUpdate, and TryDelete.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"Unused key argument on the bridge_prove_write function",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Auditing and Logging",
    "finding_id": "TOB-ZKTRIE-9",
    "target_file": "c.go",
    "content": [
      {
        "type": "text",
        "text": "The `bridge_prove_write` function implementation does not use the `key` argument."   
      },  
                                                                                                                                  
      {
        "type": "code",
        "code": "void bridge_prove_write(proveWriteF f, unsigned char* key, unsigned char* val, int size, void* param) {\n    f(val, size, param);\n}",
        "language": "go",
        "description": "Figure 9.1: zktrie/c.go#17‚Äì19"
      },

      {
        "type": "text",
        "text": "This function is always called with a `nil` value:"   
      },  

      {
        "type": "code",
        "code": "err = tr.Prove(s_key.Bytes(), 0, func(n *trie.Node) error {\n    dt := n.Value()\n    C.bridge_prove_write(\n        C.proveWriteF(callback),\n        nil, //do not need to prove node key\n        (*C.uchar)(&dt[0]),\n        C.int(len(dt)),\n        cb_param,\n    )\n    return nil\n})\nif err != nil {\n    return C.CString(err.Error())\n}\ntailingLine := trie.ProofMagicBytes()\nC.bridge_prove_write(\n    C.proveWriteF(callback),\n    nil, //do not need to prove node key\n    (*C.uchar)(&tailingLine[0]),\n    C.int(len(tailingLine)),\n    cb_param,\n)\nreturn nil",
        "language": "go",
        "description": "Figure 9.2: zktrie/lib.go#263‚Äì292"
      }
    ],
    "impact": "",
    "recommendation": "Short term, Document the intended behavior and the role and requirements of each function. Decide whether to remove the unused argument or document why it is currently unused in the implementation.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"The PreHandlingElems function panics with an empty elems array",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "medium",
    "difficulty": "low",
    "type": "Data Validation",
    "finding_id": "TOB-ZKTRIE-10",
    "target_file": "types/util.go, trie/zk_trie_node.go",
    "content": [
      {
        "type": "text",
        "text": "The `PreHandlingElems` function experiences a runtime error when the `elems` array is empty. There is an early return path for when the array has fewer than two elements that assumes there is at least one element. If this is not the case, there will be an out-of-bounds access that will cause a runtime error."
      },
      {
        "type": "code",
        "code": "func PreHandlingElems(flagArray uint32, elems []Byte32) (*Hash, error) {\n    ret := make([]*big.Int, len(elems))\n    var err error\n    for i, elem := range elems {\n        if flagArray&(1<<i) != 0 {\n            ret[i], err = elem.Hash()\n            if err != nil {\n                return nil, err\n            }\n        } else {\n            ret[i] = new(big.Int).SetBytes(elem[:])\n        }\n    }\n    if len(ret) < 2 {\n        return NewHashFromBigInt(ret[0]), nil",
        "language": "go",
        "description": "Figure 10.1: When `ret` is empty, the array access will cause a runtime error. (zktrie/types/util.go#40‚Äì57)"
      },
      {
        "type": "text",
        "text": "Figure 10.2 shows tests that demonstrate this issue by directly calling `PreHandlingElems` with an empty array and by triggering the issue via the `NodeHash` function."
      },
      {
        "type": "code",
        "code": "func TestEmptyPreHandlingElems(t *testing.T) {\n    flagArray := uint32(0)\n    elems := make([]Byte32, 0)\n    _, err := PreHandlingElems(flagArray, elems)\n    assert.NoError(t, err)\n}\n\nfunc TestPrehandlingElems(t *testing.T) {\n    k := zkt.Byte32{1}\n    k_hash_int, _ := k.Hash()\n    k_hash := zkt.NewHashFromBigInt(k_hash_int)\n    value1 := (&[0]zkt.Byte32{})[:]  \n    node, _ := NewLeafNode(k_hash, 0, value1).NodeHash()\n    t.Log(node)\n}",
        "language": "go",
        "description": "Figure 10.2: Tests that trigger the out-of-bounds access"
      },
      {
        "type": "text",
        "text": "Note that the `TrieUpdate` exported function would also trigger the same issue if called with an empty `vPreimage` argument, but this is checked in the function.\n\nIt is also possible to trigger this panic from the Rust API by calling `ZkTrieNode::parse` with the byte array obtained from the `Value()` function operated on a maliciously constructed leaf node. This is because `ZkTrieNode::parse` will eventually call `NewNodeFromBytes` and the `NodeHash` function on that node. The `NewNodeFromBytes` function also does not validate that the newly created node is well formed (TOB-ZKTRIE-14)."
      },
      {
        "type": "code",
        "code": "#[test]\nfn test_zktrienode_parse() {\n    let buff = hex::decode(\"011baa09b39b1016e6be4467f3d58c1e1859d5e883514ff707551a9355a5941e220000000000\").unwrap();\n    let _node = ZkTrieNode::parse(&buff);\n}",
        "language": "go",
        "description": "Figure 10.3: A test that triggers the out-of-bounds access from the Rust API"
      },
      {
        "type": "text",
        "text": "Both the `Data()` and `String()` functions also panic when operated on a `Node` receiver with an empty `ValuePreimage` array:"
      },
      {
        "type": "code",
        "code": "// Data returns the wrapped data inside LeafNode and cast them into bytes\n// for other node type it just return nil\nfunc (n *Node) Data() []byte {\n    switch n.Type {\n    case NodeTypeLeaf:\n        var data []byte\n        hdata := (*reflect.SliceHeader)(unsafe.Pointer(&data))\n        //TODO: uintptr(reflect.ValueOf(n.ValuePreimage).UnsafePointer()) should be more elegant but only available until go 1.18\n        hdata.Data = uintptr(unsafe.Pointer(&n.ValuePreimage[0]))\n        hdata.Len = 32 * len(n.ValuePreimage)\n        hdata.Cap = hdata.Len\n        return data\n    default:\n        return nil\n    }\n}",
        "language": "go",
        "description": "Figure 10.4: zktrie/trie/zk_trie_node.go#170‚Äì185"
      },
      {
        "type": "code",
        "code": "// String outputs a string representation of a node (different for each type).\nfunc (n *Node) String() string {\n    switch n.Type {\n    case NodeTypeParent: // {Type || ChildL || ChildR}\n        return fmt.Sprintf(\"Parent L:%s R:%s\", n.ChildL, n.ChildR)\n    case NodeTypeLeaf: // {Type || Data...}\n        return fmt.Sprintf(\"Leaf I:%v Items: %d, First:%v\", n.NodeKey, len(n.ValuePreimage), n.ValuePreimage[0])\n    case NodeTypeEmpty: // {}\n        return \"Empty\"\n    default:\n        return \"Invalid Node\"\n    }\n}",
        "language": "go",
        "description": "Figure 10.5: zktrie/trie/zk_trie_node.go#230‚Äì242"
      }
  
    ],
    "impact": "An attacker calls the public Rust `ZkTrieNode::parse` function with a maliciously chosen buffer, causing the system to experience a runtime error.",
    "recommendation": "Short Term, Document which properties need to hold for all data structures. Ensure that edge cases are documented in the type constructors, and add checks to validate that functions do not raise a runtime error. Long Term, Add fuzz testing to the public Rust and Go APIs.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"The hash_external function panics with integers larger than 32 bytes",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "low",
    "difficulty": "high",
    "type": "Data Validation",
    "finding_id": "TOB-ZKTRIE-11",
    "target_file": "types/util.go",
    "content": [
      {
        "type": "text",
        "text": "The `hash_external` function will cause a runtime error due to an out-of-bounds access if the input integers are larger than 32 bytes."
      },
      {
        "type": "code",
        "code": "func hash_external(inp []*big.Int) (*big.Int, error) {\n    if len(inp) != 2 {\n        return big.NewInt(0), errors.New(\"invalid input size\")\n    }\n    a := zkt.ReverseByteOrder(inp[0].Bytes())\n    b := zkt.ReverseByteOrder(inp[1].Bytes())\n    a = append(a, zeros[0:(32-len(a))]...)\n    b = append(b, zeros[0:(32-len(b))]...)",
        "language": "go",
        "description": "Figure 11.1: zktrie/lib.go#31‚Äì39"
      }

    ],
    "impact": "An attacker causes the system to call `hash_external` with integers larger than 32 bytes, causing the system to experience a runtime error.",
    "recommendation": "Short term, Document the function requirements that the integers need to be less than 32 bytes. If the function is reachable by an adversary, add checks to ensure that the runtime error is not reachable. Long term, Carefully check all indexing operations done on adversary-controlled values with respect to out-of-bounds accessing.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"Mishandling of cgo.Handles causes runtime errors",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "medium",
    "difficulty": "low",
    "type": "Data Validation",
    "finding_id": "TOB-ZKTRIE-12",
    "target_file": "lib.go",
    "content": [
      {
        "type": "text",
        "text": "The interaction between the Rust and Go codebases relies on the use of `cgo.Handles`. These handles are a way to encode Go pointers between Go and, in this case, Rust. Handles can be passed back to the Go runtime, which will be able to retrieve the original Go value. According to the documentation, it is safe to represent an error with the zero value, as this is an invalid handle. However, the implementation should take this into account when retrieving the Go values from the handle, as both the `Value` and `Delete` methods for `Handles` panic on invalid handles."
      },
      {
        "type": "text",
        "text": "The codebase contains multiple instances of this behavior. For example, the `NewTrieNode` function will return `0` if it finds an error:"
      },
      {
        "type": "code",
        "code": "// parse raw bytes and create the trie node\n//export NewTrieNode\nfunc NewTrieNode(data *C.char, sz C.int) C.uintptr_t {\n    bt := C.GoBytes(unsafe.Pointer(data), sz)\n    n, err := trie.NewNodeFromBytes(bt)\n    if err != nil {\n        return 0\n    }\n    // calculate key for caching\n    if _, err := n.NodeHash(); err != nil {\n        return 0\n    }\n    return C.uintptr_t(cgo.NewHandle(n))\n}",
        "language": "go",
        "description": "Figure 12.1: zktrie/lib.go#73‚Äì88"
      },
      {
        "type": "text",
        "text": "However, neither the Rust API nor the Go API takes these cases into consideration. Looking at the Rust API, the `ZkTrieNode::parse` function will simply save the result from `NewTrieNode` regardless of whether it is a valid or invalid Go handle. Then, calling any other function will cause a runtime error due to the use of an invalid handle. This issue is present in all functions implemented for `ZkTrieNode`: `drop`, `node_hash`, and `value_hash`."
      },
      {
        "type": "text",
        "text": "We now precisely describe how it fails in the `drop` function case. After constructing a malformed `ZkTrieNode`, the `drop` function will call `FreeTrieNode` on the invalid handle:"
      },
      {
        "type": "code",
        "code": "impl Drop for ZkTrieNode {\n    fn drop(&mut self) {\n        unsafe { FreeTrieNode(self.trie_node) };\n    }\n}",
        "language": "go",
        "description": "Figure 12.2: zktrie/src/lib.rs#127‚Äì131"
      },
      {
        "type": "text",
        "text": "This will cause a panic given the direct use of the invalid handle on the `Handle.Delete` function:"
      },
      {
        "type": "code",
        "code": "// free created trie node\n//export FreeTrieNode\nfunc FreeTrieNode(p C.uintptr_t) { freeObject(p) }\nfunc freeObject(p C.uintptr_t) {\n    h := cgo.Handle(p)\n    h.Delete()\n}",
        "language": "go",
        "description": "Figure 12.3: zktrie/lib.go#114‚Äì131"
      },
      {
        "type": "text",
        "text": "The following test triggers the described issue:"
      },
      {
        "type": "code",
        "code": "#[test]\nfn invalid_handle_drop() {\n    init_hash_scheme(hash_scheme);\n    let _nd = ZkTrieNode::parse(&hex::decode(\"0001\").unwrap());\n}\n// running 1 test\n// panic: runtime/cgo: misuse of an invalid Handle\n// goroutine 17 [running, locked to thread]:\n// runtime/cgo.Handle.Delete(...)\n// /opt/homebrew/Cellar/go/1.18.3/libexec/src/runtime/cgo/handle.go:137\n// main.freeObject(0x14000060d01?)\n// /zktrie/lib.go:130 +0x5c\n// main.FreeTrieNode(...)\n// /zktrie/lib.go:116",
        "language": "go",
        "description": "Figure 12.4: A test case that triggers the finding in the `drop` case"
      }

    ],
    "impact": "An attacker provides malformed data to `ZkTrieNode::parse`, causing it to contain an invalid Go handle. This subsequently causes the system to crash when one of the `value_hash` or `node_hash` functions is called or eventually when the node variable goes out of scope and the `drop` function is called.",
    "recommendation": "Short term, Ensure that invalid handles are not used with `Delete` or `Value`; for this, document the Go exported function requirements, and ensure that Rust checks for this before these functions are called. Long term, Add tests that exercise all return paths for both the Go and Rust libraries.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"Unnecessary unsafe pointer manipulation in Node.Data()",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Undefined Behavior",
    "finding_id": "TOB-ZKTRIE-13",
    "target_file": "trie/zk_trie_node.go",
    "content": [
      {
        "type": "text",
        "text": "The `Node.Data()` function returns the underlying value of a leaf node as a byte slice (i.e., `[]byte`). Since the `ValuePreimage` field is a slice of `zkt.Byte32`s, returning a value of type `[]byte` requires some form of conversion. The implementation, shown in figure 13.1, uses the `reflect` and `unsafe` packages to manually construct a byte slice that overlaps with `ValuePreimage`."
      },
      {
        "type": "code",
        "code": "case NodeTypeLeaf:\n    var data []byte\n    hdata := (*reflect.SliceHeader)(unsafe.Pointer(&data))\n    //TODO: uintptr(reflect.ValueOf(n.ValuePreimage).UnsafePointer()) should be more elegant but only available until go 1.18\n    hdata.Data = uintptr(unsafe.Pointer(&n.ValuePreimage[0]))\n    hdata.Len = 32 * len(n.ValuePreimage)\n    hdata.Cap = hdata.Len\n    return data",
        "language": "go",
        "description": "Figure 13.1: Unsafe casting from `[]zkt.Byte32` to `[]byte` (trie/zk_trie_node.go#174‚Äì181)"
      },
      {
        "type": "text",
        "text": "Manual construction of slices and unsafe casting between pointer types are error-prone and potentially very dangerous. This particular case appears to be harmless, but it is unnecessary and can be replaced by allocating a byte buffer and copying `ValuePreimage` into it."
      }
    ],
    "impact": "",
    "recommendation": "Short term, Replace this unsafe cast with code that allocated a byte buffer and then copies `ValuePreimage`, as described above. Long term, Evaluate all uses of unsafe pointer manipulation and replace them with a safe alternative where possible.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"NewNodeFromBytes does not fully validate its input",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-ZKTRIE-14",
    "target_file": "trie/zk_trie_node.go",
    "content": [
      {
        "type": "text",
        "text": "The `NewNodeFromBytes` function parses a byte array into a value of type `Node`. It checks several requirements for the `Node` value and returns `nil` and an error value if those checks fail. However, it allows a zero-length value for `ValuePreimage` (which allows TOB-ZKTRIE-10 to be exploited) and ignores extra data at the end of leaf and empty nodes."
      },
      {
        "type": "text",
        "text": "As shown in figure 14.1, the exact length of the byte array is checked in the case of a branch, but is unchecked for empty nodes and only lower-bounded in the case of a leaf node."
      },
      {
        "type": "code",
        "code": "case NodeTypeParent:\n    if len(b) != 2*zkt.HashByteLen {\n        return nil, ErrNodeBytesBadSize\n    }\n    n.ChildL = zkt.NewHashFromBytes(b[:zkt.HashByteLen])\n    n.ChildR = zkt.NewHashFromBytes(b[zkt.HashByteLen : zkt.HashByteLen*2])\ncase NodeTypeLeaf:\n    if len(b) < zkt.HashByteLen+4 {\n        return nil, ErrNodeBytesBadSize\n    }\n    n.NodeKey = zkt.NewHashFromBytes(b[0:zkt.HashByteLen])\n    mark := binary.LittleEndian.Uint32(b[zkt.HashByteLen : zkt.HashByteLen+4])\n    preimageLen := int(mark & 255)\n    n.CompressedFlags = mark >> 8\n    n.ValuePreimage = make([]zkt.Byte32, preimageLen)\n    curPos := zkt.HashByteLen + 4\n    if len(b) < curPos+preimageLen*32+1 {\n        return nil, ErrNodeBytesBadSize\n    }\n    ‚Ä¶\n    if preImageSize != 0 {\n        if len(b) < curPos+preImageSize {\n            return nil, ErrNodeBytesBadSize\n        }\n        n.KeyPreimage = new(zkt.Byte32)\n        copy(n.KeyPreimage[:], b[curPos:curPos+preImageSize])\n    }\ncase NodeTypeEmpty:\n    break",
        "language": "go",
        "description": "Figure 14.1: `preimageLen` and `len(b)` are not fully checked. (trie/zk_trie_node.go#78‚Äì111)"
      }
    ],
    "impact": "",
    "recommendation": "Short term, Add checks of the total byte array length and the `preimageLen` field to `NewNodeFromBytes`. Long term, Explicitly document the serialization format for nodes, and add tests for incorrect serialized nodes.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"init_hash_scheme is not thread-safe",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Undefined Behavior",
    "finding_id": "TOB-ZKTRIE-15",
    "target_file": "src/lib.rs, lib.go, c.go, types/hash.go",
    "content": [
      {
        "type": "text",
        "text": "`zktrie` provides a safe-Rust interface around its Go implementation. Safe Rust statically prevents various memory safety errors, including null pointer dereferences and data races. However, when unsafe Rust is wrapped in a safe interface, the unsafe code must provide any guarantees that safe Rust expects. For more information about writing unsafe Rust, consult The Rustonomicon."
      },
      {
        "type": "text",
        "text": "The `init_hash_scheme` function, shown in figure 15.1, calls `InitHashScheme`, which is a `cgo` wrapper for the Go function shown in figure 15.2."
      },
      {
        "type": "code",
        "code": "pub fn init_hash_scheme(f: HashScheme) {\n    unsafe { InitHashScheme(f) }\n}",
        "language": "rust",
        "description": "Figure 15.1: src/lib.rs#67‚Äì69"
      },
      {
        "type": "code",
        "code": "// notice the function must use C calling convention\n//export InitHashScheme\nfunc InitHashScheme(f unsafe.Pointer) {\n    hash_f := C.hashF(f)\n    C.init_hash_scheme(hash_f)\n    zkt.InitHashScheme(hash_external)\n}",
        "language": "go",
        "description": "Figure 15.2: lib.go#65‚Äì71"
      },
      {
        "type": "text",
        "text": "`InitHashScheme` calls two other functions: first, a C function called `init_hash_scheme` and second, a second Go function (this time, in the `hash` module) called `InitHashScheme`. This second Go function is synchronized with a `sync.Once` object, as shown in figure 15.3."
      },
      {
        "type": "code",
        "code": "func InitHashScheme(f func([]*big.Int) (*big.Int, error)) {\n    setHashScheme.Do(func() {\n        hashScheme = f\n    })\n}",
        "language": "go",
        "description": "Figure 15.3: types/hash.go#29‚Äì33"
      },
      {
        "type": "text",
        "text": "However, the C function `init_hash_scheme`, shown in figure 15.4, performs a completely unsynchronized write to the global variable `hash_scheme`, which can lead to a data race."
      },
      {
        "type": "code",
        "code": "void init_hash_scheme(hashF f){\n    hash_scheme = f;\n}",
        "language": "c",
        "description": "Figure 15.4: c.go#13‚Äì15"
      },
      {
        "type": "text",
        "text": "However, the only potential data race comes from multi-threaded initialization, which contradicts the usage recommendation in the `README`, shown in figure 15.5."
      },
      {
        "type": "code",
        "code": "We must init the crate with a poseidon hash scheme before any actions:\n‚Ä¶\nzktrie_util::init_hash_scheme(hash_scheme);",
        "language": "markdown",
        "description": "Figure 15.5: README.md#8‚Äì24"
      }
    ],
    "impact": "",
    "recommendation": "Short term, Add synchronization to `C.init_hash_scheme`, perhaps by using the same `sync.Once` object as `hash.go`. Long term, Carefully review all interactions between C and Rust, paying special attention to anything mentioned in the \"How Safe and Unsafe Interact\" section of the Rustonomicon.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"Safe-Rust ZkMemoryDb interface is not thread-safe",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "high",
    "difficulty": "high",
    "type": "Undefined Behavior",
    "finding_id": "TOB-ZKTRIE-16",
    "target_file": "lib.go,src/lib.rs,trie/zk_trie_database.go",
    "content": [
      {
        "type": "text",
        "text": "The Go function `Database.Init`, shown in figure 16.1, is not thread-safe. In particular, if it is called from multiple threads, a data race may occur when writing to the map. In normal usage, that is not a problem; any user of the `Database.Init` function is expected to run the function only during initialization, when synchronization is not required."
      },
      {
        "type": "code",
        "code": "// Init flush db with batches of k/v without locking\nfunc (db *Database) Init(k, v []byte) {\n    db.db[string(k)] = v\n}",
        "language": "go",
        "description": "Figure 16.1: trie/zk_trie_database.go#40‚Äì43"
      },
      {
        "type": "text",
        "text": "However, this function is called by the safe Rust function `ZkMemoryDb::add_node_bytes` (figure 16.2) via the `cgo` function `InitDbByNode` (figure 16.3):"
      },
      {
        "type": "code",
        "code": "pub fn add_node_bytes(&mut self, data: &[u8]) -> Result<(), ErrString> {\n    let ret_ptr = unsafe { InitDbByNode(self.db, data.as_ptr(), data.len() as c_int) };\n    if ret_ptr.is_null() {\n        Ok(())\n    } else {\n        Err(ret_ptr.into())\n    }\n}",
        "language": "rust",
        "description": "Figure 16.2: src/lib.rs#171‚Äì178"
      },
      {
        "type": "code",
        "code": "// flush db with encoded trie-node bytes\n//export InitDbByNode\nfunc InitDbByNode(pDb C.uintptr_t, data *C.uchar, sz C.int) *C.char {\n    h := cgo.Handle(pDb)\n    db := h.Value().(*trie.Database)\n    bt := C.GoBytes(unsafe.Pointer(data), sz)\n    n, err := trie.DecodeSMTProof(bt)\n    if err != nil {\n        return C.CString(err.Error())\n    } else if n == nil {\n        //skip magic string\n        return nil\n    }\n    hash, err := n.NodeHash()\n    if err != nil {\n        return C.CString(err.Error())\n    }\n    db.Init(hash[:], n.CanonicalValue())\n    return nil\n}",
        "language": "go",
        "description": "Figure 16.3: lib.go#147‚Äì170"
      },
      {
        "type": "text",
        "text": "Safe Rust is required to never invoke undefined behavior, such as data races. When wrapping unsafe Rust code, including FFI calls, care must be taken to ensure that safe Rust code cannot invoke undefined behavior through that wrapper. (Refer to the \"How Safe and Unsafe Interact\" section of the Rustonomicon.) Although `add_node_bytes` takes `&mut self`, and thus cannot be called from more than one thread at once, a second reference to the database can be created in a way that Rust's borrow checker cannot track, by calling `new_trie`. Figures 16.4, 16.5, and 16.6 show the call trace by which a pointer to the `Database` is stored in the `ZkTrieImpl`."
      },
      {
        "type": "code",
        "code": "pub fn new_trie(&mut self, root: &Hash) -> Option<ZkTrie> {\n    let ret = unsafe { NewZkTrie(root.as_ptr(), self.db) };\n    if ret.is_null() {\n        None\n    } else {\n        Some(ZkTrie { trie: ret })\n    }\n}",
        "language": "rust",
        "description": "Figure 16.4: src/lib.rs#181‚Äì189"
      },
      {
        "type": "code",
        "code": "func NewZkTrie(root_c *C.uchar, pDb C.uintptr_t) C.uintptr_t {\n    h := cgo.Handle(pDb)\n    db := h.Value().(*trie.Database)\n    root := C.GoBytes(unsafe.Pointer(root_c), 32)\n    zktrie, err := trie.NewZkTrie(*zkt.NewByte32FromBytes(root), db)\n    if err != nil {\n        return 0\n    }\n    return C.uintptr_t(cgo.NewHandle(zktrie))\n}",
        "language": "go",
        "description": "Figure 16.5: lib.go#174‚Äì185"
      },
      {
        "type": "code",
        "code": "func NewZkTrieImpl(storage ZktrieDatabase, maxLevels int) (*ZkTrieImpl, error) {\n    return NewZkTrieImplWithRoot(storage, &zkt.HashZero, maxLevels)\n}\n// NewZkTrieImplWithRoot loads a new ZkTrieImpl. If in the storage already exists one\n// will open that one, if not, will create a new one.\nfunc NewZkTrieImplWithRoot(storage ZktrieDatabase, root *zkt.Hash, maxLevels int) (*ZkTrieImpl, error) {\n    mt := ZkTrieImpl{db: storage, maxLevels: maxLevels, writable: true}\n    mt.rootHash = root\n    if *root != zkt.HashZero {\n        _, err := mt.GetNode(mt.rootHash)\n        if err != nil {\n            return nil, err\n        }\n    }\n    return &mt, nil\n}",
        "language": "go",
        "description": "Figure 16.6: trie/zk_trie_impl.go#56‚Äì72"
      },
      {
        "type": "text",
        "text": "Then, by calling `add_node_bytes` in one thread and `ZkTrie::root()` or some other method that calls `Database.Get()`, one can trigger a data race from safe Rust."
      }
    ],
    "impact": "A Rust-based library consumer uses threads to improve performance. Relying on Rust's type system, they assume that thread safety has been enforced and they run `ZkMemoryDb::add_node_bytes` in a multi-threaded scenario. A data race occurs and the system crashes.",
    "recommendation": "Short term, Add synchronization to `Database.Init`, such as by calling `db.lock.Lock()`. Long term, Carefully review all interactions between C and Rust, paying special attention to guidance in the \"How Safe and Unsafe Interact\" section of the Rustonomicon.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"Some Node functions return the zero hash instead of errors",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Error Reporting",
    "finding_id": "TOB-ZKTRIE-17",
    "target_file": "lib.go, trie/zk_trie_node.go",
    "content": [
      {
        "type": "text",
        "text": "The `Node.NodeHash` and `Node.ValueHash` methods each return the zero hash in cases in which an error return would be more appropriate. In the case of `NodeHash`, all invalid node types return the zero hash, the same hash as an empty node (shown in figure 17.1)."
      },
      {
        "type": "code",
        "code": "case NodeTypeEmpty: // Zero\n    n.nodeHash = &zkt.HashZero\ndefault:\n    n.nodeHash = &zkt.HashZero\n}\n}\nreturn n.nodeHash, nil",
        "language": "go",
        "description": "Figure 17.1: trie/zk_trie_node.go#149‚Äì155"
      },
      {
        "type": "text",
        "text": "In the case of `ValueHash`, non-leaf nodes have a zero value hash, as shown in figure 17.2."
      },
      {
        "type": "code",
        "code": "func (n *Node) ValueHash() (*zkt.Hash, error) {\n    if n.Type != NodeTypeLeaf {\n        return &zkt.HashZero, nil\n    }",
        "language": "go",
        "description": "Figure 17.2: trie/zk_trie_node.go#160‚Äì163"
      },
      {
        "type": "text",
        "text": "In both of these cases, returning an error is more appropriate and prevents potential confusion if client software assumes that the main return value is valid whenever the error returned is `nil`."
      }
    ],
    "impact": "",
    "recommendation": "Short term, Have the functions return an error in these cases instead of the zero hash. Long term, description: Ensure that exceptional cases lead to non-`nil` error returns rather than default values.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"get_account can read past the buffer",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "high",
    "difficulty": "medium",
    "type": "Data Exposure",
    "finding_id": "TOB-ZKTRIE-18",
    "target_file": "lib.rs",
    "content": [
      {
        "type": "text",
        "text": "The public `get_account` function assumes that the provided key corresponds to an account key. However, if the function is instead called with a storage key, it will cause an out-of-bounds read that could leak secret information."
      },
      {
        "type": "text",
        "text": "In the Rust implementation, leaf nodes can have two types of values: accounts and storage. Account values have a size of either 128 or 160 bytes depending on whether they include one or two code hashes. On the other hand, storage values always have a size of 32 bytes."
      },
      {
        "type": "text",
        "text": "The `get_account` function takes a key and returns the account associated with it. In practice, it computes the value pointer associated with the key and reads 128 or 160 bytes at that address."
      },
      {
        "type": "text",
        "text": "If the key contains a storage value rather than an account value, then `get_account` reads 96 or 128 bytes past the buffer. This is shown in figure 18.4."
      },
      {
        "type": "code",
        "code": "// get account data from account trie\npub fn get_account(&self, key: &[u8]) -> Option<AccountData> {\n    self.get::<ACCOUNTSIZE>(key).map(|arr| unsafe {\n        std::mem::transmute::<[u8; FIELDSIZE * ACCOUNTFIELDS], AccountData>(arr)\n    })\n}",
        "language": "rust",
        "description": "Figure 18.1: `get_account` calls `get` with type `ACCOUNTSIZE` and `key`. (zktrie/src/lib.rs#230‚Äì235)"
      },
      {
        "type": "code",
        "code": "// all errors are reduced to \"not found\"\nfn get<const T: usize>(&self, key: &[u8]) -> Option<[u8; T]> {\n    let ret = unsafe { TrieGet(self.trie, key.as_ptr(), key.len() as c_int) };\n    if ret.is_null() {\n        None\n    } else {\n        Some(must_get_const_bytes::<T>(ret))\n    }\n}",
        "language": "rust",
        "description": "Figure 18.2: `get` calls `must_get_const_bytes` with type `ACCOUNTSIZE` and the pointer returned by `TrieGet`. (zktrie/src/lib.rs#214‚Äì223)"
      },
      {
        "type": "code",
        "code": "fn must_get_const_bytes<const T: usize>(p: *const u8) -> [u8; T] {\n    let bytes = unsafe { std::slice::from_raw_parts(p, T) };\n    let bytes = bytes\n        .try_into()\n        .expect(\"the buf has been set to specified bytes\");\n    unsafe { FreeBuffer(p.cast()) }\n    bytes\n}",
        "language": "rust",
        "description": "Figure 18.3: `must_get_const_bytes` calls `std::slice::from_raw_parts` with type `ACCOUNTSIZE` and pointer `p` to read `ACCOUNTSIZE` bytes from pointer `p`. (zktrie/src/lib.rs#100‚Äì107)"
      },
      {
        "type": "code",
        "code": "#[test]\nfn get_account_overflow() {\n    let storage_key = hex::decode(\"0000000000000000000000000000000000000000000000000000000000000000\").unwrap();\n    let storage_data = [10u8; 32];\n    init_hash_scheme(hash_scheme);\n    let mut db = ZkMemoryDb::new();\n    let root_hash = Hash::from([0u8; 32]);\n    let mut trie = db.new_trie(&root_hash).unwrap();\n    trie.update_store(&storage_key, &storage_data).unwrap();\n    println!(\"{:?}\", trie.get_account(&storage_key).unwrap());\n}\n// Sample output (picked from a sample of ten runs):\n// [[10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10], [160, 113, 63, 0, 2, 0, 0, 0, 161, 67, 240, 40, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 158, 63, 0, 2, 0, 0, 0, 17, 72, 240, 40, 1, 0, 0, 0], [16, 180, 85, 254, 1, 0, 0, 0, 216, 179, 85, 254, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]",
        "language": "rust",
        "description": "Figure 18.4: This is a proof-of-concept demonstrating the buffer over-read. When run with `cargo test get_account_overflow -- --nocapture`, it prints 128 bytes with the last 96 bits being over-read."
      }
    ],
    "impact": "Suppose the Rust program leaves secret data in memory. An attacker can interact with the zkTrie to read secret data out-of-bounds.",
    "recommendation": "Short term, Have `get_account` return an error when it is called on a key containing a storage value. Additionally, this logic should be moved to the Go implementation instead of residing in the Rust bindings. Long term, Review all unsafe code, especially code related to pointer manipulation, to prevent similar issues.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"Unchecked usize to c_int casts allow hash collisions by length misinterpretation",
    "source":"Trail Of Bits",
    "protocol":"Scroll zkTrie",
    "protocol_type":"ZKTRIE",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Sanketh Menda"],
    "scope": [
      {
        "name": "zktrie",
        "description": "Types: Go, Rust. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zktrie/tree/90179c19281670f41c54bd80ab01e4d64c860521",
        "commit_hash": "90179c19281670f41c54bd80ab01e4d64c860521"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf",
    "severity": "high",
    "difficulty": "medium",
    "type": "Data Validation",
    "finding_id": "TOB-ZKTRIE-19",
    "target_file": "lib.rs",
    "content": [
      {
        "type": "text",
        "text": "A set of unchecked integer casting operations can lead to hash collisions and runtime errors reached from the public Rust interface."
      },
      {
        "type": "text",
        "text": "The Rust library regularly needs to convert the input function's byte array length from the `usize` type to the `c_int` type. Depending on the architecture, these types might differ in size and signedness. This difference allows an attacker to provide an array with a maliciously chosen length that will be cast to a different number. The attacker can choose to manipulate the array and cast the value to a smaller value than the actual array length, allowing the attacker to create two leaf nodes from different byte arrays that result in the same hash. The attacker is also able to cast the value to a negative number, causing a runtime error when the Go library calls the `GoBytes` function."
      },
      {
        "type": "text",
        "text": "The issue is caused by the explicit and unchecked cast using the `as` operator and occurs in the `ZkTrieNode::parse`, `ZkMemoryDb::add_node_bytes`, `ZkTrie::get`, `ZkTrie::prove`, `ZkTrie::update`, and `ZkTrie::delete` functions (all of which are public). Figure 19.1 shows `ZkTrieNode::parse`:"
      },
      {
        "type": "code",
        "code": "impl ZkTrieNode {\n    pub fn parse(data: &[u8]) -> Self {\n        Self {\n            trie_node: unsafe { NewTrieNode(data.as_ptr(), data.len() as c_int) },\n        }\n    }",
        "language": "rust",
        "description": "Figure 19.1: zktrie/src/lib.rs#133‚Äì138"
      },
      {
        "type": "text",
        "text": "To achieve a collision for nodes constructed from different byte arrays, first observe that `(c_int::MAX as usize) * 2 + 2` is `0` when cast to `c_int`. Thus, creating two nodes that have the same prefix and are then padded with different bytes with that length will cause the Go library to interpret only the common prefix of these nodes. The following test showcases this exploit."
      },
      {
        "type": "code",
        "code": "#[test]\nfn invalid_cast() {\n    init_hash_scheme(hash_scheme);\n    // common prefix\n    let nd = &hex::decode(\"012098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b648640101000000000000000000000000000000000000000000000000000000000018282256f8b00\").unwrap();\n    // create node1 with prefix padded by zeroes\n    let mut vec_nd = nd.to_vec();\n    let mut zero_padd_data = vec![0u8; (c_int::MAX as usize) * 2 + 2];\n    vec_nd.append(&mut zero_padd_data);\n    let node1 = ZkTrieNode::parse(&vec_nd);\n    // create node2 with prefix padded by ones\n    let mut vec_nd = nd.to_vec();\n    let mut one_padd_data = vec![1u8; (c_int::MAX as usize) * 2 + 2];\n    vec_nd.append(&mut one_padd_data);\n    let node2 = ZkTrieNode::parse(&vec_nd);\n    // create node3 with just the prefix\n    let node3 = ZkTrieNode::parse(&hex::decode(\"012098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864010100000000000000000000000000000000000000000000000000000000018282256f8b00\").unwrap());\n    // all hashes are equal\n    assert_eq!(node1.node_hash(), node2.node_hash());\n    assert_eq!(node1.node_hash(), node3.node_hash());\n}",
        "language": "rust",
        "description": "Figure 19.2: A test showing three different leaf nodes with colliding hashes"
      },
      {
        "type": "text",
        "text": "This finding also allows an attacker to cause a runtime error by choosing the data array with the appropriate length that will cause the cast to result in a negative number. Figure 19.2 shows a test that triggers the runtime error for the `parse` function:"
      },
      {
        "type": "code",
        "code": "#[test]\nfn invalid_cast() {\n    init_hash_scheme(hash_scheme);\n    let data = vec![0u8; c_int::MAX as usize + 1];\n    println!(\"{:?}\", data.len() as c_int);\n    let _nd = ZkTrieNode::parse(&data);\n}\n// running 1 test\n// -2147483648\n// panic: runtime error: gobytes: length out of range\n// goroutine 17 [running, locked to thread]:\n// main._Cfunc_GoBytes(...)\n// _cgo_gotypes.go:102\n// main.NewTrieNode.func1(0x14000062de8?, 0x80000000)\n// /zktrie/lib.go:78 +0x50\n// main.NewTrieNode(0x14000062e01?, 0x2680?)\n// /zktrie/lib.go:78 +0x1c",
        "language": "rust",
        "description": "Figure 19.3: A test that triggers the issue, whose output shows the reinterpreted length of the array"
      }
    ],
    "impact": "An attacker provides two different byte arrays that will have the same `node_hash`, breaking the assumption that such nodes are hard to obtain.",
    "recommendation": "Short term, have the code perform the cast in a checked manner by using the `c_int::try_from` method to allow validation if the conversion succeeds. Determine whether the Rust functions should allow arbitrary length inputs; document the length requirements and assumptions. Long term, regularly run Clippy in pedantic mode to find and fix all potentially dangerous casts.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-07-scroll-zktrie-securityreview.pdf"
    }
  },
  {
    "title":"PoseidonLookup is not implemented",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Marc Ilunga"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/v0.4",
        "commit_hash": "7b56d0b323e92ac11e54213520f6e7db41941cd0"
      },
      {
        "name": "copy-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/fc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      },
      {
        "name": "super_circuit.rs",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/blob/fc6c8a2972870e62e96cde480b3aa48c0cc1303d/zkevm-circuits/src/super_circuit.rs",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Testing",
    "finding_id": "TOB-SCROLL2-1",
    "target_file": "src/gadgets/poseidon.rs",
    "content": [
      {
        "type": "text",
        "text": "Poseidon hashing is performed within the MPT circuit by performing lookups into a Poseidon table via the `PoseidonLookup` trait, shown in figure 1.1."
      },
      {
        "type": "code",
        "code": "/// Lookup represent the poseidon table in zkevm circuit\npub trait PoseidonLookup {\nfn lookup_columns(&self) -> (FixedColumn, [AdviceColumn; 5]) {\n    let (fixed, adv) = self.lookup_columns_generic();\n    (FixedColumn(fixed), adv.map(AdviceColumn))\n}\nfn lookup_columns_generic(&self) -> (Column<Fixed>, [Column<Advice>; 5]) {\n    let (fixed, adv) = self.lookup_columns();\n    (fixed.0, adv.map(|col| col.0))\n}\n}",
        "language": "rust",
        "description": "Figure 1.1: src/gadgets/poseidon.rs#11‚Äì21"
      },
      {
        "type": "text",
        "text": "This trait is not implemented by any types except the testing-only `PoseidonTable` shown in figure 1.2, which does not constrain its columns at all."
      },
      {
        "type": "code",
        "code": "#[cfg(test)]\n#[derive(Clone, Copy)]\npub struct PoseidonTable {\nq_enable: FixedColumn,\nleft: AdviceColumn,\nright: AdviceColumn,\nhash: AdviceColumn,\ncontrol: AdviceColumn,\nhead_mark: AdviceColumn,\n}\n#[cfg(test)]\nimpl PoseidonTable {\npub fn configure<F: FieldExt>(cs: &mut ConstraintSystem<F>) -> Self {\n    let [hash, left, right, control, head_mark] =\n        [0; 5].map(|_| AdviceColumn(cs.advice_column()));\n    Self {\n        left,\n        right,\n        hash,\n        control,\n        head_mark,\n        q_enable: FixedColumn(cs.fixed_column()),\n    }\n}",
        "language": "rust",
        "description": "Figure 1.2: src/gadgets/poseidon.rs#56‚Äì80"
      },
      {
        "type": "text",
        "text": "The rest of the codebase treats this trait as a black-box implementation, so this does not seem to cause correctness problems elsewhere. However, it does limit one's ability to test some negative cases, and it makes the test coverage rely on the correctness of the `PoseidonTable` struct's witness generation."
      }
    ],
    "impact": "",
    "recommendation": "Short term, create a concrete implementation of the `PoseidonLookup` trait to enable full testing of the MPT circuit. Long term, ensure that all parts of the MPT circuit are tested with both positive and negative tests.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf"
    }
  },
  {
    "title":"IsZeroGadget does not constrain the inverse witness when the value is zero",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Marc Ilunga"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/v0.4",
        "commit_hash": "7b56d0b323e92ac11e54213520f6e7db41941cd0"
      },
      {
        "name": "copy-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/fc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      },
      {
        "name": "super_circuit.rs",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/blob/fc6c8a2972870e62e96cde480b3aa48c0cc1303d/zkevm-circuits/src/super_circuit.rs",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL2-2",
    "target_file": "src/gadgets/is_zero.rs",
    "content": [
      {
        "type": "text",
        "text": "The `IsZeroGadget` implementation allows for an arbitrary `inverse_or_zero` witness value when the `value` parameter is `0`."
      },
      {
        "type": "text",
        "text": "The gadget returns `1` when `value` is `0`; otherwise, it returns `0`. The implementation relies on the existence of an inverse for when `value` is nonzero and on correctly constraining that `value * (1 - value * inverse_or_zero) == 0`."
      },
      {
        "type": "text",
        "text": "However, when `value` is `0`, the constraint is immediately satisfied, regardless of the value of the `inverse_or_zero` witness. This allows an arbitrary value to be provided for that witness value."
      },
      {
        "type": "code",
        "code": "pub fn configure<F: FieldExt>(\n    cs: &mut ConstraintSystem<F>,\n    cb: &mut ConstraintBuilder<F>,\n    value: AdviceColumn, // TODO: make this a query once Query is\n                        // clonable/copyable.....\n) -> Self {\n    let inverse_or_zero = AdviceColumn(cs.advice_column());\n    cb.assert_zero(\n        \"value is 0 or inverse_or_zero is inverse of value\",\n        value.current() * (Query::one() - value.current() *\n        inverse_or_zero.current()),\n    );\n    Self {\n        value,\n        inverse_or_zero,\n    }\n}",
        "language": "rust",
        "description": "Figure 2.1: mpt-circuit/src/gadgets/is_zero.rs#48‚Äì62"
      }
    ],
    "impact": "",
    "recommendation": "Short term, ensure that the circuit is deterministic by constraining `inverse_or_zero` to equal `0` when `value` is `0`. Long term, document which circuits have nondeterministic witnesses; over time, constrain them so that all circuits have deterministic witnesses.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf"
    }
  },
  {
    "title":"The MPT nonexistence proof gadget is missing constraints specified in the documentation",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Marc Ilunga"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/v0.4",
        "commit_hash": "7b56d0b323e92ac11e54213520f6e7db41941cd0"
      },
      {
        "name": "copy-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/fc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      },
      {
        "name": "super_circuit.rs",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/blob/fc6c8a2972870e62e96cde480b3aa48c0cc1303d/zkevm-circuits/src/super_circuit.rs",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL2-3",
    "target_file": "src/gadgets/mpt_update/nonexistence_proof.rs",
    "content": [
      {
        "type": "text",
        "text": "The gadget for checking the consistency of nonexistence proofs is missing several constraints related to type 2 nonexistence proofs."
      },
      {
        "type": "text",
        "text": "The circuit specification includes constraints for the nonexistence of path proofs that are not included in the implementation. This causes the witness values to be unconstrained in some cases. For example, the following constraints are specified:"
      },
      {
        "type": "text",
        "text": "‚óè `other_key_hash` should equal `0` when `key` does not equal `other_key`."
      },
      {
        "type": "text",
        "text": "‚óè `other_leaf_data_hash` should equal the hash of the empty node (pointer by `other_key`)."
      },
      {
        "type": "text",
        "text": "Neither of these constraints is enforced in the implementation: this is because the implementation has no explicit constraints imposed for the type 2 nonexistence proofs. Figure 3.1 shows that the circuit constrains these values only for type 1 proofs."
      },
      {
        "type": "code",
        "code": "pub fn configure<F: FieldExt>(\n    cb: &mut ConstraintBuilder<F>,\n    value: SecondPhaseAdviceColumn,\n    key: AdviceColumn,\n    other_key: AdviceColumn,\n    key_equals_other_key: IsZeroGadget,\n    hash: AdviceColumn,\n    hash_is_zero: IsZeroGadget,\n    other_key_hash: AdviceColumn,\n    other_leaf_data_hash: AdviceColumn,\n    poseidon: &impl PoseidonLookup,\n) {\n    cb.assert_zero(\"value is 0 for empty node\", value.current());\n    cb.assert_equal(\n        \"key_minus_other_key = key - other key\",\n        key_equals_other_key.value.current(),\n        key.current() - other_key.current(),\n    );\n    cb.assert_equal(\n        \"hash_is_zero input == hash\",\n        hash_is_zero.value.current(),\n        hash.current(),\n    );\n    let is_type_1 = !key_equals_other_key.current();\n    let is_type_2 = hash_is_zero.current();\n    cb.assert_equal(\n        \"Empty account is either type 1 xor type 2\",\n        Query::one(),\n        Query::from(is_type_1.clone()) + Query::from(is_type_2),\n    );\n    cb.condition(is_type_1, |cb| {\n        cb.poseidon_lookup(\n            \"other_key_hash == h(1, other_key)\",\n            [Query::one(), other_key.current(), other_key_hash.current()],\n            poseidon,\n        );\n        cb.poseidon_lookup(\n            \"hash == h(key_hash, other_leaf_data_hash)\",\n            [\n                other_key_hash.current(),\n                other_leaf_data_hash.current(),\n                hash.current(),\n            ],\n            poseidon,\n        );\n    });",
        "language": "rust",
        "description": "Figure 3.1: mpt-circuit/src/gadgets/mpt_update/nonexistence_proof.rs#7‚Äì54"
      },
      {
        "type": "text",
        "text": "The Scroll team has stated that this is a specification error and that the missing constraints do not impact the soundness of the circuit."
      }
    ],
    "impact": "",
    "recommendation": "Short term, update the specification to remove the description of these constraints; ensure that the documentation is kept updated. Long term, add positive and negative tests for both types of nonexistence proofs.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf"
    }
  },
  {
    "title":"Discrepancies between the MPT circuit specification and implementation",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Marc Ilunga"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/v0.4",
        "commit_hash": "7b56d0b323e92ac11e54213520f6e7db41941cd0"
      },
      {
        "name": "copy-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/fc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      },
      {
        "name": "super_circuit.rs",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/blob/fc6c8a2972870e62e96cde480b3aa48c0cc1303d/zkevm-circuits/src/super_circuit.rs",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL2-4",
    "target_file": "Several files",
    "content": [
      {
        "type": "text",
        "text": "The MPT circuit implementation is not faithful to the circuit specification in many areas and does not contain comments for the constraints that are either missing from the implementation or that diverge from those in the specification."
      },
      {
        "type": "text",
        "text": "The allowed segment transitions depend on the proof type. For the `NonceChanged` proof type, the specification states that the `Start` segment type can transition to `Start` and that the `AccountLeaf0` segment type also can transition to `Start`. However, neither of these paths is allowed in the implementation."
      },
      {
        "type": "code",
        "code": "MPTProofType::NonceChanged\n| MPTProofType::BalanceChanged\n| MPTProofType::CodeSizeExists\n| MPTProofType::CodeHashExists => [\n    (\n        SegmentType::Start,\n        vec![\n            SegmentType::AccountTrie, // mpt has > 1 account\n            SegmentType::AccountLeaf0, // mpt has <= 1 account\n        ],\n    ),\n    (\n        SegmentType::AccountTrie,\n        vec![\n            SegmentType::AccountTrie,\n            SegmentType::AccountLeaf0,\n            SegmentType::Start, // empty account proof\n        ],\n    ),\n    (SegmentType::AccountLeaf0, vec![SegmentType::AccountLeaf1]),\n    (SegmentType::AccountLeaf1, vec![SegmentType::AccountLeaf2]),\n    (SegmentType::AccountLeaf2, vec![SegmentType::AccountLeaf3]),\n    (SegmentType::AccountLeaf3, vec![SegmentType::Start]),",
        "language": "rust",
        "description": "Figure 4.1: mpt-circuit/src/gadgets/mpt_update/segment.rs#20‚Äì42"
      },
      {
        "type": "code",
        "code": "",
        "language": "text",
        "description": "Figure 4.2: Part of the MPT specification (spec/mpt-proof.md#L318-L328)"
      },
      {
        "type": "text",
        "text": "The transitions allowed for the `PoseidonCodeHashExists` proof type also do not match: the specification states that it has the same transitions as the `NonceChanged` proof type, but the implementation has different transitions."
      },
      {
        "type": "text",
        "text": "The key depth direction checks also do not match the specification. The specification states that the `depth` parameter should be used but the implementation uses `depth - 1`."
      },
      {
        "type": "code",
        "code": "cb.condition(is_trie.clone(), |cb| {\n    cb.add_lookup(\n        \"direction is correct for key and depth\",\n        [key.current(), depth.current() - 1, direction.current()],\n        key_bit.lookup(),\n    );\n    cb.assert_equal(\n        \"depth increases by 1 in trie segments\",\n        depth.current(),\n        depth.previous() + 1,\n    );\n    cb.condition(path_type.current_matches(&[PathType::Common]), |cb| {\n        cb.add_lookup(\n            \"direction is correct for other_key and depth\",\n            [\n                other_key.current(),\n                depth.current() - 1,",
        "language": "rust",
        "description": "Figure 4.3: mpt-circuit/src/gadgets/mpt_update.rs#188‚Äì205"
      },
      {
        "type": "code",
        "code": "",
        "language": "text",
        "description": "Figure 4.4: Part of the MPT specification (spec/mpt-proof.md#L279-L282)"
      },
      {
        "type": "text",
        "text": "Finally, the specification states that when a segment type is a non-trie type, the value of `key` should be constrained to `0`, but this constraint is omitted from the implementation."
      },
      {
        "type": "code",
        "code": "cb.condition(!is_trie, |cb| {\n    cb.assert_zero(\"depth is 0 in non-trie segments\", depth.current());\n});",
        "language": "rust",
        "description": "Figure 4.5: mpt-circuit/src/gadgets/mpt_update.rs#212‚Äì214"
      },
      {
        "type": "code",
        "code": "",
        "language": "text",
        "description": "Figure 4.6: Part of the MPT specification (spec/mpt-proof.md#L284-L286)"
      }
    ],
    "impact": "",
    "recommendation": "Short term, review the specification and ensure its consistency. Match the implementation with the specification, and document possible optimizations that remove constraints, detailing why they do not cause soundness issues. Long term, include both positive and negative tests for all edge cases in the specification.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf"
    }
  },
  {
    "title":"Redundant lookups in the Word RLC circuit",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Marc Ilunga"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/v0.4",
        "commit_hash": "7b56d0b323e92ac11e54213520f6e7db41941cd0"
      },
      {
        "name": "copy-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/fc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      },
      {
        "name": "super_circuit.rs",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/blob/fc6c8a2972870e62e96cde480b3aa48c0cc1303d/zkevm-circuits/src/super_circuit.rs",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Cryptographic",
    "finding_id": "TOB-SCROLL2-5",
    "target_file": "src/gadgets/mpt_update/word_rlc.rs",
    "content": [
      {
        "type": "text",
        "text": "The Word RLC circuit has two redundant lookups into the `BytesLookup` table."
      },
      {
        "type": "text",
        "text": "The Word RLC circuit combines the random linear combination (RLC) for the lower and upper 16 bytes of a word into a single RLC value. For this, it checks that the lower and upper word segments are 16 bytes by looking into the `BytesLookup` table, and it checks that their RLCs are correctly computed by looking into the `RlcLookup` table. However, the lookup into the `RlcLookup` table will also ensure that the lower and upper segments of the word have the correct 16 bytes, making the first two lookups redundant."
      },
      {
        "type": "code",
        "code": "pub fn configure<F: FieldExt>(\n    cb: &mut ConstraintBuilder<F>,\n    [word_hash, high, low]: [AdviceColumn; 3],\n    [rlc_word, rlc_high, rlc_low]: [SecondPhaseAdviceColumn; 3],\n    poseidon: &impl PoseidonLookup,\n    bytes: &impl BytesLookup,\n    rlc: &impl RlcLookup,\n    randomness: Query<F>,\n) {\n    cb.add_lookup(\n        \"old_high is 16 bytes\",\n        [high.current(), Query::from(15)],\n        bytes.lookup(),\n    );\n    cb.add_lookup(\n        \"old_low is 16 bytes\",\n        [low.current(), Query::from(15)],\n        bytes.lookup(),\n    );\n    cb.poseidon_lookup(\n        \"word_hash = poseidon(high, low)\",\n        [high.current(), low.current(), word_hash.current()],\n        poseidon,\n    );\n    cb.add_lookup(\n        \"rlc_high = rlc(high) and high is 16 bytes\",\n        [high.current(), Query::from(15), rlc_high.current()],\n        rlc.lookup(),\n    );\n    cb.add_lookup(\n        \"rlc_low = rlc(low) and low is 16 bytes\",\n        [low.current(), Query::from(15), rlc_low.current()],\n        rlc.lookup(),",
        "language": "rust",
        "description": "Figure 5.1: mpt-circuit/src/gadgets/mpt_update/word_rlc.rs#16‚Äì49"
      },
      {
        "type": "text",
        "text": "Although the `WordRLC::configure` function receives two different lookup objects, `bytes` and `rlc`, they are instantiated with the same concrete lookup:"
      },
      {
        "type": "code",
        "code": "let mpt_update = MptUpdateConfig::configure(\n    cs,\n    &mut cb,\n    poseidon,\n    &key_bit,\n    &byte_representation,\n    &byte_representation,\n    &rlc_randomness,\n    &canonical_representation,\n);",
        "language": "rust",
        "description": "Figure 5.2: mpt-circuit/src/mpt.rs#60‚Äì69"
      },
      {
        "type": "text",
        "text": "We also note that the labels refer to the upper and lower bytes as `old_high` and `old_low` instead of just `high` and `low`."
      }
    ],
    "impact": "",
    "recommendation": "Short term, determine whether both the `BytesLookup` and `RlcLookup` tables are needed for this circuit, and refactor the circuit accordingly, removing the redundant constraints. Long term, review the codebase for duplicated or redundant constraints using manual and automated methods.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf"
    }
  },
  {
    "title":"The NonceChanged configuration circuit does not constrain the new value nonce value",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Marc Ilunga"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/v0.4",
        "commit_hash": "7b56d0b323e92ac11e54213520f6e7db41941cd0"
      },
      {
        "name": "copy-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/fc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      },
      {
        "name": "super_circuit.rs",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/blob/fc6c8a2972870e62e96cde480b3aa48c0cc1303d/zkevm-circuits/src/super_circuit.rs",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf",
    "severity": "high",
    "difficulty": "low",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL2-6",
    "target_file": "src/gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "The `NonceChanged` configuration circuit does not constrain the `config.new_value` parameter to be 8 bytes. Instead, there is a duplicated constraint for `config.old_value`:"
      },
      {
        "type": "code",
        "code": "SegmentType::AccountLeaf3 => {\n    cb.assert_zero(\"direction is 0\", config.direction.current());\n    let old_code_size = (config.old_hash.current() - config.old_value.current())\n    * Query::Constant(F::from(1 << 32).square().invert().unwrap());\n    let new_code_size = (config.new_hash.current() - config.new_value.current())\n    * Query::Constant(F::from(1 << 32).square().invert().unwrap());\n    cb.condition(\n        config.path_type.current_matches(&[PathType::Common]),\n        |cb| {\n            cb.add_lookup(\n                \"old nonce is 8 bytes\",\n                [config.old_value.current(), Query::from(7)],\n                bytes.lookup(),\n            );\n            cb.add_lookup(\n                \"new nonce is 8 bytes\",\n                [config.old_value.current(), Query::from(7)],\n                bytes.lookup(),\n            );",
        "language": "rust",
        "description": "Figure 6.1: mpt-circuit/src/gadgets/mpt_update.rs#1209‚Äì1228"
      },
      {
        "type": "text",
        "text": "This means that a malicious prover could update the `Account` node with a value of arbitrary length for the `Nonce` and `Codesize` parameters."
      },
      {
        "type": "text",
        "text": "The same constraint (with a correct label but incorrect value) is used in the `ExtensionNew` path type:"
      },
      {
        "type": "code",
        "code": "cb.condition(\n    config.path_type.current_matches(&[PathType::ExtensionNew]),\n    |cb| {\n        cb.add_lookup(\n            \"new nonce is 8 bytes\",\n            [config.old_value.current(), Query::from(7)],\n            bytes.lookup(),\n        );",
        "language": "rust",
        "description": "Figure 6.2: mpt-circuit/src/gadgets/mpt_update.rs#1241‚Äì1248"
      }
    ],
    "impact": "A malicious prover uses the `NonceChanged` proof to update the nonce with a larger than expected value.",
    "recommendation": "Short term, enforce the constraint for the `config.new_value` witness. Long term, add positive and negative testing of the edge cases present in the specification. For both the `Common` and `ExtensionNew` path types, there should be a negative test that fails because it changes the new nonce to a value larger than 8 bytes. Use automated testing tools like Semgrep to find redundant and duplicate constraints, as these could indicate that a constraint is incorrect.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf"
    }
  },
  {
    "title":"The Copy circuit does not totally enforce the tag values",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Marc Ilunga"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/v0.4",
        "commit_hash": "7b56d0b323e92ac11e54213520f6e7db41941cd0"
      },
      {
        "name": "copy-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/fc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      },
      {
        "name": "super_circuit.rs",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/blob/fc6c8a2972870e62e96cde480b3aa48c0cc1303d/zkevm-circuits/src/super_circuit.rs",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL2-7",
    "target_file": "src/copy_circuit/copy_gadgets.rs",
    "content": [
      {
        "type": "text",
        "text": "The Copy table includes a tag column that indicates the type of data for that particular row. However, the Copy circuit tag validation function does not totally ensure that the tag matches one of the predefined tag values."
      },
      {
        "type": "text",
        "text": "The implementation uses the `copy_gadgets::constrain_tag` function to bind the `is_precompiled`, `is_tx_calldata`, `is_bytecode`, `is_memory`, and `is_tx_log` witnesses to the actual tag value. However, the code does not ensure that exactly one of these Boolean values is `true`."
      },
      {
        "type": "code",
        "code": "#[allow(clippy::too_many_arguments)]\npub fn constrain_tag<F: Field>(\n    meta: &mut ConstraintSystem<F>,\n    q_enable: Column<Fixed>,\n    tag: BinaryNumberConfig<CopyDataType, 4>,\n    is_precompiled: Column<Advice>,\n    is_tx_calldata: Column<Advice>,\n    is_bytecode: Column<Advice>,\n    is_memory: Column<Advice>,\n    is_tx_log: Column<Advice>,\n) {\n    meta.create_gate(\"decode tag\", |meta| {\n        let enabled = meta.query_fixed(q_enable, CURRENT);\n        let is_precompile = meta.query_advice(is_precompiled, CURRENT);\n        let is_tx_calldata = meta.query_advice(is_tx_calldata, CURRENT);\n        let is_bytecode = meta.query_advice(is_bytecode, CURRENT);\n        let is_memory = meta.query_advice(is_memory, CURRENT);\n        let is_tx_log = meta.query_advice(is_tx_log, CURRENT);\n        let precompiles = sum::expr([\n            tag.value_equals(\n                CopyDataType::Precompile(PrecompileCalls::Ecrecover),\n                CURRENT,\n            )(meta),\n            tag.value_equals(CopyDataType::Precompile(PrecompileCalls::Sha256),\n            CURRENT)(meta),\n            tag.value_equals(\n                CopyDataType::Precompile(PrecompileCalls::Ripemd160),\n                CURRENT,\n            )(meta),\n            tag.value_equals(CopyDataType::Precompile(PrecompileCalls::Identity),\n            CURRENT)(meta),\n            tag.value_equals(CopyDataType::Precompile(PrecompileCalls::Modexp),\n            CURRENT)(meta),\n            tag.value_equals(CopyDataType::Precompile(PrecompileCalls::Bn128Add),\n            CURRENT)(meta),\n            tag.value_equals(CopyDataType::Precompile(PrecompileCalls::Bn128Mul),\n            CURRENT)(meta),\n            tag.value_equals(\n                CopyDataType::Precompile(PrecompileCalls::Bn128Pairing),\n                CURRENT,\n            )(meta),\n            tag.value_equals(CopyDataType::Precompile(PrecompileCalls::Blake2F),\n            CURRENT)(meta),\n        ]);\n        vec![\n            // Match boolean indicators to their respective tag values.\n            enabled.expr() * (is_precompile - precompiles),\n            enabled.expr()\n            * (is_tx_calldata - tag.value_equals(CopyDataType::TxCalldata,\n            CURRENT)(meta)),\n            enabled.expr()\n            * (is_bytecode - tag.value_equals(CopyDataType::Bytecode,\n            CURRENT)(meta)),\n            enabled.expr() * (is_memory - tag.value_equals(CopyDataType::Memory,\n            CURRENT)(meta)),\n            enabled.expr() * (is_tx_log - tag.value_equals(CopyDataType::TxLog,\n            CURRENT)(meta)),\n        ]\n    });\n}",
        "language": "rust",
        "description": "Figure 7.1: copy_circuit/copy_gadgets.rs#13‚Äì62"
      },
      {
        "type": "text",
        "text": "In fact, the tag value could equal `CopyDataType::RlcAcc`, as in the `SHA3` gadget. The `CopyDataType::Padding` value is also not currently matched."
      },
      {
        "type": "text",
        "text": "In the current state of the codebase, this issue does not appear to cause any soundness issues because the lookups into the Copy table either use a statically set source and destination tag or, as in the case of precompiles, the value is correctly bounded and does not pose an avenue of attack for a malicious prover."
      },
      {
        "type": "text",
        "text": "We also observe that the Copy circuit specification mentions a witness value for the `is_rlc_acc` case, but this is not reflected in the code."
      }
    ],
    "impact": "",
    "recommendation": "Short term, ensure that the tag column is fully constrained. Review the circuit specification and match the implementation with the specification, documenting possible optimizations that remove constraints and detailing why they do not cause soundness issues. Long term, include negative tests for an unintended tag value.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf"
    }
  },
  {
    "title":"The \"invalid creation\" error handling circuit is unconstrained",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Marc Ilunga"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/v0.4",
        "commit_hash": "7b56d0b323e92ac11e54213520f6e7db41941cd0"
      },
      {
        "name": "copy-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/fc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      },
      {
        "name": "super_circuit.rs",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/blob/fc6c8a2972870e62e96cde480b3aa48c0cc1303d/zkevm-circuits/src/super_circuit.rs",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf",
    "severity": "high",
    "difficulty": "medium",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL2-8",
    "target_file": "evm_circuit/execution/error_invalid_creation_code.rs",
    "content": [
      {
        "type": "text",
        "text": "The \"invalid creation\" error handling circuit does not constrain the first byte of the actual memory to be `0xef` as intended. This allows a malicious prover to redirect the EVM execution to a halt after the `CREATE` opcode is called, regardless of the memory value."
      },
      {
        "type": "text",
        "text": "The `ErrorInvalidCreationCodeGadget` circuit was updated to accommodate the memory addressing optimizations. However, in doing so, the `first_byte` witness value that was bound to the memory's first byte is no longer bound to it. Therefore, a malicious prover can always satisfy the circuit constraints, even if they are not in an error state after the `CREATE` opcode is called."
      },
      {
        "type": "code",
        "code": "fn configure(cb: &mut EVMConstraintBuilder<F>) -> Self {\n    let opcode = cb.query_cell();\n    let first_byte = cb.query_cell();\n    //let address = cb.query_word_rlc();\n    let offset = cb.query_word_rlc();\n    let length = cb.query_word_rlc();\n    let value_left = cb.query_word_rlc();\n    cb.stack_pop(offset.expr());\n    cb.stack_pop(length.expr());\n    cb.require_true(\"is_create is true\", cb.curr.state.is_create.expr());\n    let address_word = MemoryWordAddress::construct(cb, offset.clone());\n    // lookup memory for first word\n    cb.memory_lookup(\n        0.expr(),\n        address_word.addr_left(),\n        value_left.expr(),\n        value_left.expr(),\n        None,\n    );\n    // let first_byte = value_left.cells[address_word.shift()];\n    // constrain first byte is 0xef\n    let is_first_byte_invalid = IsEqualGadget::construct(cb, first_byte.expr(),\n    0xef.expr());\n    cb.require_true(\n        \"is_first_byte_invalid is true\",\n        is_first_byte_invalid.expr(),\n    );",
        "language": "rust",
        "description": "Figure 8.1: evm_circuit/execution/error_invalid_creation_code.rs#36‚Äì67"
      }
    ],
    "impact": "A malicious prover generates two different proofs for the same transaction, one leading to the error state, and the other successfully executing the `CREATE` opcode. Distributing these proofs to two ends of a bridge leads to state divergence and a loss of funds.",
    "recommendation": "Short term, bind the `first_byte` witness value to the memory value; ensure that the successful `CREATE` end state checks that the first byte is different from `0xef`. Long term, investigate ways to generate malicious traces that could be added to the test suite; every time a new soundness issue is found, create such a malicious trace and add it to the test suite.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf"
    }
  },
  {
    "title":"The OneHot primitive allows more than one value at once",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Marc Ilunga"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/v0.4",
        "commit_hash": "7b56d0b323e92ac11e54213520f6e7db41941cd0"
      },
      {
        "name": "copy-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/fc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      },
      {
        "name": "super_circuit.rs",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/blob/fc6c8a2972870e62e96cde480b3aa48c0cc1303d/zkevm-circuits/src/super_circuit.rs",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf",
    "severity": "high",
    "difficulty": "low",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL2-9",
    "target_file": "constraint_builder/binary_column.rs",
    "content": [
      {
        "type": "text",
        "text": "The `OneHot` primitive uses `BinaryQuery` values as witness values. However, despite their name, these values are not constrained to be Boolean values, allowing a malicious prover to choose more than one \"hot\" value in the data structure."
      },
      {
        "type": "code",
        "code": "impl<T: IntoEnumIterator + Hash + Eq> OneHot<T> {\n    pub fn configure<F: FieldExt>(\n        cs: &mut ConstraintSystem<F>,\n        cb: &mut ConstraintBuilder<F>,\n    ) -> Self {\n        let mut columns = HashMap::new();\n        for variant in Self::nonfirst_variants() {\n            columns.insert(variant, cb.binary_columns::<1>(cs)[0]);\n        }\n        let config = Self { columns };\n        cb.assert(\n            \"sum of binary columns in OneHot is 0 or 1\",\n            config.sum(0).or(!config.sum(0)),\n        );\n        config\n    }",
        "language": "rust",
        "description": "Figure 9.1: mpt-circuit/src/gadgets/one_hot.rs#14‚Äì30"
      },
      {
        "type": "text",
        "text": "The reason the `BinaryQuery` values are not constrained to be Boolean is because the `BinaryColumn` configuration does not constrain the advice values to be Boolean, and the configuration is simply a type wrapper around the `Column<Advice>` type. This provides no guarantees to the users of this API, who might assume that these values are guaranteed to be Boolean."
      },
      {
        "type": "code",
        "code": "pub fn configure<F: FieldExt>(\n    cs: &mut ConstraintSystem<F>,\n    _cb: &mut ConstraintBuilder<F>,\n) -> Self {\n    let advice_column = cs.advice_column();\n    // TODO: constrain to be binary here...\n    // cb.add_constraint()\n    Self(advice_column)\n}",
        "language": "rust",
        "description": "Figure 9.2: mpt-circuit/src/constraint_builder/binary_column.rs#29‚Äì37"
      },
      {
        "type": "text",
        "text": "The `OneHot` primitive is used to implement the Merkle path‚Äìchecking state machine, including critical properties such as requiring the `key` and `other_key` columns to remain unchanged along a given Merkle path calculation, as shown in figure 9.3."
      },
      {
        "type": "code",
        "code": "cb.condition(\n    !segment_type.current_matches(&[SegmentType::Start, SegmentType::AccountLeaf3]),\n    |cb| {\n        cb.assert_equal(\n            \"key can only change on Start or AccountLeaf3 rows\",\n            key.current(),\n            key.previous(),\n        );\n        cb.assert_equal(\n            \"other_key can only change on Start or AccountLeaf3 rows\",\n            other_key.current(),\n            other_key.previous(),\n        );\n    },\n);",
        "language": "rust",
        "description": "Figure 9.3: mpt-circuit/src/gadgets/mpt_update.rs#170‚Äì184"
      },
      {
        "type": "text",
        "text": "We did not develop a proof-of-concept exploit for the path-checking table, so it may be the case that the constraint in figure 9.3 is not exploitable due to other constraints. However, if at any point it is possible to match both `SegmentType::Start` and some other segment type (such as by setting one `OneHot` cell to `1` and another to `-1`), a malicious prover would be able to change the key partway through and forge Merkle updates."
      }
    ],
    "impact": "A malicious prover uses the `OneHot` soundness issue to bypass constraints, ensuring that the `key` and `other_key` columns remain unchanged along a given Merkle path calculation. This allows the attacker to successfully forge MPT update proofs that update an arbitrary key.",
    "recommendation": "Short term, add constraints that ensure that the advice values from these columns are Boolean. Long term, add positive and negative tests ensuring that these constraint builders operate according to their expectations.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf"
    }
  },
  {
    "title":"Intermediate columns are not explicit",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Filipe Casal","Joe Doyle","and Marc Ilunga"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/v0.4",
        "commit_hash": "7b56d0b323e92ac11e54213520f6e7db41941cd0"
      },
      {
        "name": "copy-circuit",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/fc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      },
      {
        "name": "super_circuit.rs",
        "description": "Types: Rust, halo2. Platform: Native.",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/blob/fc6c8a2972870e62e96cde480b3aa48c0cc1303d/zkevm-circuits/src/super_circuit.rs",
        "commit_hash": "fc6c8a2972870e62e96cde480b3aa48c0cc1303d"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL2-10",
    "target_file": "src/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "The MPT update circuit includes two arrays of \"intermediate value\" columns, as shown in figure 10.1."
      },
      {
        "type": "code",
        "code": "intermediate_values: [AdviceColumn; 10], // can be 4?\nsecond_phase_intermediate_values: [SecondPhaseAdviceColumn; 10], // 4?",
        "language": "rust",
        "description": "Figure 10.1: mpt-circuit/src/gadgets/mpt_update.rs#65‚Äì66"
      },
      {
        "type": "text",
        "text": "These columns are used as general-use cells for values that are only conditionally needed in a given row, reducing the total number of columns needed. For example, figure 10.2 shows that `intermediate_values[0]` is used for the `address` value in rows that match `SegmentType::Start`, but as shown in figure 10.3, rows representing the `SegmentType::AccountLeaf3` state of a Keccak code-hash proof use that same slot for the `old_high` value."
      },
      {
        "type": "code",
        "code": "let address = self.intermediate_values[0].current() * is_start();",
        "language": "rust",
        "description": "Figure 10.2: mpt-circuit/src/gadgets/mpt_update.rs#78"
      },
      {
        "type": "code",
        "code": "SegmentType::AccountLeaf3 => {\n    cb.assert_equal(\"direction is 1\", config.direction.current(), Query::one());\n    let [old_high, old_low, new_high, new_low, ..] = config.intermediate_values;",
        "language": "rust",
        "description": "Figure 10.3: mpt-circuit/src/gadgets/mpt_update.rs#1632‚Äì1635"
      },
      {
        "type": "text",
        "text": "In some cases, cells of `intermediate_values` are used starting from the end of the `intermediate_values` column, such as the `other_key_hash` and `other_leaf_data_hash` values in `PathType::ExtensionOld` rows, as illustrated in figure 10.4."
      },
      {
        "type": "code",
        "code": "let [.., key_equals_other_key, new_hash_is_zero] = config.is_zero_gadgets;\nlet [.., other_key_hash, other_leaf_data_hash] = config.intermediate_values;\nnonexistence_proof::configure(\n    cb,\n    config.new_value,\n    config.key,\n    config.other_key,\n    key_equals_other_key,\n    config.new_hash,\n    new_hash_is_zero,\n    other_key_hash,\n    other_leaf_data_hash,\n    poseidon,\n);",
        "language": "rust",
        "description": "Figure 10.4: mpt-circuit/src/gadgets/mpt_update.rs#1036‚Äì1049"
      },
      {
        "type": "text",
        "text": "Although we did not find any mistakes such as misused columns, this pattern is ad hoc and error-prone, and evaluating the correctness of this pattern requires checking every individual use of `intermediate_values`."
      }
    ],
    "impact": "",
    "recommendation": "Short term, document the assignment of all `intermediate_values` columns in each relevant case. Long term, consider using Rust types to express the different uses of the various `intermediate_values` columns. For example, one could define an `IntermediateValues` enum, with cases like `StartRow { address: &AdviceColumn }` and `ExtensionOld { other_key_hash: &AdviceColumn, other_leaf_data_hash: &AdviceColumn }`, and a single function `fn parse_intermediate_values(segment_type: SegmentType, path_type: PathType, columns: &[AdviceColumn; 10]) -> IntermediateValues`. Then, the correct assignment and use of `intermediate_values` columns can be audited only by checking `parse_intermediate_values`.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/08/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scroll-zkEVM-wave2-securityreview.pdf"
    }
  },
  {
    "title":"Transaction pool fails to drop transactions that cannot afford L1 fees",
    "source":"Trail Of Bits",
    "protocol":"Scroll l2geth",
    "protocol_type":"L2GETH",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Benjamin Samuels and Damilola Edwards"],
    "scope": [
      {
        "name": "l2geth",
        "description": "Type: Go",
        "repository": "https://github.com/scroll-tech/go-ethereum/compare/compare..scroll-tech:go-ethereum:audit-v1",
        "commit_hash": "audit-v1@2dcc60a082ff89d1c57e497f23daad4823b2fdea"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "low",
    "type": "Data Validation",
    "finding_id": "TOB-L2GETH-1",
    "target_file": "core/types/transaction.go",
    "content": [
      {
        "type": "text",
        "text": "l2geth defines two fees that must be paid for L2 transactions: an L2 fee and an L1 fee. However, the code fails to account for L1 fees; as a result, transactions that cannot afford the combined L1 and L2 fees may be included in a block rather than demoted, as intended."
      },
      {
        "type": "text",
        "text": "The transaction.go file defines a Cost() function that returns the amount of ether that a transaction consumes, as shown in figure 1.1. The current implementation of Cost() does not account for L1 fees, causing other parts of the codebase to misjudge the balance requirements to execute a transaction. The correct implementation of Cost() should match the implementation of VerifyFee(), which correctly checks for L1 fees."
      },
      {
        "type": "code",
        "code": "// Cost returns gas * gasPrice + value.\nfunc (tx *Transaction) Cost() *big.Int {\ntotal := new(big.Int).Mul(tx.GasPrice(), new(big.Int).SetUint64(tx.Gas()))\ntotal.Add(total, tx.Value())\nreturn total\n}",
        "language": "go",
        "description": "Figure 1.1: The Cost() function does not include L1 fees in its calculation. (go-ethereum/core/types/transaction.go#318‚Äì323)"
      },
      {
        "type": "text",
        "text": "Most notably, Cost() is consumed by the tx_list.Filter() function, which is used to prune un-executable transactions (transactions that cannot afford the fees), as shown in figure 1.2. The failure to account for L1 fees in Cost() could cause tx_list.Filter() to fail to demote such transactions, causing them to be incorrectly included in the block."
      },
      {
        "type": "code",
        "code": "func (l *txList) Filter(costLimit *big.Int, gasLimit uint64) (types.Transactions, types.Transactions) {\n// If all transactions are below the threshold, short circuit\nif l.costcap.Cmp(costLimit) <= 0 && l.gascap <= gasLimit {\nreturn nil, nil\n}\nl.costcap = new(big.Int).Set(costLimit) // Lower the caps to the thresholds\nl.gascap = gasLimit\n// Filter out all the transactions above the account's funds\nremoved := l.txs.Filter(func(tx *types.Transaction) bool {\nreturn tx.Gas() > gasLimit || tx.Cost().Cmp(costLimit) > 0\n})",
        "language": "go",
        "description": "Figure 1.2: Filter() uses Cost() to determine which transactions to demote. (go-ethereum/core/tx_list.go#332‚Äì343)"
      }
    ],
    "impact": "A user creates an L2 transaction that can just barely afford the L1 and L2 fees in the next upcoming block. Their transaction is delayed due to full blocks and is included in a future block in which the L1 fees have risen. Their transaction reverts due to the increased L1 fees instead of being ejected from the transaction pool.",
    "recommendation": "Short term, refactor the Cost() function to account for L1 fees, as is done in the VerifyFee() function; alternatively, have the transaction list structure use VerifyFee() or a similar function instead of Cost(). Long term, add additional tests to verify complex state transitions such as a transaction becoming un-executable due to changes in L1 fees.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf"
    }
  },
  {
    "title":"Multiple instances of unchecked errors",
    "source":"Trail Of Bits",
    "protocol":"Scroll l2geth",
    "protocol_type":"L2GETH",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Benjamin Samuels and Damilola Edwards"],
    "scope": [
      {
        "name": "l2geth",
        "description": "Type: Go",
        "repository": "https://github.com/scroll-tech/go-ethereum/compare/compare..scroll-tech:go-ethereum:audit-v1",
        "commit_hash": "audit-v1@2dcc60a082ff89d1c57e497f23daad4823b2fdea"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf",
    "severity": "low",
    "difficulty": "high",
    "type": "Undefined Behavior",
    "finding_id": "TOB-L2GETH-2",
    "target_file": "trie/zkproof/writer.go, trie/sync.go, trie/proof.go, trie/committer.go, trie/database.go",
    "content": [
      {
        "type": "text",
        "text": "There are multiple instances of unchecked errors in the l2geth codebase, which could lead to undefined behavior when errors are raised. One such unhandled error is shown in figure 2.1. A comprehensive list of unchecked errors is provided in appendix C."
      },
      {
        "type": "code",
        "code": "if len(requests) == 0 && req.deps == 0 {\n    s.commit(req)\n} else {",
        "language": "go",
        "description": "Figure 2.1: The Sync.commit() function returns an error that is unhandled, which could lead to invalid commitments or a frozen chain. (go-ethereum/trie/sync.go#296‚Äì298)"
      },
      {
        "type": "text",
        "text": "Unchecked errors also make the system vulnerable to denial-of-service attacks; they could allow attackers to trigger nil dereference panics in the sequencer node."
      }
    ],
    "impact": "An attacker identifies a way to cause a zkTrie commitment to fail, allowing invalid data to be silently committed by the sequencer.",
    "recommendation": "Short term, add error checks to all functions that can emit Go errors. Long term, add the tools errcheck and ineffassign to l2geth's build pipeline. These tools can be used to detect errors and prevent builds containing unchecked errors from being deployed.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf"
    }
  },
  {
    "title":"Risk of double-spend attacks due to use of single-node Clique consensus without finality API",
    "source":"Trail Of Bits",
    "protocol":"Scroll l2geth",
    "protocol_type":"L2GETH",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Benjamin Samuels and Damilola Edwards"],
    "scope": [
      {
        "name": "l2geth",
        "description": "Type: Go",
        "repository": "https://github.com/scroll-tech/go-ethereum/compare/compare..scroll-tech:go-ethereum:audit-v1",
        "commit_hash": "audit-v1@2dcc60a082ff89d1c57e497f23daad4823b2fdea"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf",
    "severity": "medium",
    "difficulty": "high",
    "type": "Undefined Behavior",
    "finding_id": "TOB-L2GETH-3",
    "target_file": "N/A",
    "content": [
      {
        "type": "text",
        "text": "l2geth uses the proof-of-authority Clique consensus protocol, defined by EIP-255. This consensus type is not designed for single-node networks, and an attacker-controlled sequencer node may produce multiple conflicting forks of the chain to facilitate double-spend attacks."
      },
      {
        "type": "text",
        "text": "The severity of this finding is compounded by the fact that there is no API for an end user to determine whether their transaction has been finalized by L1, forcing L2 users to use ineffective block/time delays to determine finality."
      },
      {
        "type": "text",
        "text": "Clique consensus was originally designed as a replacement for proof-of-work consensus for Ethereum testnets. It uses the same fork choice rule as Ethereum's proof-of-work consensus; the fork with the highest \"difficulty\" should be considered the canonical fork. Clique consensus does not use proof-of-work and cannot update block difficulty using the traditional calculation; instead, block difficulty may be one of two values:"
      },
      {
        "type": "text",
        "text": "‚óè \"1\" if the block was mined by the designated signer for the block height"
      },
      {
        "type": "text",
        "text": "‚óè \"2\" if the block was mined by a non-designated signer for the block height"
      },
      {
        "type": "text",
        "text": "This means that in a network with only one authorized signer, all of the blocks and forks produced by the sequencer will have the same difficulty value, making it impossible for syncing nodes to determine which fork is canonical at the given block height."
      },
      {
        "type": "text",
        "text": "In a normal proof-of-work network, one of the proposed blocks will have a higher difficulty value, causing syncing nodes to re-organize and drop the block with the lower difficulty value. In a single-validator proof-of-authority network, neither block will be preferred, so each syncing node will simply prefer the first block they received."
      },
      {
        "type": "text",
        "text": "This finding is not unique to l2geth; it will be endemic to all L2 systems that have only one authorized sequencer."
      }
    ],
    "impact": "An attacker acquires control over l2geth's centralized sequencer node. The attacker modifies the node to prove two forks: one fork containing a deposit transaction to a centralized exchange, and one fork with no such deposit transaction. The attacker publishes the first fork, and the centralized exchange picks up and processes the deposit transaction. The attacker continues to produce blocks on the second private fork. Once the exchange processes the deposit, the attacker stops generating blocks on the public fork, generates an extra block to make the private fork longer than the public fork, then publishes the private fork to cause a re-organization across syncing nodes. This attack must be completed before the sequencer is required to publish a proof to L1.",
    "recommendation": "Short term, add API methods and documentation to ensure that bridges and centralized exchanges query only for transactions that have been proved and finalized on the L1 network. Long term, decentralize the sequencer in such a way that a majority of sequencers must collude in order to successfully execute a double-spend attack. This design should be accompanied by a slashing mechanism to penalize sequencers that sign conflicting blocks.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf"
    }
  },
  {
    "title":"Improper use of panic",
    "source":"Trail Of Bits",
    "protocol":"Scroll l2geth",
    "protocol_type":"L2GETH",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Benjamin Samuels and Damilola Edwards"],
    "scope": [
      {
        "name": "l2geth",
        "description": "Type: Go",
        "repository": "https://github.com/scroll-tech/go-ethereum/compare/compare..scroll-tech:go-ethereum:audit-v1",
        "commit_hash": "audit-v1@2dcc60a082ff89d1c57e497f23daad4823b2fdea"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf",
    "severity": "lwo",
    "difficulty": "medium",
    "type": "Denial of Service",
    "finding_id": "TOB-L2GETH-4",
    "target_file": "Various areas of the codebase",
    "content": [
      {
        "type": "text",
        "text": "l2geth overuses Go's panic mechanism in lieu of Go's built-in error propagation system, introducing opportunities for denial of service."
      },
      {
        "type": "text",
        "text": "Go has two primary methods through which errors can be reported or propagated up the call stack: the panic method and Go errors. The use of panic is not recommended, as it is unrecoverable: when an operation panics, the Go program is terminated and must be restarted. The use of panic creates a denial-of-service vector that is especially applicable to a centralized sequencer, as a restart of the sequencer would effectively halt the L2 network until the sequencer recovers."
      },
      {
        "type": "text",
        "text": "Some example uses of panic are presented in figures 4.1 to 4.3. These do not represent an exhaustive list of panic statements in the codebase, and the Scroll team should investigate each use of panic in its modified code to verify whether it truly represents an unrecoverable error."
      },
      {
        "type": "code",
        "code": "func sanityCheckByte32Key(b []byte) {\n    if len(b) != 32 && len(b) != 20 {\n        panic(fmt.Errorf(\"do not support length except for 120bit and 256bit now. data: %v len: %v\", b, len(b)))\n    }\n}",
        "language": "go",
        "description": "Figure 4.1: The sanityCheckByte32Key function panics when a trie key does not match the expected size. This function may be called during the execution of certain RPC requests. (go-ethereum/trie/zk_trie.go#44‚Äì48)"
      },
      {
        "type": "code",
        "code": "func (s *StateAccount) MarshalFields() ([]zkt.Byte32, uint32) {\n    fields := make([]zkt.Byte32, 5)\n    if s.Balance == nil {\n        panic(\"StateAccount balance nil\")\n    }\n    if !utils.CheckBigIntInField(s.Balance) {\n        panic(\"StateAccount balance overflow\")\n    }\n    if !utils.CheckBigIntInField(s.Root.Big()) {\n        panic(\"StateAccount root overflow\")\n    }\n    if !utils.CheckBigIntInField(new(big.Int).SetBytes(s.PoseidonCodeHash)) {\n        panic(\"StateAccount poseidonCodeHash overflow\")\n    }",
        "language": "go",
        "description": "Figure 4.2: The MarshalFields function panics when attempting to marshal an object that does not match certain requirements. This function may be called during the execution of certain RPC requests. (go-ethereum/core/types/state_account_marshalling.go#47‚Äì64)"
      },
      {
        "type": "code",
        "code": "func (t *ProofTracer) MarkDeletion(key []byte) {\n    if path, existed := t.emptyTermPaths[string(key)]; existed {\n        // copy empty node terminated path for final scanning\n        t.rawPaths[string(key)] = path\n    } else if path, existed = t.rawPaths[string(key)]; existed {\n        // sanity check\n        leafNode := path[len(path)-1]\n        if leafNode.Type != zktrie.NodeTypeLeaf {\n            panic(\"all path recorded in proofTrace should be ended with leafNode\")\n        }",
        "language": "go",
        "description": "Figure 4.3: The MarkDeletion function panics when the proof tracer contains a path that does not terminate in a leaf node. This function may be called when a syncing node attempts to process an invalid, malicious proof that an attacker has gossiped on the network. (go-ethereum/trie/zktrie_deletionproof.go#120‚Äì130)"
      }
    ],
    "impact": "An attacker identifies an error path that terminates with a panic that can be triggered by a malformed RPC request or proof payload. The attacker leverages this issue to either disrupt the sequencer's operation or prevent follower/syncing nodes from operating properly.",
    "recommendation": "Short term, review all uses of panic that have been introduced by Scroll's changes to go-ethereum. Ensure that these uses of panic truly represent unrecoverable errors, and if not, add error handling logic to recover from the errors. Long term, annotate all valid uses of panic with explanations for why the errors are unrecoverable and, if applicable, how to prevent the unrecoverable conditions from being triggered. l2geth's code review process must also be updated to verify that this documentation exists for new uses of panic that are introduced later.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf"
    }
  },
  {
    "title":"Risk of panic from nil dereference due to flawed error reporting in addressToKey",
    "source":"Trail Of Bits",
    "protocol":"Scroll l2geth",
    "protocol_type":"L2GETH",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Benjamin Samuels and Damilola Edwards"],
    "scope": [
      {
        "name": "l2geth",
        "description": "Type: Go",
        "repository": "https://github.com/scroll-tech/go-ethereum/compare/compare..scroll-tech:go-ethereum:audit-v1",
        "commit_hash": "audit-v1@2dcc60a082ff89d1c57e497f23daad4823b2fdea"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Error Handling",
    "finding_id": "TOB-L2GETH-5",
    "target_file": "trie/zkproof/writer.go",
    "content": [
      {
        "type": "text",
        "text": "The addressToKey function, shown in figure 5.1, returns a nil pointer instead of a Go error when an error is returned by the preImage.Hash() function, which will cause a nil dereference panic in the NewZkTrieProofWriter function, as shown in figure 5.2."
      },
      {
        "type": "text",
        "text": "If the error generated by preImage.Hash() is unrecoverable, the addressToKey function should panic instead of silently returning a nil pointer."
      },
      {
        "type": "code",
        "code": "func addressToKey(addr common.Address) *zkt.Hash {\n    var preImage zkt.Byte32\n    copy(preImage[:], addr.Bytes())\n    h, err := preImage.Hash()\n    if err != nil {\n        log.Error(\"hash failure\", \"preImage\", hexutil.Encode(preImage[:]))\n        return nil\n    }\n    return zkt.NewHashFromBigInt(h)\n}",
        "language": "go",
        "description": "Figure 5.1: The addressToKey function returns a nil pointer to zkt.Hash when an error is returned by preImage.Hash(). (go-ethereum/trie/zkproof/writer.go#31‚Äì41)"
      },
      {
        "type": "code",
        "code": "func NewZkTrieProofWriter(storage *types.StorageTrace) (*zktrieProofWriter, error) {\n    underlayerDb := memorydb.New()\n    zkDb := trie.NewZktrieDatabase(underlayerDb)\n    accounts := make(map[common.Address]*types.StateAccount)\n    // resuming proof bytes to underlayerDb\n    for addrs, proof := range storage.Proofs {\n        if n := resumeProofs(proof, underlayerDb); n != nil {\n            addr := common.HexToAddress(addrs)\n            if n.Type == zktrie.NodeTypeEmpty {\n                accounts[addr] = nil\n            } else if acc, err := types.UnmarshalStateAccount(n.Data()); err == nil {\n                if bytes.Equal(n.NodeKey[:], addressToKey(addr)[:]) {\n                    accounts[addr] = acc",
        "language": "go",
        "description": "Figure 5.2: The addressToKey function is consumed by NewZkTrieProofWriter, which will attempt to dereference the nil pointer and generate a system panic. (go-ethereum/trie/zkproof/writer.go#152‚Äì167)"
      }
    ],
    "impact": "",
    "recommendation": "Short term, modify addressToKey so that it either returns an error that its calling functions can propagate or, if the error is unrecoverable, panics instead of returning a nil pointer. Long term, update Scroll's code review and style guidelines to reflect that errors must be propagated by Go's error system or must halt the program by using panic.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf"
    }
  },
  {
    "title":"Risk of transaction pool admission denial of service",
    "source":"Trail Of Bits",
    "protocol":"Scroll l2geth",
    "protocol_type":"L2GETH",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Benjamin Samuels and Damilola Edwards"],
    "scope": [
      {
        "name": "l2geth",
        "description": "Type: Go",
        "repository": "https://github.com/scroll-tech/go-ethereum/compare/compare..scroll-tech:go-ethereum:audit-v1",
        "commit_hash": "audit-v1@2dcc60a082ff89d1c57e497f23daad4823b2fdea"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf",
    "severity": "low",
    "difficulty": "low",
    "type": "Denial of Service",
    "finding_id": "TOB-L2GETH-6",
    "target_file": "core/tx_pool.go",
    "content": [
      {
        "type": "text",
        "text": "l2geth's changes to the transaction pool include an ECDSA recovery operation at the beginning of the pool's transaction validation logic, introducing a denial-of-service vector: an attacker could generate invalid transactions to exhaust the sequencer's resources."
      },
      {
        "type": "text",
        "text": "l2geth adds an L1 fee that all L2 transactions must pay. To verify that an L2 transaction can afford the L1 fee, the transaction pool calls fees.VerifyFee(), as shown in figure 6.1. VerifyFee() performs an ECDSA recovery operation to determine the account that will pay the L1 fee, as shown in figure 6.2."
      },
      {
        "type": "text",
        "text": "ECDSA key recovery is an expensive operation that should be executed as late in the transaction validation process as possible in order to reduce the impact of denial-of-service attacks."
      },
      {
        "type": "code",
        "code": "func (pool *TxPool) add(tx *types.Transaction, local bool) (replaced bool, err error) {\n    // If the transaction is already known, discard it\n    hash := tx.Hash()\n    if pool.all.Get(hash) != nil {\n        log.Trace(\"Discarding already known transaction\", \"hash\", hash)\n        knownTxMeter.Mark(1)\n        return false, ErrAlreadyKnown\n    }\n    // Make the local flag. If it's from local source or it's from the network but\n    // the sender is marked as local previously, treat it as the local transaction.\n    isLocal := local || pool.locals.containsTx(tx)\n    if pool.chainconfig.Scroll.FeeVaultEnabled() {\n        if err := fees.VerifyFee(pool.signer, tx, pool.currentState); err != nil {",
        "language": "go",
        "description": "Figure 6.1: TxPool.add() calls fees.VerifyFee() before any other transaction validators are called. (go-ethereum/core/tx_pool.go#684‚Äì697)"
      },
      {
        "type": "code",
        "code": "func VerifyFee(signer types.Signer, tx *types.Transaction, state StateDB) error {\n    from, err := types.Sender(signer, tx)\n    if err != nil {\n        return errors.New(\"invalid transaction: invalid sender\")\n    }",
        "language": "go",
        "description": "Figure 6.2: VerifyFee() initiates an ECDSA recovery operation via types.Sender(). (go-ethereum/rollup/fees/rollup_fee.go#198‚Äì202)"
      }
    ],
    "impact": "An attacker generates a denial-of-service attack against the sequencer by submitting extraordinarily large transactions. Because ECDSA recovery is a CPU-intensive operation and is executed before the transaction size is checked, the attacker is able to exhaust the memory resources of the sequencer.",
    "recommendation": "Short term, modify the code to check for L1 fees in the TxPool.validateTx() function immediately after that function calls types.Sender(). This will ensure that other, less expensive-to-check validations are performed before the ECDSA signature is recovered. Long term, exercise caution when making changes to code paths that validate information received from public sources or gossip. For changes to the transaction pool, a good general rule of thumb is to validate transaction criteria in the following order: 1. Simple, in-memory criteria that do not require disk reads or data manipulation 2. Criteria that require simple, in-memory manipulations of the data such as checks of the transaction size 3. Criteria that require an in-memory state trie to be checked 4. ECDSA recovery operations 5. Criteria that require an on-disk state trie to be checked. However, note that sometimes these criteria must be checked out of order; for example, the ECDSA recovery operation to identify the origin account may need to be performed before the state trie is checked to determine whether the account can afford the transaction.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf"
    }
  },
  {
    "title":"Syncing nodes fail to check consensus rule for L1 message count",
    "source":"Trail Of Bits",
    "protocol":"Scroll l2geth",
    "protocol_type":"L2GETH",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Benjamin Samuels and Damilola Edwards"],
    "scope": [
      {
        "name": "l2geth",
        "description": "Type: Go",
        "repository": "https://github.com/scroll-tech/go-ethereum/compare/compare..scroll-tech:go-ethereum:audit-v1",
        "commit_hash": "audit-v1@2dcc60a082ff89d1c57e497f23daad4823b2fdea"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf",
    "severity": "high",
    "difficulty": "low",
    "type": "Data Validation",
    "finding_id": "TOB-L2GETH-7",
    "target_file": "core/block_validator.go",
    "content": [
      {
        "type": "text",
        "text": "l2geth adds a consensus rule requiring that there be no more than L1Config.NumL1MessagesPerBlock number of L1 messages per L2 block. This rule is checked by the sequencer when building new blocks but is not checked by syncing nodes through the ValidateL1Messages function, as shown in figure 7.1."
      },
      {
        "type": "code",
        "code": "// TODO: consider adding a rule to enforce L1Config.NumL1MessagesPerBlock.\n// If there are L1 messages available, sequencer nodes should include them.\n// However, this is hard to enforce as different nodes might have different views of L1.",
        "language": "go",
        "description": "Figure 7.1: The ValidateL1Messages function does not check the NumL1MessagesPerBlock restriction. (go-ethereum/core/block_validator.go#145‚Äì147)"
      },
      {
        "type": "text",
        "text": "The TODO comment shown in the figure expresses a concern that syncing nodes cannot enforce NumL1MessagesPerBlock due to the different view of L1 that the nodes may have; however, this issue does not prevent syncing nodes from simply checking the number of L1 messages included in the block."
      }
    ],
    "impact": "A malicious sequencer ignores the NumL1MessagesPerBlock restriction while constructing a block, thus bypassing the consensus rules. Follower nodes consider the block to be valid even though the consensus rule is violated.",
    "recommendation": "Short term, add a check to ValidateL1Messages to check the maximum number of L1 messages per block restriction. Long term, document and check all changes to the system's consensus rules to ensure that both nodes that construct blocks and nodes that sync blocks check the consensus rules. This includes having syncing nodes check whether an L1 transaction actually exists on the L1, a concern expressed in comments further up in the ValidateL1Messages function.",
    "auditFirm": "Trail of Bits",
    "publishDate": "09/12/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-initial-securityreview.pdf"
    }
  },
  {
    "title":"Attacker can prevent L2 transactions from being added to a block",
    "source":"Trail Of Bits",
    "protocol":"Scroll l2geth",
    "protocol_type":"L2GETH",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Anish Naik", "Nat Chin", "Vara Prasad Bandaru"],
    "scope": [
      {
        "name": "l2geth",
        "description": "Type: Go",
        "repository": "https://github.com/scroll-tech/go-ethereum/compare/compare..scroll-tech:go-ethereum:audit-v1",
        "commit_hash": "audit-v1@2dcc60a082ff89d1c57e497f23daad4823b2fdea"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-securityreview.pdf",
    "severity": "high",
    "difficulty": "low",
    "type": "Denial of Service",
    "finding_id": "TOB-L2GETH-1",
    "target_file": "miner/worker.go",
    "content": [
      {
        "type": "text",
        "text": "The commitTransactions function returns a flag that determines whether to halt transaction production, even if the block has room for more transactions to be added."
      },
      {
        "type": "text",
        "text": "If the circuit checker returns an error either for row consumption being too high or reasons unknown, the circuitCapacityReached flag is set to true (figure 1.1)."
      },
      {
        "type": "code",
        "code": "case (errors.Is(err, circuitcapacitychecker.ErrTxRowConsumptionOverflow) &&\ntx.IsL1MessageTx()):\n// Circuit capacity check: L1MessageTx row consumption too high, shift to the\nnext from the account,\n// because we shouldn't skip the entire txs from the same account.\n// This is also useful for skipping \"problematic\" L1MessageTxs.\nqueueIndex := tx.AsL1MessageTx().QueueIndex\nlog.Trace(\"Circuit capacity limit reached for a single tx\", \"tx\",\ntx.Hash().String(), \"queueIndex\", queueIndex)\nlog.Info(\"Skipping L1 message\", \"queueIndex\", queueIndex, \"tx\",\ntx.Hash().String(), \"block\", w.current.header.Number, \"reason\", \"row consumption\noverflow\")\nw.current.nextL1MsgIndex = queueIndex + 1\n// after `ErrTxRowConsumptionOverflow`, ccc might not revert updates\n// associated with this transaction so we cannot pack more transactions.\n// TODO: fix this in ccc and change these lines back to `txs.Shift()`\ncircuitCapacityReached = true\nbreak loop\ncase (errors.Is(err, circuitcapacitychecker.ErrTxRowConsumptionOverflow) &&\n!tx.IsL1MessageTx()):\n// Circuit capacity check: L2MessageTx row consumption too high, skip the\naccount.\n// This is also useful for skipping \"problematic\" L2MessageTxs.\nlog.Trace(\"Circuit capacity limit reached for a single tx\", \"tx\",\ntx.Hash().String())\n// after `ErrTxRowConsumptionOverflow`, ccc might not revert updates\n// associated with this transaction so we cannot pack more transactions.\n// TODO: fix this in ccc and change these lines back to `txs.Pop()`\ncircuitCapacityReached = true\nbreak loop\ncase (errors.Is(err, circuitcapacitychecker.ErrUnknown) && tx.IsL1MessageTx()):\n// Circuit capacity check: unknown circuit capacity checker error for\nL1MessageTx,\n// shift to the next from the account because we shouldn't skip the entire txs\nfrom the same account\nqueueIndex := tx.AsL1MessageTx().QueueIndex\nlog.Trace(\"Unknown circuit capacity checker error for L1MessageTx\", \"tx\",\ntx.Hash().String(), \"queueIndex\", queueIndex)\nlog.Info(\"Skipping L1 message\", \"queueIndex\", queueIndex, \"tx\",\ntx.Hash().String(), \"block\", w.current.header.Number, \"reason\", \"unknown row\nconsumption error\")\nw.current.nextL1MsgIndex = queueIndex + 1\n// after `ErrUnknown`, ccc might not revert updates associated\n// with this transaction so we cannot pack more transactions.\n// TODO: fix this in ccc and change these lines back to `txs.Shift()`\ncircuitCapacityReached = true\nbreak loop\ncase (errors.Is(err, circuitcapacitychecker.ErrUnknown) && !tx.IsL1MessageTx()):\n// Circuit capacity check: unknown circuit capacity checker error for\nL2MessageTx, skip the account\nlog.Trace(\"Unknown circuit capacity checker error for L2MessageTx\", \"tx\",\ntx.Hash().String())\n// after `ErrUnknown`, ccc might not revert updates associated\n// with this transaction so we cannot pack more transactions.\n// TODO: fix this in ccc and change these lines back to `txs.Pop()`\ncircuitCapacityReached = true\nbreak loop",
        "language": "go",
        "description": "Figure 1.1: Error handling for the circuit capacity checker (worker.go#L1073-L1121)"
      },
      {
        "type": "text",
        "text": "When this flag is set to true, no new transactions will be added even if there is room for additional transactions in the block (figure 1.2)."
      },
      {
        "type": "code",
        "code": "// Fill the block with all available pending transactions.\npending := w.eth.TxPool().Pending(true)\n// Short circuit if there is no available pending transactions.\n// But if we disable empty precommit already, ignore it. Since\n// empty block is necessary to keep the liveness of the network.\nif len(pending) == 0 && pendingL1Txs == 0 && atomic.LoadUint32(&w.noempty) == 0 {\nw.updateSnapshot()\nreturn\n}\n// Split the pending transactions into locals and remotes\nlocalTxs, remoteTxs := make(map[common.Address]types.Transactions), pending\nfor _, account := range w.eth.TxPool().Locals() {\nif txs := remoteTxs[account]; len(txs) > 0 {\ndelete(remoteTxs, account)\nlocalTxs[account] = txs\n}\n}\nvar skipCommit, circuitCapacityReached bool\nif w.chainConfig.Scroll.ShouldIncludeL1Messages() && len(l1Txs) > 0 {\nlog.Trace(\"Processing L1 messages for inclusion\", \"count\", pendingL1Txs)\ntxs := types.NewTransactionsByPriceAndNonce(w.current.signer, l1Txs,\nheader.BaseFee)\nskipCommit, circuitCapacityReached = w.commitTransactions(txs, w.coinbase,\ninterrupt)\nif skipCommit {\nreturn\n}\n}\nif len(localTxs) > 0 && !circuitCapacityReached {\ntxs := types.NewTransactionsByPriceAndNonce(w.current.signer, localTxs,\nheader.BaseFee)\nskipCommit, circuitCapacityReached = w.commitTransactions(txs, w.coinbase,\ninterrupt)\nif skipCommit {\nreturn\n}\n}\nif len(remoteTxs) > 0 && !circuitCapacityReached {\ntxs := types.NewTransactionsByPriceAndNonce(w.current.signer, remoteTxs,\nheader.BaseFee)\n// don't need to get `circuitCapacityReached` here because we don't have\nfurther `commitTransactions`\n// after this one, and if we assign it won't take effect (`ineffassign`)\nskipCommit, _ = w.commitTransactions(txs, w.coinbase, interrupt)\nif skipCommit {\nreturn\n}\n}\n// do not produce empty blocks\nif w.current.tcount == 0 {\nreturn\n}\nw.commit(uncles, w.fullTaskHook, true, tstart)",
        "language": "go",
        "description": "Figure 1.2: Pending transactions are not added if the circuit capacity has been reached. (worker.go#L1284-L1332)"
      }
    ],
    "impact": "Eve, an attacker, sends an L2 transaction that uses ecrecover many times. The transaction is provided to the mempool with enough gas to be the first L2 transaction in the blockchain. Because this causes an error in the circuit checker, it prevents all other L2 transactions from being executed in this block.",
    "recommendation": "Short term, Implement a snapshotting mechanism in the circuit checker to roll back unexpected changes made as a result of incorrect or incomplete computation. Long term, Analyze and document all impacts of error handling across the system to ensure that these errors are handled gracefully. Additionally, clearly document all expected invariants of how the system is expected to behave to ensure that in interactions with other components, these invariants hold throughout the system.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-securityreview.pdf"
    }
  },
  {
    "title":"Unused and dead code",
    "source":"Trail Of Bits",
    "protocol":"Scroll l2geth",
    "protocol_type":"L2GETH",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Anish Naik", "Nat Chin", "Vara Prasad Bandaru"],
    "scope": [
      {
        "name": "l2geth",
        "description": "Type: Go",
        "repository": "https://github.com/scroll-tech/go-ethereum/compare/compare..scroll-tech:go-ethereum:audit-v1",
        "commit_hash": "audit-v1@2dcc60a082ff89d1c57e497f23daad4823b2fdea"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Undefined Behavior",
    "finding_id": "TOB-L2GETH-2",
    "target_file": "Throughout the code",
    "content": [
      {
        "type": "text",
        "text": "Due to the infrastructure setup of this network and the use of a single node clique setup, this fork of geth contains a significant amount of unused logic. Continuing to maintain this code can be problematic and may lead to issues."
      },
      {
        "type": "text",
        "text": "The following are examples of unused and dead code:"
      },
      {
        "type": "text",
        "text": "‚óè Uncle blocks‚Äîwith a single node clique network, there is no chance for uncle blocks to exist, so all the logic that handles and interacts with uncle blocks can be dropped."
      },
      {
        "type": "text",
        "text": "‚óè Redundant logic around updating the L1 queue index"
      },
      {
        "type": "text",
        "text": "‚óè A redundant check on empty blocks in the worker.go file"
      }
    ],
    "impact": "",
    "recommendation": "Short term, Remove anything that is no longer relevant for the current go-etheruem implementation and be sure to document all the changes to the codebase. Long term, Remove all unused code from the codebase.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-securityreview.pdf"
    }
  },
  {
    "title":"Lack of documentation",
    "source":"Trail Of Bits",
    "protocol":"Scroll l2geth",
    "protocol_type":"L2GETH",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Anish Naik", "Nat Chin", "Vara Prasad Bandaru"],
    "scope": [
      {
        "name": "l2geth",
        "description": "Type: Go",
        "repository": "https://github.com/scroll-tech/go-ethereum/compare/compare..scroll-tech:go-ethereum:audit-v1",
        "commit_hash": "audit-v1@2dcc60a082ff89d1c57e497f23daad4823b2fdea"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Unexpected Behavior",
    "finding_id": "TOB-L2GETH-3",
    "target_file": "miner/worker.go",
    "content": [
      {
        "type": "text",
        "text": "Certain areas of the codebase lack documentation, high-level descriptions, and examples, which makes the contracts difficult to review and increases the likelihood of user mistakes."
      },
      {
        "type": "text",
        "text": "Areas that would benefit from being expanded and clarified in code and documentation include the following:"
      },
      {
        "type": "text",
        "text": "‚óè Internals of the CCC. Despite being treated as a black box, the code relies on stateful changes made from geth calls. This suggests that the internal states of the miner's work and the CCC overlap. The lack of documentation regarding these states creates a lack of visibility in evaluating whether there are potential state corruptions or unexpected behavior."
      },
      {
        "type": "text",
        "text": "‚óè Circumstances where transactions are skipped and how they are expected to be handled. During the course of the review, we attempted to reverse engineer the intended behavior of transactions considered skipped by the CCC. The lack of documentation in these areas results in unclear expectations for this code."
      },
      {
        "type": "text",
        "text": "‚óè Error handling standard throughout the system. The codebase handles system errors differently‚Äîin some cases, logging an error and continuing execution or logging traces. Listing out all instances where errors are identified and documenting how they are handled can help ensure that there is no unexpected behavior related to error handling."
      },
      {
        "type": "text",
        "text": "The documentation should include all expected properties and assumptions relevant to the aforementioned aspects of the codebase."
      }
    ],
    "impact": "",
    "recommendation": "Short term, Review and properly document the aforementioned aspects of the codebase. In addition to external documentation, NatSpec and inline code comments could help clarify complexities. Long term Consider writing a formal specification of the protocol.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-08-scrollL2geth-securityreview.pdf"
    }
  },
  {
    "title":"Aggregated public input hash does not include coinbase or difficulty",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL3-1",
    "target_file": "aggregator/src/chunk.rs",
    "content": [
      {
        "type": "text",
        "text": "The public input hash of an aggregated proof represents the public inputs of all SNARKs that the proof aggregates. In the case of zkEVM chunks, the public inputs include commitments to the overall EVM states before and after the chunk and the data included in the blocks of the chunk, as illustrated by the `ChunkHash` struct, shown in figure 1.1."
      },
      {
        "type": "code",
        "code": "pub struct ChunkHash {\n/// Chain identifier\npub chain_id: u64,\n/// state root before this chunk\npub prev_state_root: H256,\n/// state root after this chunk\npub post_state_root: H256,\n/// the withdraw root after this chunk\npub withdraw_root: H256,\n/// the data hash of this chunk\npub data_hash: H256,\n/// if the chunk is a padded chunk\npub is_padding: bool,\n}",
        "language": "rust",
        "description": "Figure 1.1: aggregator/src/chunk.rs#18‚Äì31"
      },
      {
        "type": "text",
        "text": "The data hash does not include all fields of the `BlockContext` struct, as shown in figure 1.2. Some fields in `BlockContext`, shown in figure 1.3, are included in the public input hash through other mechanisms; for example, `chain_id` is used directly to calculate `chunk_pi_hash`. However, the `coinbase` and `difficulty` fields are not included."
      },
      {
        "type": "code",
        "code": "iter::empty()\n// Block Values\n.chain(b_ctx.number.as_u64().to_be_bytes())\n.chain(b_ctx.timestamp.as_u64().to_be_bytes())\n.chain(b_ctx.base_fee.to_be_bytes())\n.chain(b_ctx.gas_limit.to_be_bytes())\n.chain(num_txs.to_be_bytes())",
        "language": "rust",
        "description": "Figure 1.2: aggregator/src/chunk.rs#68‚Äì74"
      },
      {
        "type": "code",
        "code": "pub struct BlockContext {\n    /// The address of the miner for the block\n    pub coinbase: Address,\n    /// The gas limit of the block\n    pub gas_limit: u64,\n    /// The number of the block\n    pub number: Word,\n    /// The timestamp of the block\n    pub timestamp: Word,\n    /// The difficulty of the block\n    pub difficulty: Word,\n    /// The base fee, the minimum amount of gas fee for a transaction\n    pub base_fee: Word,\n    /// The hash of previous blocks\n    pub history_hashes: Vec<Word>,\n    /// The chain id\n    pub chain_id: u64,\n    /// Original Block from geth\n    pub eth_block: eth_types::Block<eth_types::Transaction>,\n}",
        "language": "rust",
        "description": "Figure 1.3: zkevm-circuits/src/witness/block.rs#204‚Äì223"
      },
      {
        "type": "text",
        "text": "The `zkevm-circuits` specification draft describes these fields as constants, so they do not need to be included individually in each chunk's hash, but they should be committed to through some mechanism."
      }
    ],
    "impact": "",
    "recommendation": "Short term, add `coinbase` and `difficulty` to the aggregated public input hash. Long term, develop a specification for how all chain constants such as `chain_id`, `coinbase`, and `difficulty` should be treated when committing to them in the system.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"Use of account_hash_traces cells does not match specification",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL3-2",
    "target_file": "mpt-circuits/src/types.rs, mpt-circuits/spec/mpt-proof.md",
    "content": [
      {
        "type": "text",
        "text": "The `old_account_hash_traces` and `new_account_hash_traces` arrays each contain triples of cells corresponding to input and output values of the Poseidon hash function. These arrays are populated by the `account_hash_traces` function, a portion of which is shown in figure 2.1."
      },
      {
        "type": "code",
        "code": "let mut account_hash_traces = [[Fr::zero(); 3]; 6];\naccount_hash_traces[0] = [codehash_hi, codehash_lo, h1];\naccount_hash_traces[1] = [storage_root, h1, h2];\naccount_hash_traces[2] = [nonce_and_codesize, balance, h3];\naccount_hash_traces[3] = [h3, h2, h4]; //\naccount_hash_traces[4] = [h4, poseidon_codehash, account_hash];\naccount_hash_traces[5] = [\n    account_key,\n    account_hash,\n    domain_hash(account_key, account_hash, HashDomain::Leaf),\n];\naccount_hash_traces",
        "language": "rust",
        "description": "Figure 2.1: src/types.rs#512‚Äì523"
      },
      {
        "type": "text",
        "text": "This assignment does not match the specification in the `mpt-proof.md` specification, shown in figure 2.2."
      },
      {
        "type": "code",
        "code": "- `old_account_hash_traces`: Vector with item in `[[Fr; 3]; 6]`. For non-empty\naccount\n- `[codehash_hi, codehash_lo, h1=hash(codehash_hi, codehash_lo)]`\n- `[h1, storage_root, h2=hash(h1, storage_root)]`\n- `[nonce, balance, h3=hash(nonce, balance)]`\n- `[h3, h2, h4=hash(h3, h2)]`\n- `[1, account_key, h5=hash(1, account_key)]`\n- `[h4, h5, h6=hash(h4, h5)]`",
        "language": "markdown",
        "description": "Figure 2.2: spec/mpt-proof.md#131‚Äì137"
      },
      {
        "type": "text",
        "text": "It appears that the version implemented in `account_hash_traces` matches the use in the rest of the circuit. For example, the snippet shown in figure 2.3 uses the expression `old_account_hash_traces[1][0]` to retrieve the value `old_storage_root`."
      },
      {
        "type": "code",
        "code": "ClaimKind::Storage { .. } | ClaimKind::IsEmpty(Some(_)) => self.old_account.map(|_|\n{\n    let old_account_hash = old_account_hash_traces[5][1];\n    let old_h4 = old_account_hash_traces[4][0];\n    let old_h2 = old_account_hash_traces[1][2];\n    let old_storage_root = old_account_hash_traces[1][0];\n    vec![old_account_hash, old_h4, old_h2, old_storage_root]",
        "language": "rust",
        "description": "Figure 2.3: src/types.rs#642‚Äì647"
      },
      {
        "type": "text",
        "text": "However, this pattern of referring to values in the `account_hash_traces` arrays by their indices is error-prone and difficult to check completely."
      }
    ],
    "impact": "",
    "recommendation": "Short term, update the specification document to reflect the current use of these arrays. Long term, replace ad hoc indexing with a struct that has named fields.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"hash_traces skips invalid leaf hashes",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL3-3",
    "target_file": "mpt-circuits/gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "The `hash_traces` function takes a collection of `Proof` objects and returns an array of the Poseidon hash calls included in those objects, in a format suitable for lookups into the Poseidon table. For hashes in account leaf nodes, the correct domain is chosen by trial and error, as shown in figure 3.1."
      },
      {
        "type": "code",
        "code": "for account_leaf_hash_traces in\n[proof.old_account_hash_traces, proof.new_account_hash_traces]\n{\n    for [left, right, digest] in account_leaf_hash_traces {\n        if domain_hash(left, right, HashDomain::AccountFields) == digest {\n            hash_traces.push(([left, right], HashDomain::AccountFields.into(),\ndigest))\n        } else if domain_hash(left, right, HashDomain::Leaf) == digest {\n            hash_traces.push(([left, right], HashDomain::Leaf.into(), digest))\n        } else if domain_hash(left, right, HashDomain::Pair) == digest {\n            hash_traces.push(([left, right], HashDomain::Pair.into(), digest))\n        }\n    }\n}\n}\nhash_traces",
        "language": "rust",
        "description": "Figure 3.1: mpt-circuit/src/gadgets/mpt_update.rs#2094‚Äì2108"
      },
      {
        "type": "text",
        "text": "If the hash does not match any domain, no entry is added to the returned list."
      },
      {
        "type": "text",
        "text": "This function is publicly exposed, and if it is used for certain purposes, such as generating the lookups in a circuit, it could lead to an underconstrained hash witness."
      },
      {
        "type": "text",
        "text": "`hash_traces` appears to be used only in a testing context, so it does not currently cause any security concerns."
      }
    ],
    "impact": "",
    "recommendation": "Short term, add handling for all cases to `hash_traces`, and explicitly document when it should and should not be used. Long term, document all public functions and provide clear directions for when they should and should not be used.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"Values in chunk_is_valid_cells are not constrained to be Boolean",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL3-4",
    "target_file": "aggregator/src/core.rs",
    "content": [
      {
        "type": "text",
        "text": "The cells in the `chunk_is_valid_cells` vector indicate whether a chunk is real or padded. A padded chunk is simply a copy of the last real chunk. For each chunk, some checks are performed depending on whether it is valid."
      },
      {
        "type": "text",
        "text": "Currently, the `chunk_is_valid_cells` values are not constrained to be Boolean. When used in conditional equality checks, the lack of Boolean enforcement does not pose a problem because the constraint required for the conditional equality forces either the conditioning value to be `0` or the difference of the values under comparison to be `0`."
      },
      {
        "type": "text",
        "text": "However, `chunk_is_valid_cells` is also used to compute the number of valid cells in a batch. The `num_valid_snarks` function, shown in figure 4.1, takes the `chunk_are_valid` argument, which is called with the `chunk_is_valid_cells` value."
      },
      {
        "type": "code",
        "code": "fn num_valid_snarks(\n    rlc_config: &RlcConfig,\n    region: &mut Region<Fr>,\n    chunk_are_valid: &[AssignedCell<Fr, Fr>],\n    offset: &mut usize,\n) -> Result<AssignedCell<Fr, Fr>, halo2_proofs::plonk::Error> {\n    let mut res = chunk_are_valid[0].clone();\n    for e in chunk_are_valid.iter().skip(1) {\n        res = rlc_config.add(region, &res, e, offset)?;\n    }\n    Ok(res)\n}",
        "language": "rust",
        "description": "Figure 4.1: aggregator/src/core.rs#935‚Äì946"
      },
      {
        "type": "text",
        "text": "In practice, the impact of non-Boolean values in `chunk_is_valid_cells` is limited exclusively to the very first chunk. Any non-Boolean chunk other than the first one must satisfy two almost contradictory conditions."
      },
      {
        "type": "text",
        "text": "First, it must be continuous with the previous chunk; that is, its previous root must be equal to the previous chunk's next root, as shown in figure 4.2:"
      },
      {
        "type": "code",
        "code": "// 4 __valid__ chunks are continuous: they are linked via the state roots\nfor i in 0..MAX_AGG_SNARKS - 1 {\n    for j in 0..DIGEST_LEN {\n        ‚Ä¶\n        rlc_config.conditional_enforce_equal(\n            &mut region,\n            &chunk_pi_hash_preimages[i + 1][PREV_STATE_ROOT_INDEX + j],\n            &chunk_pi_hash_preimages[i][POST_STATE_ROOT_INDEX + j],\n            &chunk_is_valid_cells[i + 1],\n            &mut offset,\n        )?;\n    }\n}",
        "language": "rust",
        "description": "Figure 4.2: aggregator/src/core.rs#666‚Äì690"
      },
      {
        "type": "text",
        "text": "Second, it must have equal public inputs to the previous chunk, as shown in figure 4.3:"
      },
      {
        "type": "code",
        "code": "// 6. chunk[i]'s chunk_pi_hash_rlc_cells == chunk[i-1].chunk_pi_hash_rlc_cells when\n// chunk[i] is padded\nlet chunks_are_padding = chunk_is_valid_cells\n    .iter()\n    .map(|chunk_is_valid| rlc_config.not(&mut region, chunk_is_valid, &mut offset))\n    .collect::<Result<Vec<_>, halo2_proofs::plonk::Error>>()?;\nlet chunk_pi_hash_rlc_cells = parse_pi_hash_rlc_cells(data_rlc_cells);\nfor i in 1..MAX_AGG_SNARKS {\n    rlc_config.conditional_enforce_equal(\n        &mut region,\n        chunk_pi_hash_rlc_cells[i - 1],\n        chunk_pi_hash_rlc_cells[i],\n        &chunks_are_padding[i],\n        &mut offset,\n    )?;\n}",
        "language": "rust",
        "description": "Figure 4.3: aggregator/src/core.rs#692‚Äì709"
      },
      {
        "type": "text",
        "text": "This requires the previous and next roots to be equal, which may be possible in non-zkEVM uses but which should not be possible in a zkEVM."
      },
      {
        "type": "text",
        "text": "However, these constraints do not prevent a non-Boolean value for `chunk_is_valid_cells[0]`, so a malicious prover might hope to choose a value for it that enables an exploit. Suppose a batch of nine chunks is being aggregated; in that situation, the prover might hope to generate a proof with the initial and final state roots of `chunks[0..9]` but with the batch hash of `chunks[0..8]`, by setting the value of `chunk_is_valid_cells[0]` to `-1`."
      },
      {
        "type": "text",
        "text": "Several other checks must be passed to generate such a proof."
      },
      {
        "type": "text",
        "text": "First, the batch hash must be the hash corresponding to `chunks[0..8]`. In this case, the flags `(flag1,flag2,flag3)` are `(0,1,0)`, so the chunk data hash will correspond to the second `potential_batch_data_hash_digest` value, as shown in figure 4.4:"
      },
      {
        "type": "code",
        "code": "let rhs = rlc_config.mul(\n    &mut region,\n    &flag1,\n    &potential_batch_data_hash_digest[(3 - i) * 8 + j],\n    &mut offset,\n)?;\nlet rhs = rlc_config.mul_add(\n    &mut region,\n    &flag2,\n    &potential_batch_data_hash_digest[(3 - i) * 8 + j + 32],\n    &rhs,\n    &mut offset,\n)?;\nlet rhs = rlc_config.mul_add(\n    &mut region,\n    &flag3,\n    &potential_batch_data_hash_digest[(3 - i) * 8 + j + 64],\n    &rhs,\n    &mut offset,\n)?;\nregion.constrain_equal(\n    batch_pi_hash_preimage[i * 8 + j + CHUNK_DATA_HASH_INDEX].cell(),\n    rhs.cell(),\n)?;",
        "language": "rust",
        "description": "Figure 4.4: aggregator/src/core.rs#602‚Äì626"
      },
      {
        "type": "text",
        "text": "Second, the Keccak input length must equal `8`, according to the constraints shown in figure 4.5:"
      },
      {
        "type": "code",
        "code": "let data_hash_inputs_len =\n    rlc_config.mul(&mut region, &num_valid_snarks, &const32, &mut offset)?;\n‚Ä¶\nlet mut data_hash_inputs_len_rec = rlc_config.mul(\n    &mut region,\n    &hash_input_len_cells[MAX_AGG_SNARKS * 2 + 3],\n    &flag1,\n    &mut offset,\n)?;\ndata_hash_inputs_len_rec = rlc_config.mul_add(\n    &mut region,\n    &hash_input_len_cells[MAX_AGG_SNARKS * 2 + 4],\n    &flag2,\n    &data_hash_inputs_len_rec,\n    &mut offset,\n)?;\ndata_hash_inputs_len_rec = rlc_config.mul_add(\n    &mut region,\n    &hash_input_len_cells[MAX_AGG_SNARKS * 2 + 5],\n    &flag3,\n    &data_hash_inputs_len_rec,\n    &mut offset,\n)?;\n‚Ä¶\nregion.constrain_equal(\n    data_hash_inputs_len.cell(),\n    data_hash_inputs_len_rec.cell(),\n)?;",
        "language": "rust",
        "description": "Figure 4.5: aggregator/src/core.rs#744‚Äì804"
      },
      {
        "type": "text",
        "text": "Third, the RLC of the Keccak data input must match any of the three possible Keccak RLC values. This constraint seems to prevent any practical use of a non-Boolean value for `chunk_is_valid_cells[0]` because the implementation of `RlcConfig::select`, shown in figure 4.6, returns the result of `(1 - cond) * b + cond * a`, which causes values in different positions of the RLC vector to be mixed together when `cond` equals `-1`."
      },
      {
        "type": "code",
        "code": "// if cond = 1 return a, else b\npub(crate) fn select(\n    &self,\n    region: &mut Region<Fr>,\n    a: &AssignedCell<Fr, Fr>,\n    b: &AssignedCell<Fr, Fr>,\n    cond: &AssignedCell<Fr, Fr>,\n    offset: &mut usize,\n) -> Result<AssignedCell<Fr, Fr>, Error> {\n    // (cond - 1) * b + cond * a\n    let cond_not = self.not(region, cond, offset)?;\n    let tmp = self.mul(region, a, cond, offset)?;\n    self.mul_add(region, b, &cond_not, &tmp, offset)\n}",
        "language": "rust",
        "description": "Figure 4.6: This figure shows `RlcConfig::select`. Note that the comment incorrectly specifies `(cond - 1)` instead of `(1 - cond)`, but either version causes the same \"mixing\" effect for non-Boolean flags. (aggregator/src/aggregation/rlc/gates.rs#296‚Äì309)"
      },
      {
        "type": "text",
        "text": "However, care should be taken when modifying the implementation of `rlc_with_flag`; if it treats all nonzero values of `cond` the same way, this attack may become possible."
      }
    ],
    "impact": "",
    "recommendation": "Short term, add constraints to force the values in `chunk_is_valid_cells` to be Boolean. Long term, document all cases in which a constraint is enforced due to a combination of several constraints spread across the codebase.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"The Sig circuit may reject valid signatures",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "low",
    "difficulty": "high",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL3-5",
    "target_file": "zkevm-circuits/src/sig_circuit/ecdsa.rs",
    "content": [
      {
        "type": "text",
        "text": "The `ecdsa_verify_no_pubkey_check` function performs the steps required to verify an ECDSA signature. The verification procedure requires checking that u‚ÇÅG ‚â† -u‚ÇÇQ, where u‚ÇÅ and u‚ÇÇ are intermediary values generated during signature verification and Q is the public key. The signature verification circuit performs these checks by enforcing that the x coordinate of u‚ÇÅG and u‚ÇÇQ are not equal, as shown in figure 5.1."
      },
      {
        "type": "code",
        "code": "// check u1 * G and u2 * pubkey are not negatives and not equal\n// TODO: Technically they could be equal for a valid signature, but this happens\nwith\n// vanishing probability for an ECDSA signature constructed in a standard\nway\n// coordinates of u1_mul and u2_mul are in proper bigint form, and lie in but are\nnot\n// constrained to [0, n) we therefore need hard inequality here\nlet u1_u2_x_eq = base_chip.is_equal(ctx, &u1_mul.x, &u2_mul.x);\nlet u1_u2_not_neg = base_chip.range.gate().not(ctx, Existing(u1_u2_x_eq));",
        "language": "rust",
        "description": "Figure 5.1: zkevm-circuits/src/sig_circuit/ecdsa.rs#74‚Äì80"
      },
      {
        "type": "text",
        "text": "As the comment in the code snippet in figure 5.1 indicates, checking the x coordinate for equality will also cause the circuit to be unsatisfiable on valid signatures where u‚ÇÅG = u‚ÇÇQ."
      },
      {
        "type": "text",
        "text": "A specially crafted secret key can be used to trigger this incompleteness vulnerability at will."
      },
      {
        "type": "text",
        "text": "This issue was also disclosed in a previous audit of the `halo2-ecc` library for Axiom and Scroll (TOB-AXIOM-4)."
      }
    ],
    "impact": "Alice deploys a multisignature bridge contract from another EVM-like blockchain to the Scroll zkEVM. Bob, who is a signing party, wants to be able to maliciously stall the bridge at some future point. Bob generates a secret key in such a way that some specific, otherwise innocuous transaction will fail `ecdsa_verify_no_pubkey_check` when signed with Bob's key. At a later point, he submits this transaction, which is accepted on the non-Scroll side but which cannot be bridged into the Scroll zkEVM, leading to a denial of service and potentially a loss of funds.",
    "recommendation": "Short term, modify the circuit to ensure that signatures with u‚ÇÅG = u‚ÇÇQ are accepted but signatures with u‚ÇÅG = -u‚ÇÇQ are rejected. Long term, ensure that optimizations preserve correctness even in adversarial settings.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"assigned_y_tmp is not constrained to be 87 bits",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL3-6",
    "target_file": "zkevm-circuits/src/sig_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "Given a signature (r, s, v), the `ecdsa_verify_no_pubkey_check` function uses the parity information in v and recovers the ephemeral point R = (x, y) corresponding to r."
      },
      {
        "type": "text",
        "text": "Concretely, the circuit returns a value indicating whether the signature is valid and the value y."
      },
      {
        "type": "text",
        "text": "The Sig circuit then ensures that the recovered value v is well formed by enforcing that v indeed captures the oddness of y. This is done by showing that there exists a value tmp satisfying the equation v + 2tmp = y‚ÇÄ, where y‚ÇÄ is the first limb of the value y that was previously recovered by `ecdsa_verify_no_pubkey_check`. Furthermore, tmp must be an 87-bit value to ensure soundness. The code snippet in figure 6.1 shows the last check, where tmp corresponds to the `assigned_y_tmp` variable."
      },
      {
        "type": "code",
        "code": "// last step we want to constrain assigned_y_tmp is 87 bits\necc_chip\n    .field_chip\n    .range\n    .range_check(ctx, &assigned_y_tmp, 88);",
        "language": "rust",
        "description": "Figure 6.1: zkevm-circuits/src/sig_circuit.rs#420‚Äì424"
      },
      {
        "type": "text",
        "text": "Contrary to the comment in figure 6.1, the code constraints `assigned_y_tmp` to be 88 bits instead of 87 bits."
      },
      {
        "type": "text",
        "text": "However, this issue is unlikely to lead to any soundness issue because the extra bit afforded to malicious provers is not enough to craft an invalid witness that satisfies the constraints."
      }
    ],
    "impact": "",
    "recommendation": "Short term, constrain `assigned_y_tmp` to be 87 bits. Long term, add negative tests to ensure that invariants are not violated.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"Aggregated proof verification algorithm is unspecified",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL3-7",
    "target_file": "aggregator/",
    "content": [
      {
        "type": "text",
        "text": "The zkEVM proof aggregation circuit architecture described in the `aggregator/README.md` file includes several instances of proof aggregation, in the form of both direct aggregation of proofs and nested aggregation (i.e., aggregation of already-aggregated proofs). Based on our understanding of the architecture and the implementation, the final aggregate proof will consist of a triple (pi_hash, acc, œÄ):"
      },
      {
        "type": "text",
        "text": "1. pi_hash is the hash of the overall public inputs of the aggregated proofs."
      },
      {
        "type": "text",
        "text": "2. acc is the aggregated \"all-but-the-pairing\" proof, which, when verified with a pairing check, should guarantee that each input proof and all aggregation proofs except the very last one all pass verification."
      },
      {
        "type": "text",
        "text": "3. œÄ is a SHPLONK proof that pi_hash and acc are correctly constructed and that, therefore, checking acc with a pairing in fact verifies the overall tree of proofs."
      },
      {
        "type": "text",
        "text": "However, the actual details of how to construct and verify this triple are not clearly specified, documented, or implemented. There are testing-focused macros in the `aggregator/src/tests.rs` file that implement proof generation followed immediately by verification; the different components of the proof are represented by the macros `layer_0`, `compression_layer_snark`, `compression_layer_evm`, and `aggregation_layer_snark`. However, there are no distinct implementations of procedures for the following:"
      },
      {
        "type": "text",
        "text": "‚óè Proving and verifying key generation"
      },
      {
        "type": "text",
        "text": "‚óè Proof generation using the proving key and a witness"
      },
      {
        "type": "text",
        "text": "‚óè Verification using the verification key and a proof"
      },
      {
        "type": "text",
        "text": "Implementing each of these procedures distinctly, especially the key generation and verification procedures, is critical for evaluating the soundness of the aggregate proof system. Even if there are not specific problems in the aggregation or compression circuits, there may be catastrophic issues if vital checks are unintentionally skipped; for example, for key generation to be correct, the verification keys of inner circuits must be constants in the outer circuits, and in the verification algorithm, both the aggregated proof and the outermost aggregation proof must be checked."
      }
    ],
    "impact": "",
    "recommendation": "Short term, develop, implement, and review a clear specification of the proof aggregation circuit. Long term, explicitly document the intended security properties of the zkEVM aggregated proof, and connect those properties to the specification with security proofs or proof sketches.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"Aggregation prover verifies each aggregated proof",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Testing",
    "finding_id": "TOB-SCROLL3-8",
    "target_file": "aggregator/src/aggregation/circuit.rs, aggregator/src/compression/circuit.rs, aggregator/src/core.rs",
    "content": [
      {
        "type": "text",
        "text": "The zkEVM proof aggregation algorithms combine several \"all-but-the-pairing\" proofs into a single \"all-but-the-pairing\" proof which, when verified with a pairing, simultaneously verifies all the constituent proofs."
      },
      {
        "type": "text",
        "text": "As sanity check measures, the functions `extract_accumulators_and_proof`, `AggregationCircuit::new`, and `CompressionCircuit::new` perform a pairing check on each aggregated input proof and on the outer aggregated proof, as shown in figures 8.1, 8.2, and 8.3."
      },
      {
        "type": "code",
        "code": "for (i, acc) in accumulators.iter().enumerate() {\n    let KzgAccumulator { lhs, rhs } = acc;\n    let left = Bn256::pairing(lhs, g2);\n    let right = Bn256::pairing(rhs, s_g2);\n    log::trace!(\"acc extraction {}-th acc check: left {:?}\", i, left);\n    log::trace!(\"acc extraction {}-th acc check: right {:?}\", i, right);\n    if left != right {\n        return Err(snark_verifier::Error::AssertionFailure(format!(\n            \"accumulator check failed {left:?} {right:?}, index {i}\",\n        )));\n    }\n    //assert_eq!(left, right, \"accumulator check failed\");\n}",
        "language": "rust",
        "description": "Figure 8.1: Pairing calls in `extract_accumulators_and_proof` (aggregator/src/core.rs#75‚Äì87)"
      },
      {
        "type": "code",
        "code": "let left = Bn256::pairing(&lhs, &params.g2());\nlet right = Bn256::pairing(&rhs, &params.s_g2());\nlog::trace!(\"aggregation circuit acc check: left {:?}\", left);\nlog::trace!(\"aggregation circuit acc check: right {:?}\", right);\nif left != right {\n    return Err(snark_verifier::Error::AssertionFailure(format!(\n        \"accumulator check failed {left:?} {right:?}\",\n    )));\n}",
        "language": "rust",
        "description": "Figure 8.2: Pairing calls in `AggregationCircuit::new` (aggregator/src/aggregation/circuit.rs#110‚Äì118)"
      },
      {
        "type": "code",
        "code": "let left = Bn256::pairing(&lhs, &params.g2());\nlet right = Bn256::pairing(&rhs, &params.s_g2());\nlog::trace!(\"compression circuit acc check: left {:?}\", left);\nlog::trace!(\"compression circuit acc check: right {:?}\", right);\nif left != right {\n    return Err(snark_verifier::Error::AssertionFailure(format!(\n        \"accumulator check failed {left:?} {right:?}\",\n    )));\n}",
        "language": "rust",
        "description": "Figure 8.3: Pairing calls in `CompressionCircuit::new` (aggregator/src/compression/circuit.rs#205‚Äì214)"
      },
      {
        "type": "text",
        "text": "These checks prevent developers from writing negative tests; for example, they would block a test that aggregates an incorrect proof with many correct proofs and then checks that the result does not pass verification. In addition, pairing calls tend to be expensive to compute, so these calls may unnecessarily decrease prover performance."
      }
    ],
    "impact": "",
    "recommendation": "Short term, make these checks conditional, either with a feature flag or a function parameter; then, write negative tests for aggregation and compression. Long term, ensure that security-critical features such as aggregation verification can be tested both positively and negatively.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"KECCAK_ROWS environment variable may disagree with DEFAULT_KECCAK_ROWS constant",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "low",
    "difficulty": "high",
    "type": "Configuration",
    "finding_id": "TOB-SCROLL3-9",
    "target_file": "aggregator/src/constants.rs, aggregator/src/aggregation/config.rs",
    "content": [
      {
        "type": "text",
        "text": "The number of rows per round of the Keccak-f box in the Keccak table is represented by the `DEFAULT_KECCAK_ROWS` constant in the `aggregator` crate and is used via the calculated `ROWS_PER_ROUND` constant to extract data from the Keccak table, as shown in figure 9.1:"
      },
      {
        "type": "code",
        "code": "if offset % ROWS_PER_ROUND == 0 && offset / ROWS_PER_ROUND <= MAX_KECCAK_ROUNDS\n{\n    // first column is is_final\n    is_final_cells.push(row[0].clone());\n    // second column is data rlc\n    data_rlc_cells.push(row[1].clone());\n    // third column is hash len\n    hash_input_len_cells.push(row[2].clone());\n}",
        "language": "rust",
        "description": "Figure 9.1: aggregator/src/core.rs#253‚Äì261"
      },
      {
        "type": "text",
        "text": "However, the `ROWS_PER_ROUND` constant is not guaranteed to match the parameters of the Keccak circuit, and in fact, the rows-per-round parameter of the Keccak circuit is read from the `KECCAK_ROWS` environment variable multiple times while the circuit is being constructed, as shown in figures 9.2 and 9.3."
      },
      {
        "type": "code",
        "code": "pub(crate) fn get_num_rows_per_round() -> usize {\n    var(\"KECCAK_ROWS\")\n        .unwrap_or_else(|_| format!(\"{DEFAULT_KECCAK_ROWS}\"))\n        .parse()\n        .expect(\"Cannot parse KECCAK_ROWS env var as usize\")\n}",
        "language": "rust",
        "description": "Figure 9.2: zkevm-circuits/src/keccak_circuit/keccak_packed_multi.rs#15‚Äì20"
      },
      {
        "type": "code",
        "code": "for p in 0..3 {\n    column_starts[p] = cell_manager.start_region();\n    let mut row_idx = 0;\n    for j in 0..5 {\n        for _ in 0..num_word_parts {\n            for i in 0..5 {\n                rho_pi_chi_cells[p][i][j]\n                    .push(cell_manager.query_cell_value_at_row(row_idx as i32));\n            }\n            row_idx = (row_idx + 1) % get_num_rows_per_round();\n        }\n    }\n}",
        "language": "rust",
        "description": "Figure 9.3: A loop that repeatedly reads the `KECCAK_ROWS` environment variable (zkevm-circuits/src/keccak_circuit/keccak_packed_multi.rs#677‚Äì689)"
      },
      {
        "type": "text",
        "text": "If this environment variable is incorrect when the verification key is generated, or if it changes during the layout phase, a potentially incorrect circuit may be generated. However, this type of change would affect many parts of the code, including the witness generation implementation, and is unlikely to pass even basic tests. Because of that, we do not consider this to be a plausible soundness problem."
      },
      {
        "type": "text",
        "text": "However, a prover whose environment sets `KECCAK_ROWS` to an incorrect value would consistently fail to create proofs, causing a potential denial-of-service attack vector."
      },
      {
        "type": "text",
        "text": "For example, running the command `KECCAK_ROWS=20 cargo test ‚Äìrelease test_aggregation_circuit` in the `aggregator/` folder fails on the assertion shown in figure 9.4:"
      },
      {
        "type": "code",
        "code": "assert_eq!(\n    columns.len(),\n    87,\n    \"cell manager configuration does not match the hard coded setup\"\n);",
        "language": "rust",
        "description": "Figure 9.4: aggregator/src/aggregation/config.rs#90‚Äì94"
      },
      {
        "type": "text",
        "text": "We did not explore other options for `KECCAK_ROWS` or more sophisticated attack scenarios such as changing the `KECCAK_ROWS` environment variable during prover execution."
      }
    ],
    "impact": "Alice runs a sequencer for the Scroll zkEVM. Bob convinces her to install an MEV optimizer, which under normal conditions behaves normally. However, the optimizer software sets `KECCAK_ROWS` to other values whenever Bob wishes, causing Alice to consistently fail to generate proofs, causing a denial of service.",
    "recommendation": "Short term, change `get_num_rows_per_round` so that it reads `KECCAK_ROWS` only once (e.g., with `lazy_static`), and add assertions to the `aggregator` codebase to make sure that `KECCAK_ROWS` equals `DEFAULT_KECCAK_ROWS`. Long term, document all configuration parameters for the zkEVM circuits and any required relationships between them.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"Incorrect state transitions can be proven for any chunk by manipulating padding flags",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "high",
    "difficulty": "medium",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL3-10",
    "target_file": "aggregator/src/core.rs",
    "content": [
      {
        "type": "text",
        "text": "Due to insufficient constraints in the aggregation circuit's padding logic, a malicious prover can generate two types of invalid proofs:"
      },
      {
        "type": "text",
        "text": "1. For any chunk `A`, a malicious prover can prove that the empty batch steps from `A.prev_root` to `A.next_root`."
      },
      {
        "type": "text",
        "text": "2. For any pair of chunks `(A,B)` that is continuous (i.e., `A.next_root` equals `B.prev_root`), and any choice of data hash `evil_data_hash`, a malicious prover can generate an aggregated proof in which `batch_prev_root` equals `A.prev_root`, `batch_next_root` equals `B.next_root`, and `batch_data_hash` equals `keccak(evil_data_hash)`."
      },
      {
        "type": "text",
        "text": "Attack 1 is problematic but unlikely to occur in practice unless empty batches or sub-batches are allowed to cause state updates."
      },
      {
        "type": "text",
        "text": "Attack 2 is extremely severe because it allows a malicious prover to prove that any `data_hash` has almost any state transition."
      },
      {
        "type": "text",
        "text": "Due to time constraints, we were not able to develop proof-of-concept exploits demonstrating these two attacks, but we believe that such exploits are possible."
      },
      {
        "type": "text",
        "text": "The aggregation circuit takes a sequence of SNARKs s‚ÇÅ,...,s‚Çô and a sequence of \"validity flags\" v‚ÇÅ,...,v‚Çô, where each v·µ¢ is intended to be a Boolean value indicating whether s·µ¢ is a proof for a valid chunk or a padding chunk. Each s·µ¢ must be a correct SNARK, but different rules are enforced on the public inputs of valid and padding chunks. Valid chunks after the first one must be continuous with the previous chunk, while padding chunks after the first one must have exactly equal public inputs to the previous chunk. These checks are shown in figures 10.1 and 10.2."
      },
      {
        "type": "code",
        "code": "// 4 __valid__ chunks are continuous: they are linked via the state roots\nfor i in 0..MAX_AGG_SNARKS - 1 {\n    for j in 0..DIGEST_LEN {\n        ‚Ä¶\n        rlc_config.conditional_enforce_equal(\n            &mut region,\n            &chunk_pi_hash_preimages[i + 1][PREV_STATE_ROOT_INDEX + j],\n            &chunk_pi_hash_preimages[i][POST_STATE_ROOT_INDEX + j],\n            &chunk_is_valid_cells[i + 1],\n            &mut offset,\n        )?;\n    }\n}",
        "language": "rust",
        "description": "Figure 10.1: aggregator/src/core.rs#666‚Äì690"
      },
      {
        "type": "code",
        "code": "// 6. chunk[i]'s chunk_pi_hash_rlc_cells == chunk[i-1].chunk_pi_hash_rlc_cells when\n// chunk[i] is padded\nlet chunks_are_padding = chunk_is_valid_cells\n    .iter()\n    .map(|chunk_is_valid| rlc_config.not(&mut region, chunk_is_valid, &mut offset))\n    .collect::<Result<Vec<_>, halo2_proofs::plonk::Error>>()?;\nlet chunk_pi_hash_rlc_cells = parse_pi_hash_rlc_cells(data_rlc_cells);\nfor i in 1..MAX_AGG_SNARKS {\n    rlc_config.conditional_enforce_equal(\n        &mut region,\n        chunk_pi_hash_rlc_cells[i - 1],\n        chunk_pi_hash_rlc_cells[i],\n        &chunks_are_padding[i],\n        &mut offset,\n    )?;\n}",
        "language": "rust",
        "description": "Figure 10.2: aggregator/src/core.rs#692‚Äì709"
      },
      {
        "type": "text",
        "text": "The `README` section shown in figure 10.3 suggests that, for some situations in which k > 1, the first k chunks will be valid and the last n-k chunks will be padding; however, this is not explicitly enforced by the aggregation circuit, and both attacks rely on manipulation of the validity flags."
      },
      {
        "type": "code",
        "code": "4. chunks are continuous when they are not padded: they are linked via the state\nroots.\n```\nfor i in 1 ... k-1\n    c_i.post_state_root == c_{i+1}.prev_state_root\n```\n5. All the chunks use a same chain id. __Static__.\n```\nfor i in 1 ... n\n    batch.chain_id == chunk[i].chain_id\n```\n6. The last `(n-k)` chunk[i] are padding\n```\nfor i in 1 ... n:\n    if is_padding:\n        chunk[i]'s chunk_pi_hash_rlc_cells == chunk[i-1].chunk_pi_hash_rlc_cells\n```",
        "language": "markdown",
        "description": "Figure 10.3: aggregator/README.md#102‚Äì120"
      },
      {
        "type": "text",
        "text": "Attack 1 involves setting all v·µ¢ flags to `0` and setting all chunks to `A`. When that occurs, all batch public input fields other than `chain_id` and `batch_data_hash` will be calculated from `A`, as shown in figure 10.4."
      },
      {
        "type": "code",
        "code": "for i in 0..DIGEST_LEN {\n    // 2.1 chunk[0].prev_state_root\n    ‚Ä¶\n    region.constrain_equal(\n        batch_pi_hash_preimage[i + PREV_STATE_ROOT_INDEX].cell(),\n        chunk_pi_hash_preimages[0][i + PREV_STATE_ROOT_INDEX].cell(),\n    )?;\n    // 2.2 chunk[k-1].post_state_root\n    ‚Ä¶\n    region.constrain_equal(\n        batch_pi_hash_preimage[i + POST_STATE_ROOT_INDEX].cell(),\n        chunk_pi_hash_preimages[MAX_AGG_SNARKS - 1][i + POST_STATE_ROOT_INDEX]\n            .cell(),\n    )?;\n    // 2.3 chunk[k-1].withdraw_root\n    ‚Ä¶\n    region.constrain_equal(\n        batch_pi_hash_preimage[i + WITHDRAW_ROOT_INDEX].cell(),\n        chunk_pi_hash_preimages[MAX_AGG_SNARKS - 1][i + WITHDRAW_ROOT_INDEX].cell(),\n    )?;\n}",
        "language": "rust",
        "description": "Figure 10.4: aggregator/src/core.rs#355‚Äì406"
      },
      {
        "type": "text",
        "text": "The cells in `potential_batch_data_hash_preimage` will not be constrained to be equal to any of the chunk `data_hash` fields, as shown in figure 10.5."
      },
      {
        "type": "code",
        "code": "for i in 0..MAX_AGG_SNARKS {\n    for j in 0..DIGEST_LEN {\n        ‚Ä¶\n        rlc_config.conditional_enforce_equal(\n            &mut region,\n            &chunk_pi_hash_preimages[i][j + CHUNK_DATA_HASH_INDEX],\n            &potential_batch_data_hash_preimage[i * DIGEST_LEN + j],\n            &chunk_is_valid_cells[i],\n            &mut offset,\n        )?;\n    }\n}",
        "language": "rust",
        "description": "Figure 10.5: aggregator/src/core.rs#642‚Äì664"
      },
      {
        "type": "text",
        "text": "`num_valid_snarks` will equal `0`, and the hash-selection flags will be `(1,0,0)`, as shown in figure 10.6."
      },
      {
        "type": "code",
        "code": "let flag1 = rlc_config.is_smaller_than(\n    &mut region,\n    &num_valid_snarks,\n    &five,\n    &mut offset,\n)?;\nlet not_flag1 = rlc_config.not(&mut region, &flag1, &mut offset)?;\nlet not_flag3 = rlc_config.is_smaller_than(\n    &mut region,\n    &num_valid_snarks,\n    &nine,\n    &mut offset,\n)?;\nlet flag3 = rlc_config.not(&mut region, &not_flag3, &mut offset)?;\nlet flag2 = rlc_config.mul(&mut region, &not_flag1, &not_flag3, &mut offset)?;",
        "language": "rust",
        "description": "Figure 10.6: aggregator/src/core.rs#524‚Äì538"
      },
      {
        "type": "text",
        "text": "The calculated input length will be `0`, and the length field of the first row of the `batch_data_hash` section will be `0`, as shown in figure 10.7."
      },
      {
        "type": "code",
        "code": "let data_hash_inputs_len =\n    rlc_config.mul(&mut region, &num_valid_snarks, &const32, &mut offset)?;\n‚Ä¶\nlet mut data_hash_inputs_len_rec = rlc_config.mul(\n    &mut region,\n    &hash_input_len_cells[MAX_AGG_SNARKS * 2 + 3],\n    &flag1,\n    &mut offset,\n)?;\ndata_hash_inputs_len_rec = rlc_config.mul_add(\n    &mut region,\n    &hash_input_len_cells[MAX_AGG_SNARKS * 2 + 4],\n    &flag2,\n    &data_hash_inputs_len_rec,\n    &mut offset,\n)?;\ndata_hash_inputs_len_rec = rlc_config.mul_add(\n    &mut region,\n    &hash_input_len_cells[MAX_AGG_SNARKS * 2 + 5],\n    &flag3,\n    &data_hash_inputs_len_rec,\n    &mut offset,\n)?;\n‚Ä¶\nregion.constrain_equal(\n    data_hash_inputs_len.cell(),\n    data_hash_inputs_len_rec.cell(),\n)?;",
        "language": "rust",
        "description": "Figure 10.7: aggregator/src/core.rs#744‚Äì804"
      },
      {
        "type": "text",
        "text": "Based on the flags and the calculated input length, the batch data hash will be the Keccak hash of an empty sequence, as determined by the constraints in figure 10.8."
      },
      {
        "type": "code",
        "code": "let rhs = rlc_config.mul(\n    &mut region,\n    &flag1,\n    &potential_batch_data_hash_digest[(3 - i) * 8 + j],\n    &mut offset,\n)?;\nlet rhs = rlc_config.mul_add(\n    &mut region,\n    &flag2,\n    &potential_batch_data_hash_digest[(3 - i) * 8 + j + 32],\n    &rhs,\n    &mut offset,\n)?;\nlet rhs = rlc_config.mul_add(\n    &mut region,\n    &flag3,\n    &potential_batch_data_hash_digest[(3 - i) * 8 + j + 64],\n    &rhs,\n    &mut offset,\n)?;\nregion.constrain_equal(\n    batch_pi_hash_preimage[i * 8 + j + CHUNK_DATA_HASH_INDEX].cell(),\n    rhs.cell(),\n)?;",
        "language": "rust",
        "description": "Figure 10.8: aggregator/src/core.rs#602‚Äì626"
      },
      {
        "type": "text",
        "text": "The last constraint that must be satisfied for attack 1 to succeed is the RLC calculation, shown in figure 10.9. In theory, the RLC should be equal to `0`, so the check should succeed by equaling the RLC of the first row. However, due to finding TOB-SCROLL3-11, the calculated RLC will equal the first byte of the `batch_data_hash` section, which is a padding byte equal to 1. This can be resolved by setting the second row of the `batch_data_hash` section, which is otherwise unused in this situation, to the one-byte sequence `[1]`."
      },
      {
        "type": "code",
        "code": "let rlc_cell = rlc_config.rlc_with_flag(\n    &mut region,\n    potential_batch_data_hash_preimage[..DIGEST_LEN * MAX_AGG_SNARKS].as_ref(),\n    &challenge_cell,\n    &flags,\n    &mut offset,\n)?;\n‚Ä¶\n// assertion\nlet t1 = rlc_config.sub(\n    &mut region,\n    &rlc_cell,\n    &data_rlc_cells[MAX_AGG_SNARKS * 2 + 3],\n    &mut offset,\n)?;\nlet t2 = rlc_config.sub(\n    &mut region,\n    &rlc_cell,\n    &data_rlc_cells[MAX_AGG_SNARKS * 2 + 4],\n    &mut offset,\n)?;\nlet t3 = rlc_config.sub(\n    &mut region,\n    &rlc_cell,\n    &data_rlc_cells[MAX_AGG_SNARKS * 2 + 5],\n    &mut offset,\n)?;\nlet t1t2 = rlc_config.mul(&mut region, &t1, &t2, &mut offset)?;\nlet t1t2t3 = rlc_config.mul(&mut region, &t1t2, &t3, &mut offset)?;\nrlc_config.enforce_zero(&mut region, &t1t2t3)?;",
        "language": "rust",
        "description": "Figure 10.9: aggregator/src/core.rs#817‚Äì866"
      },
      {
        "type": "text",
        "text": "Attack 2 must pass many of the same constraints, and proceeds as follows:"
      },
      {
        "type": "text",
        "text": "1. Set the batch to `[A,A,A,A,B,B,...,B]` and the validity flags to `[0,0,0,0,1,0,0,...,0]` (i.e., the first four chunks are padding chunks containing `A`, the fifth chunk is a valid chunk containing `B`, and the remaining chunks are padding chunks containing `B`)."
      },
      {
        "type": "text",
        "text": "2. Set the first row of the `batch_data_hash` section to `evil_data_hash[0..32]`. This will satisfy the constraints shown in figures 10.7 and 10.8 and will cause the batch data hash to equal `keccak(evil_data_hash)`, the result from this row."
      },
      {
        "type": "text",
        "text": "3. Set the second row of the `batch_data_hash` section to `B.data_hash[0..32]` to satisfy the requirements shown in figure 10.5. Set the `final` flag on this row to avoid interfering with the next step."
      },
      {
        "type": "text",
        "text": "4. Set the third row of the `batch_data_hash` to `[A.data_hash[0],B.data_hash[0],B.data_hash[1],...,B.data_hash[31]]` so that the `data_rlc` value in this row will satisfy the constraints in figure 10.9 by matching the incorrect calculation of `rlc_cell` due to finding TOB-SCROLL3-11."
      },
      {
        "type": "text",
        "text": "We believe that this attack can generalize further, but due to time constraints, we did not evaluate any other cases."
      },
      {
        "type": "text",
        "text": "If finding TOB-SCROLL3-11 is resolved, the attack is still possible: steps 3 and 4 must be modified so that the third row is all zeros and the `final` flag is not set in the second row."
      }
    ],
    "impact": "Alice sends a deposit to the Scroll zkEVM L2 contract, and the L1 message for that deposit is included in a chunk that is successfully committed but not yet finalized. Bob uses attack 2 to generate a proof for an incorrect state transition and uses that proof to finalize the chunk that Alice sent. The L1 messages that would be popped by that chunk are removed from the queue with no effect, and because the chunk has been finalized, it cannot be reverted, causing Alice's funds to be trapped in the Scroll L2 contract with no way of withdrawing them.",
    "recommendation": "Short term, add constraints so that `num_valid_snarks` must be nonzero and `chunk_is_valid_cells` must not have any valid cells after padding chunks. Long term, specify, review, and test all security-critical logic such as the aggregation padding validation as thoroughly as possible.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"RlcConfig::rlc_with_flag is incorrect",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Testing",
    "finding_id": "TOB-SCROLL3-11",
    "target_file": "aggregator/src/aggregation/rlc/gates.rs",
    "content": [
      {
        "type": "text",
        "text": "The `RlcConfig::rlc_with_flag` function combines a vector of field elements and a vector of flag values with a random challenge. The documentation comment on this function, shown in figure 11.1, suggests that the flag array should act like a mask on the vector; that is, entries in the vector with a flag of `0` should be set to `0`:"
      },
      {
        "type": "code",
        "code": "// Returns challenge^k * inputs[0] * flag[0] + ... + challenge * inputs[k-1] *\nflag[k-1]] +\n// inputs[k]* flag[k]",
        "language": "rust",
        "description": "Figure 11.1: aggregator/src/aggregation/rlc/gates.rs#342‚Äì343"
      },
      {
        "type": "text",
        "text": "The two test cases for this function, shown in figure 11.2, as well as its use in the aggregation circuit, suggest an alternate intended functionality where entries with a flag value equal to `0` are simply removed from the vector before the RLC occurs:"
      },
      {
        "type": "code",
        "code": "// unit test: rlc with flags\n{\n    let zero = config.load_private(&mut region, &Fr::zero(), &mut offset)?;\n    let one = config.not(&mut region, &zero, &mut offset)?;\n    let flag = [one.clone(), one.clone(), one.clone(), one.clone()];\n    let f6_rec =\n        config.rlc_with_flag(&mut region, &inputs, &f5, &flag, &mut offset)?;\n    region.constrain_equal(f6.cell(), f6_rec.cell())?;\n    let flag = [one.clone(), one.clone(), one, zero];\n    let res = rlc(&[self.f1, self.f2, self.f3], &self.f5);\n    let res = config.load_private(&mut region, &res, &mut offset)?;\n    let res_rec =\n        config.rlc_with_flag(&mut region, &inputs, &f5, &flag, &mut offset)?;\n    region.constrain_equal(res.cell(), res_rec.cell())?;\n}",
        "language": "rust",
        "description": "Figure 11.2: aggregator/src/tests/rlc/gates.rs#125‚Äì141"
      },
      {
        "type": "text",
        "text": "Regardless of whichever functionality is the intended one, `rlc_with_flag`, shown in figure 11.3, is incorrect:"
      },
      {
        "type": "code",
        "code": "pub(crate) fn rlc_with_flag(\n    &self,\n    region: &mut Region<Fr>,\n    inputs: &[AssignedCell<Fr, Fr>],\n    challenge: &AssignedCell<Fr, Fr>,\n    flags: &[AssignedCell<Fr, Fr>],\n    offset: &mut usize,\n) -> Result<AssignedCell<Fr, Fr>, Error> {\n    assert!(flags.len() == inputs.len());\n    let mut acc = inputs[0].clone();\n    for (input, flag) in inputs.iter().zip(flags.iter()).skip(1) {\n        let tmp = self.mul_add(region, &acc, challenge, input, offset)?;\n        acc = self.select(region, &tmp, &acc, flag, offset)?;\n    }\n    Ok(acc)\n}",
        "language": "rust",
        "description": "Figure 11.3: aggregator/src/aggregation/rlc/gates.rs#344‚Äì360"
      },
      {
        "type": "text",
        "text": "If the flags are supposed to act as a filter, only the handling of `flags[0]` needs to change (e.g., to the version shown in figure 11.4)."
      },
      {
        "type": "code",
        "code": "pub(crate) fn rlc_with_flag(\n    &self,\n    region: &mut Region<Fr>,\n    inputs: &[AssignedCell<Fr, Fr>],\n    challenge: &AssignedCell<Fr, Fr>,\n    flags: &[AssignedCell<Fr, Fr>],\n    offset: &mut usize,\n) -> Result<AssignedCell<Fr, Fr>, Error> {\n    assert!(flags.len() == inputs.len());\n    let mut acc = self.mul(region, &inputs[0], &flags[0], offset)?;\n    for (input, flag) in inputs.iter().zip(flags.iter()).skip(1) {\n        let tmp = self.mul_add(region, &acc, challenge, input, offset)?;\n        acc = self.select(region, &tmp, &acc, flag, offset)?;\n    }\n    Ok(acc)\n}",
        "language": "rust",
        "description": "Figure 11.4: A fix for `rlc_with_flag` if the flags should act like filters"
      },
      {
        "type": "text",
        "text": "If the behavior is supposed to match the documentation comment, the function should be rewritten to unconditionally multiply `acc` by `challenge` and to conditionally add `input`, as shown in figure 11.5."
      },
      {
        "type": "code",
        "code": "pub(crate) fn rlc_with_flag(\n    &self,\n    region: &mut Region<Fr>,\n    inputs: &[AssignedCell<Fr, Fr>],\n    challenge: &AssignedCell<Fr, Fr>,\n    flags: &[AssignedCell<Fr, Fr>],\n    offset: &mut usize,\n) -> Result<AssignedCell<Fr, Fr>, Error> {\n    assert!(flags.len() == inputs.len());\n    let mut acc = self.mul(region, &inputs[0], &flags[0], offset)?;\n    for (input, flag) in inputs.iter().zip(flags.iter()).skip(1) {\n        let tmp = self.mul(region, input, flag, offset)?;\n        acc = self.mul_add(region, &acc, challenge, &tmp, offset)?;\n    }\n    Ok(acc)\n}",
        "language": "rust",
        "description": "Figure 11.5: A fix for `rlc_with_flag` if the flags should act like masks"
      },
      {
        "type": "text",
        "text": "Because this function is used only in the `conditional_constraints` function, the impact of this issue is minimal, and all potential issues we found would also be fixed by addressing finding TOB-SCROLL3-10."
      }
    ],
    "impact": "",
    "recommendation": "Short term, determine the correct behavior of `rlc_with_flag` and update the implementation to reflect that behavior. Long term, test critical functions such as `rlc_with_flag` on as broad a set of inputs as possible with property-based testing frameworks like proptest.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"Accumulator representation assumes fixed-length field limbs",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Data Validation",
    "finding_id": "TOB-SCROLL3-12",
    "target_file": "aggregator/src/aggregation/circuit.rs, snark-verifier-sdk/src/aggregation.rs",
    "content": [
      {
        "type": "text",
        "text": "KZG accumulators are pairs of elliptic curve points and must be uniquely serialized when included in the public inputs when verifying SHPLONK proofs. This serialization is done by the `flatten_accumulator` function from the `snark-verifier-sdk` crate, as shown in figures 12.1 and 12.2."
      },
      {
        "type": "code",
        "code": "// extract the assigned values for\n// - instances which are the public inputs of each chunk (prefixed with 12\n// instances from previous accumulators)\n// - new accumulator to be verified on chain\n//\nlet (assigned_aggregation_instances, acc) = aggregate::<Kzg<Bn256, Bdfg21>>(\n    &self.svk,\n    &loader,\n    &self.snarks_with_padding,\n    self.as_proof(),\n);\n‚Ä¶\n// extract the following cells for later constraints\n// - the accumulators\n// - the public inputs from each snark\naccumulator_instances.extend(flatten_accumulator(acc).iter().copied());\n// the snark is not a fresh one, assigned_instances already contains an\n// accumulator so we want to skip the first 12 elements from the public input\nsnark_inputs.extend(\n    assigned_aggregation_instances\n        .iter()\n        .flat_map(|instance_column| instance_column.iter().skip(ACC_LEN)),\n);\nconfig.range().finalize(&mut loader.ctx_mut());\nloader.ctx_mut().print_stats(&[\"Range\"]);\nOk((accumulator_instances, snark_inputs))",
        "language": "rust",
        "description": "Figure 12.1: aggregator/src/aggregation/circuit.rs#226‚Äì258"
      },
      {
        "type": "code",
        "code": "pub fn flatten_accumulator<'a>(\n    accumulator: KzgAccumulator<G1Affine, Rc<Halo2Loader<'a>>>,\n) -> Vec<AssignedValue<Fr>> {\n    let KzgAccumulator { lhs, rhs } = accumulator;\n    let lhs = lhs.into_assigned();\n    let rhs = rhs.into_assigned();\n    lhs.x\n        .truncation\n        .limbs\n        .into_iter()\n        .chain(lhs.y.truncation.limbs.into_iter())\n        .chain(rhs.x.truncation.limbs.into_iter())\n        .chain(rhs.y.truncation.limbs.into_iter())\n        .collect()\n}",
        "language": "rust",
        "description": "Figure 12.2: snark-verifier-sdk/src/aggregation.rs#44‚Äì59"
      },
      {
        "type": "text",
        "text": "This function does not check or include the lengths of the `truncation` vectors in this serialization. This is not an active problem because, to our knowledge, the current finite field implementations in the `halo2-ecc` library guarantee that `truncation` vectors are always a fixed size. However, if `halo2-ecc` allows variable-length `truncation` vectors, it may be possible for two different accumulators to serialize to the same array. This should be documented as an assumption made about `snark-verifier-sdk` and `halo2-ecc`, and care should be taken when updating `halo2-ecc` or `snark-verifier-sdk` in case this behavior changes."
      }
    ],
    "impact": "",
    "recommendation": "Short term, document this requirement and consider adding assertions to `flatten_accumulator`. Long term, document all serialization formats used in the aggregator implementation and ensure that those formats fulfill any assumptions made about them.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"PlonkProof::read ignores extra entries in num_challenge",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Testing",
    "finding_id": "TOB-SCROLL3-13",
    "target_file": "snark-verifier/src/verifier/plonk.rs",
    "content": [
      {
        "type": "text",
        "text": "Due to the `PlonkProof::read` function's use of the `zip()` function shown in figure 13.1, it is possible for a single proof to be verified using two different `Protocol` values, where one has extra entries in the `num_challenge` field."
      },
      {
        "type": "code",
        "code": "let (witnesses, challenges) = {\n    let (witnesses, challenges): (Vec<_>, Vec<_>) = protocol\n        .num_witness\n        .iter()\n        .zip(protocol.num_challenge.iter())\n        .map(|(&n, &m)| {\n            (transcript.read_n_ec_points(n).unwrap(),\n            transcript.squeeze_n_challenges(m))\n        })\n        .unzip();\n    (\n        witnesses.into_iter().flatten().collect_vec(),\n        challenges.into_iter().flatten().collect_vec(),\n    )\n};",
        "language": "rust",
        "description": "Figure 13.1: snark-verifier/src/verifier/plonk.rs#155‚Äì169"
      },
      {
        "type": "text",
        "text": "This does not appear to be exploitable as is, but code calling the `PlonkProof::read` function should be careful not to rely on `Protocol` values to be unique."
      }
    ],
    "impact": "",
    "recommendation": "Short term, replace this `zip()` call with `zip_eq()` or document this behavior of `PlonkProof::read`. Long term, review all calls to `zip()` to ensure that the calling code behaves correctly on non-equal-length inputs.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title":"MAX_AGG_SNARKS values other than 10 may misbehave",
    "source":"Trail Of Bits",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Marc Ilunga and Joe Doyle"],
    "scope": [
      {
        "name": "mpt-circuit",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/tree/2163a9c436ed85363c954ecf7e6e1044a1b991dc",
        "commit_hash": "2163a9c436ed85363c954ecf7e6e1044a1b991dc"
      },
      {
        "name": "aggregator",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/e40ab9e8e78fd362c50fcd0277db79a1c9a98e60/aggregator",
        "commit_hash": "e40ab9e8e78fd362c50fcd0277db79a1c9a98e60"
      },
      {
        "name": "precompiles",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/tree/4a884959e143ab946fe231e96f847c008a46885a/zkevm-circuits",
        "commit_hash": "4a884959e143ab946fe231e96f847c008a46885a"
      },
      {
        "name": "snark-verifier",
        "description": "Type: Rust, halo2. Platform: Native ",
        "repository": "https://github.com/scroll-tech/snark-verifier/tree/bc1d39ae31f3fe520c51dd150f0fefaf9653c465",
        "commit_hash": "bc1d39ae31f3fe520c51dd150f0fefaf9653c465"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf",
    "severity": "informational",
    "difficulty": "N/A",
    "type": "Configuration",
    "finding_id": "TOB-SCROLL3-14",
    "target_file": "aggregator/src/constants.rs",
    "content": [
      {
        "type": "text",
        "text": "The aggregation circuit takes n SNARKs and aggregates them into a batch proof that proves their correctness. The value n is represented in the aggregation circuit by the constant `MAX_AGG_SNARKS`, which is currently set to `10`."
      },
      {
        "type": "code",
        "code": "/// Max number of snarks to be aggregated in a chunk.\n/// If the input size is less than this, dummy snarks\n/// will be padded.\n// TODO: update me(?)\npub const MAX_AGG_SNARKS: usize = 10;",
        "language": "rust",
        "description": "Figure 14.1: aggregator/src/constants.rs#56‚Äì60"
      },
      {
        "type": "text",
        "text": "The implementation of the aggregation circuit is strongly coupled with a `MAX_AGG_SNARKS` value of `10`. For instance, the layout of the `batch_data_hash` portion of the Keccak table expects to have exactly three rounds of the Keccak permutation. While this logic appears to work for the values `9`, `10`, `11`, and `12`, it is not obvious whether a value of `8` would cause problems. Consequently, future updates of `MAX_AGG_SNARKS` may require a non-trivial amount of the circuit to be rewritten."
      },
      {
        "type": "code",
        "code": "// #valid snarks | offset of data hash | flags\n// 1,2,3,4 | 0 | 1, 0, 0\n// 5,6,7,8 | 32 | 0, 1, 0\n// 9,10 | 64 | 0, 0, 1",
        "language": "rust",
        "description": "Figure 14.2: aggregator/src/core.rs#507‚Äì510"
      },
      {
        "type": "text",
        "text": "During this assessment, we treated `MAX_AGG_SNARKS` as a constant equal to `10`, and we did not thoroughly evaluate whether the implementation behaves correctly for values other than `10`. Care should be taken if `MAX_AGG_SNARKS` needs to be changed for any reason."
      }
    ],
    "impact": "",
    "recommendation": "Short term, document the assumptions that each component makes about `MAX_AGG_SNARKS`, and add assertions to enforce those assumptions during circuit construction. Long term, evaluate the behavior of the aggregator implementation for values of `MAX_AGG_SNARKS` other than `10`, and if other values need to be used, consider refactoring the code to use `MAX_AGG_SNARKS` in a generic fashion.",
    "auditFirm": "Trail of Bits",
    "publishDate": "10/06/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2023-09-scroll-zkEVM-wave3-securityreview.pdf"
    }
  },
  {
    "title": "Missing constraints in the copy circuit for MCOPY allow inserting illegitimate entries in the rw table",
    "source":"Zellic",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Malte Leip", "Mohit Sharma", "Zellic"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits",
        "commit_hash": "7f47a75e334754d4a73b95ea57450333ef992cc7"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "high",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL-3.1",
    "target_file": "Copy circuit",
    "content": [
      {
        "type": "text",
        "text": "This finding concerns constraints missing in the copy circuit regarding copy events associated to MCOPY instructions, which ultimately allow inserting illegitimate entries in the rw table. To describe this issue, we will start by describing the relevant aspects of the rw table and the intended way to ensure there are no illegitimate entries in the rw table, via the EVM circuit's counting of legitimate rw lookups. We will then discuss how, in the case of MCOPY instructions, the correctness of this count depends on the copy circuit correctly constraining a certain value. Finally, we can discuss how the copy circuit constrains that value, and we will see that it is insufficiently constrained."
      },
      {
        "type": "text",
        "text": "Purpose of the rw table and state circuit"
      },
      {
        "type": "text",
        "text": "The rw table is used to keep track of consistency of read and write operations that write to or read from, among other locations, storage, memory, and stack. This table is constrained by the state circuit, which ensures that, for example, reads that follow a write to some location will read the value written, that reads do not change the value, and so on. The state circuit does not however check that the entries are actually legitimate, so from the perspective of the state circuit only, any writes may appear in the table. Non-Start entries of the rw table are intended to have a unique ID, given by the counter, which is to increment on each read or write. Entries of the Start type, which are used as padding at the start of the table, have separate counters, counting up on each row. By looking up a Start entry with counter being 1 and one Start entry with counter being a high number, an upper bound on the number of non-Start entries in the rw table can be enforced."
      },
      {
        "type": "text",
        "text": "Ensuring that there are no malicious entries in the rw table"
      },
      {
        "type": "text",
        "text": "Other circuits make lookups to the rw table to perform reads and writes to storage, memory, and so on. In order to ensure that all non-Start entries in the rw table actually arise from such legitimate lookups, the EVM circuit keeps track of the current counter for the next entry of the rw table in state.rw_counter of each step. This is done by adding the number of rw lookups that were done when transitioning from one step to the next. At the very end, the rw_counter should reflect the total number of legitimate lookups done by the EVM circuit or by the copy circuit. The EVM circuit then, at the end of the block, looks up two entries in the rw table of the Start type to ensure that the remaining number of rows available (not of type Start) are at most as many as expected for legitimate lookups:"
      },
      {
        "type": "code",
        "code": "// 3. Verify rw_counter counts to the same number of meaningful rows in\n// rw_table to ensure there is no malicious insertion.\n// Verify that there are at most total_rws meaningful entries in the rw_table\ncb.rw_table_start_lookup(1.expr());\ncb.rw_table_start_lookup(max_rws.expr() - total_rws.expr());\n// Since every lookup done in the EVM circuit must succeed and uses\n// a unique rw_counter, we know that at least there are\n// total_rws meaningful entries in the rw_table.\n// We conclude that the number of meaningful entries in the rw_table\n// is total_rws.",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "This will ensure that there are indeed no malicious entries in the rw table as long as two assumptions hold:\n1. The count of legitimate rw lookups done is accurate.\n2. No two legitimate rw lookups are identical.\nIf either of these assumptions is violated, there will be additional rows available in the rw table in which an adversary may insert arbitrary malicious entries, such as writes to storage of their choosing."
      },
      {
        "type": "text",
        "text": "This finding concerns the possibility of violating both assumptions for MCOPY instructions due to missing constraints in the copy circuit."
      },
      {
        "type": "text",
        "text": "Constraints on rw_counter in the EVM circuit for MCOPY"
      },
      {
        "type": "text",
        "text": "In zkevm-circuits/src/evm_circuit/execution/mcopy.rs, the MCopyGadget::configure function adds the constraints for the MCOPY operation. Here is a relevant snippet:"
      },
      {
        "type": "code",
        "code": "// copy_rwc_inc used in copy circuit lookup.\nlet copy_rwc_inc = cb.query_cell();\ncb.condition(memory_src_address.has_length(), |cb| {\n    cb.copy_table_lookup(\n        cb.curr.state.call_id.expr(),\n        CopyDataType::Memory.expr(),\n        cb.curr.state.call_id.expr(),\n        CopyDataType::Memory.expr(),\n        // src_addr\n        memory_src_address.offset(),\n        // src_addr_end\n        memory_src_address.end_offset(),\n        // dest_addr\n        memory_dest_address.offset(),\n        memory_dest_address.length(),\n        // rlc_acc is 0 here.\n        0.expr(),\n        copy_rwc_inc.expr(),\n    );\n});\ncb.condition(not::expr(memory_src_address.has_length()), |cb| {\n    cb.require_zero(\n        \"if no bytes to copy, copy table rwc inc == 0\",\n        copy_rwc_inc.expr(),\n    );\n});",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "The crucial circuit variable to consider here is copy_rwc_inc, which is part of the arguments for copy_table_lookup, which will add the copy table lookup. Otherwise copy_rwc_inc is not constrained here as long as the length of the the copy operation is positive. In the case that the copy operation is for length zero, copy_rwc_inc is constrained to be zero as well. We will only consider the case for positive length in the following."
      },
      {
        "type": "text",
        "text": "The circuit builder's EVMConstraintBuilder::copy_table_lookup function is implemented in zkevm-circuits/src/evm_circuit/util/constraint_builder.rs as follows:"
      },
      {
        "type": "code",
        "code": "pub(crate) fn copy_table_lookup(\n    &mut self,\n    src_id: Expression<F>,\n    src_tag: Expression<F>,\n    dst_id: Expression<F>,\n    dst_tag: Expression<F>,\n    src_addr: Expression<F>,\n    src_addr_end: Expression<F>,\n    dst_addr: Expression<F>,\n    length: Expression<F>,\n    rlc_acc: Expression<F>,\n    rwc_inc: Expression<F>,\n) {\n    self.add_lookup(\n        \"copy lookup\",\n        Lookup::CopyTable {\n            is_first: 1.expr(), // is_first\n            src_id,\n            src_tag,\n            dst_id,\n            dst_tag,\n            src_addr,\n            src_addr_end,\n            dst_addr,\n            length,\n            rlc_acc,\n            rw_counter: self.curr.state.rw_counter.expr() +\n                self.rw_counter_offset(),\n            rwc_inc: rwc_inc.clone(),\n        },\n    );\n    self.rw_counter_offset = self.rw_counter_offset.clone() +\n        self.condition_expr() * rwc_inc;\n}",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "The copy_rwc_inc circuit variable from MCopyGadget::configure is used here as rwc_inc in the actual copy table lookup. It is also used to increase the read write counter offset accordingly. This means that if the operation currently executing actually is MCOPY (so the condition expression is 1), then the circuit builder's rw_counter_offset will increase by copy_rwc_inc."
      },
      {
        "type": "text",
        "text": "Back in MCopyGadget::configure in zkevm-circuits/src/evm_circuit/execution/mcopy.rs, the state transition is constrained by the following snippet:"
      },
      {
        "type": "code",
        "code": "let step_state_transition = StepStateTransition {\n    rw_counter: Transition::Delta(cb.rw_counter_offset()),\n    program_counter: Transition::Delta(1.expr()),\n    stack_pointer: Transition::Delta(3.expr()),\n    memory_word_size:\n        Transition::To(memory_expansion.next_memory_word_size()),\n    gas_left: Transition::Delta(-gas_cost),\n    ..Default::default()\n};\nlet same_context = SameContextGadget::construct(cb, opcode,\n    step_state_transition);",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "So the rw_counter will increase by cb.rw_counter_offset for the next execution step. In effect this means that rw_counter will increase by copy_rwc_inc, and the only other way this value is constrained in the evm circuit is via the copy table lookup."
      },
      {
        "type": "text",
        "text": "The copy circuit"
      },
      {
        "type": "text",
        "text": "In the copy circuit, the column containing copy_rwc_inc is called rwc_inc_left. The copy circuit is thus responsible to constrain the value of the rwc_inc_left column in the first row of the copy event to be the number of distinct rw table lookups that are performed by it."
      },
      {
        "type": "text",
        "text": "However, this is not the case. The top-level function introducing constraints for the copy circuit is CopyCircuitConfig::new in zkevm-circuits/src/copy_circuit.rs. The only place rwc_inc_left is used there is in a call to constrain_rw_counter in zkevm-circuits/src/copy_circuit/copy_gadgets.rs."
      },
      {
        "type": "text",
        "text": "That function introduces two different types of constraints, depending on whether or not the copy operation is a memory-to-memory copy."
      },
      {
        "type": "text",
        "text": "The case of copies that are not memory-to-memory"
      },
      {
        "type": "text",
        "text": "The copy table contains a row for each byte read or written during the copy operation. However, reads and writes actually happen per word, which is 32 bytes of length. Multiple bytes will thus be read or written from the same lookup in the rw table. Some relevant columns (or expressions formed from columns) for the discussion here are as follows:"
      },
      {
        "type": "text",
        "text": "is_row_end A boolean that is 1 if and only if this is the last byte (index 31) of the word that is being read or written.\nrw_counter The counter for the rw table lookup underlying the read or written byte of the current row.\nis_last A boolean that is true on the last row of of reading and writing a word. This will be enabled on the write row only."
      },
      {
        "type": "text",
        "text": "Copy events have rows with read and write rows alternating. For copies that are not memory-to-memory, the first row will read the first byte, the second row will write the first byte, and so on. There is some additional padding logic if the copy operation begins or ends in the middle of a word, but we will ignore this in our exposition here, as it is not relevant to the finding."
      },
      {
        "type": "text",
        "text": "We depict below an example for a copy operation that involves copying two words. The r/w column indicates whether the row is a read or write row, the word column indicates which word is being copied, and word_index is the index of the byte currently copied within the current word. In this example, we have not yet taken into account the constraints imposed by constrain_rw_counter."
      },
      {
        "type": "table",
        "headers": ["word", "word_index", "r/w", "is_row_end", "is_last", "rw_counter", "rwc_inc_left"],
        "rows": [
          ["0", "0", "r", "0", "0", "X", "Y"],
          ["0", "0", "w", "0", "0", "?", "?"],
          ["0", "1", "r", "0", "0", "?", "?"],
          ["0", "1", "w", "0", "0", "?", "?"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["0", "31", "r", "1", "0", "?", "?"],
          ["0", "31", "w", "1", "0", "?", "?"],
          ["1", "0", "r", "0", "0", "?", "?"],
          ["1", "0", "w", "0", "0", "?", "?"],
          ["1", "1", "r", "0", "0", "?", "?"],
          ["1", "1", "w", "0", "0", "?", "?"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["1", "31", "r", "1", "0", "?", "?"],
          ["1", "31", "w", "1", "1", "?", "?"]
        ]
      },
      {
        "type": "text",
        "text": "Here, we indicated the rw_counter and rwc_inc_left entries in the first row with X and Y to indicate that these are (as we have not yet imposed the constraints from constrain_rw_counter) arbitrary values ‚Äî but looked up by the EVM circuit. Entries marked with a question mark indicate that these are fully unconstrained cells (apart from rw_counter being used in lookups into the rw table)."
      },
      {
        "type": "text",
        "text": "We are now ready to consider the constraints imposed by constrain_rw_counter in the case where is_memory_copy is 0 (indicating we are not doing a memory-to-memory copy)."
      },
      {
        "type": "code",
        "code": "// Decrement rwc_inc_left for the next row, when an RWrwc_inc_left operation\n// happens.\nlet rwc_diff = is_rw_type.expr() * is_row_end.expr();\nlet new_value = meta.query_advice(rwc_inc_left, CURRENT) - rwc_diff;\nlet is_last = meta.query_advice(is_last_col, CURRENT);\n// ...\n// At the end, it must reach 0.\nlet update_or_finish = select::expr(\n    not::expr(is_last.clone()),\n    meta.query_advice(rwc_inc_left, NEXT_ROW),\n    0.expr(),\n);\n// ...\ncb.condition(not::expr(is_memory_copy.clone()), |cb| {\n    cb.require_equal(\n        \"rwc_inc_left[1] == rwc_inc_left[0] - rwc_diff, or 0 at the end\",\n        new_value.clone(),\n        update_or_finish,\n    );\n});\n// ...\n// Maintain rw_counter based on rwc_inc_left. Their sum remains constant in\n// all cases.\ncb.condition(not::expr(is_last.expr()), |cb| {\n    cb.require_equal(\n        \"rw_counter[0] + rwc_inc_left[0] == rw_counter[1] + rwc_inc_left[1]\",\n        meta.query_advice(rw_counter, CURRENT) +\n            meta.query_advice(rwc_inc_left, CURRENT),\n        meta.query_advice(rw_counter, NEXT_ROW) +\n            meta.query_advice(rwc_inc_left, NEXT_ROW),\n    );\n});",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "As is_rw_type will be 1, rwc_diff will be the same as is_row_end. Thus, new_value will be rwc_inc_left decremented by one at rows for the last byte of a word, otherwise it will be rwc_inc_left unchanged."
      },
      {
        "type": "text",
        "text": "There are then two cases to distinguish depending on whether is_last is 1 or 0. If it is 0, then update_or_finish will be rwc_inc_left of the next row. Thus, rwc_inc_left of the next row will be constrained to be the same as for the current row or decremented by 1 in the case of the last byte in a word. We can fill out some parts of the table with this information:"
      },
      {
        "type": "table",
        "headers": ["word", "word_index", "r/w", "is_row_end", "is_last", "rw_counter", "rwc_inc_left"],
        "rows": [
          ["0", "0", "r", "0", "0", "X", "Y"],
          ["0", "0", "w", "0", "0", "?", "Y"],
          ["0", "1", "r", "0", "0", "?", "Y"],
          ["0", "1", "w", "0", "0", "?", "Y"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["0", "31", "r", "1", "0", "?", "Y"],
          ["0", "31", "w", "1", "0", "?", "Y ‚àí 1"],
          ["1", "0", "r", "0", "0", "?", "Y ‚àí 2"],
          ["1", "0", "w", "0", "0", "?", "Y ‚àí 2"],
          ["1", "1", "r", "0", "0", "?", "Y ‚àí 2"],
          ["1", "1", "w", "0", "0", "?", "Y ‚àí 2"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["1", "31", "r", "1", "0", "?", "Y ‚àí 2"],
          ["1", "31", "w", "1", "1", "?", "Y ‚àí 3"]
        ]
      },
      {
        "type": "text",
        "text": "When we are on the very last row, where is_last = 1, we will have update_or_finish = 0 instead. As on that row is_row_end = 1 as well, we have new_value = rwc_inc_left - 1. Thus, the constraint new_value = update_or_finish enforces rwc_inc_left = 1. We can see that we already filled in that cell with Y ‚àí 3. This implies that we must have Y = 4 in this example:"
      },
      {
        "type": "table",
        "headers": ["word", "word_index", "r/w", "is_row_end", "is_last", "rw_counter", "rwc_inc_left"],
        "rows": [
          ["0", "0", "r", "0", "0", "X", "4"],
          ["0", "0", "w", "0", "0", "?", "4"],
          ["0", "1", "r", "0", "0", "?", "4"],
          ["0", "1", "w", "0", "0", "?", "4"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["0", "31", "r", "1", "0", "?", "4"],
          ["0", "31", "w", "1", "0", "?", "3"],
          ["1", "0", "r", "0", "0", "?", "2"],
          ["1", "0", "w", "0", "0", "?", "2"],
          ["1", "1", "r", "0", "0", "?", "2"],
          ["1", "1", "w", "0", "0", "?", "2"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["1", "31", "r", "1", "0", "?", "2"],
          ["1", "31", "w", "1", "1", "?", "1"]
        ]
      },
      {
        "type": "text",
        "text": "Finally, we consider the remaining constraint:"
      },
      {
        "type": "code",
        "code": "// Maintain rw_counter based on rwc_inc_left. Their sum remains constant in\n// all cases.\ncb.condition(not::expr(is_last.expr()), |cb| {\n    cb.require_equal(\n        \"rw_counter[0] + rwc_inc_left[0] == rw_counter[1] + rwc_inc_left[1]\",\n        meta.query_advice(rw_counter, CURRENT) +\n            meta.query_advice(rwc_inc_left, CURRENT),\n        meta.query_advice(rw_counter, NEXT_ROW) +\n            meta.query_advice(rwc_inc_left, NEXT_ROW),\n    );\n});",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "This ensures that the sum of rw_counter and rwc_inc_left cannot change within a copy event. As the sum in the first row of our example is X + 4, it must thus be in the remaining rows as well, so we can fill in the remainder of the table:"
      },
      {
        "type": "table",
        "headers": ["word", "word_index", "r/w", "is_row_end", "is_last", "rw_counter", "rwc_inc_left"],
        "rows": [
          ["0", "0", "r", "0", "0", "X", "4"],
          ["0", "0", "w", "0", "0", "X", "4"],
          ["0", "1", "r", "0", "0", "X", "4"],
          ["0", "1", "w", "0", "0", "X", "4"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["0", "31", "r", "1", "0", "X", "4"],
          ["0", "31", "w", "1", "0", "X + 1", "3"],
          ["1", "0", "r", "0", "0", "X + 2", "2"],
          ["1", "0", "w", "0", "0", "X + 2", "2"],
          ["1", "1", "r", "0", "0", "X + 2", "2"],
          ["1", "1", "w", "0", "0", "X + 2", "2"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["1", "31", "r", "1", "0", "X + 2", "2"],
          ["1", "31", "w", "1", "1", "X + 3", "1"]
        ]
      },
      {
        "type": "text",
        "text": "We would like to emphasize in particular here that the constraints enforce that the value of rwc_inc_left in the first row accurately reflect the number of words read or written. There is a single countdown for read and write rows together."
      },
      {
        "type": "text",
        "text": "The case of memory-to-memory copies"
      },
      {
        "type": "text",
        "text": "In the case of memory-to-memory copies, the table we obtained above would not be adequate. To see why that is, imagine that the copy operation is to copy words 0 and 1 to words 1 and 2. With the above table, the reads and writes happening would be as follows:"
      },
      {
        "type": "text",
        "text": "rw_counter\nX Read word 0\nX + 1 Write the word just read to word 1\nX + 2 Read word 1\nX + 3 Write the word just read to word 2"
      },
      {
        "type": "text",
        "text": "Note that with this access order, the first write will overwrite the original value at word 1. However, MCOPY should operate as if an intermediate buffer were used. Thus this access order will not work for MCOPY. It is instead necessary to first carry out all reads and only then perform the writes."
      },
      {
        "type": "text",
        "text": "The table that is intended in the case of our example above, but for MCOPY, would be as follows:"
      },
      {
        "type": "table",
        "headers": ["word", "word_index", "r/w", "is_row_end", "is_last", "rw_counter", "rwc_inc_left"],
        "rows": [
          ["0", "0", "r", "0", "0", "X", "4"],
          ["0", "0", "w", "0", "0", "X + 2", "2"],
          ["0", "1", "r", "0", "0", "X", "4"],
          ["0", "1", "w", "0", "0", "X + 2", "2"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["0", "31", "r", "1", "0", "X", "4"],
          ["0", "31", "w", "1", "0", "X + 2", "2"],
          ["1", "0", "r", "0", "0", "X + 1", "3"],
          ["1", "0", "w", "0", "0", "X + 3", "1"],
          ["1", "1", "r", "0", "0", "X + 1", "3"],
          ["1", "1", "w", "0", "0", "X + 3", "1"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["1", "31", "r", "1", "0", "X + 1", "3"],
          ["1", "31", "w", "1", "1", "X + 3", "1"]
        ]
      },
      {
        "type": "text",
        "text": "Let us now consider the constraints for this case:"
      },
      {
        "type": "code",
        "code": "// Decrement rwc_inc_left for the next row, when an RWrwc_inc_left operation\n// happens.\nlet rwc_diff = is_rw_type.expr() * is_row_end.expr();\nlet new_value = meta.query_advice(rwc_inc_left, CURRENT) - rwc_diff;\nlet is_last = meta.query_advice(is_last_col, CURRENT);\nlet is_last_two = meta.query_advice(is_last_col, NEXT_ROW);\n// ...\nlet update_or_finish_mcopy = meta.query_advice(rwc_inc_left, NEXT_STEP);\n// ...\n// handle is_memory_copy case: for all read steps, `rwc_inc_left` decrease by\n// 1 or 0,\n// for all write steps, `rwc_inc_left` decrease by 1 or 0 as well. this is not\n// the same as\n// normal case( `rwc_inc_left` decrease by 1 or 0 for consecutive read steps-->\n// write step\n// --> read step -->write step ...).\ncb.condition(\n    is_memory_copy * not::expr(is_last_two) * not::expr(is_last.clone()),\n    |cb| {\n        cb.require_equal(\n            \"rwc_inc_left[2] == rwc_inc_left[0] - rwc_diff, or 0 at the end\",\n            new_value,\n            update_or_finish_mcopy,\n        );\n    },\n);\n// Maintain rw_counter based on rwc_inc_left. Their sum remains constant in\n// all cases.\ncb.condition(not::expr(is_last.expr()), |cb| {\n    cb.require_equal(\n        \"rw_counter[0] + rwc_inc_left[0] == rw_counter[1] + rwc_inc_left[1]\",\n        meta.query_advice(rw_counter, CURRENT) +\n            meta.query_advice(rwc_inc_left, CURRENT),\n        meta.query_advice(rw_counter, NEXT_ROW) +\n            meta.query_advice(rwc_inc_left, NEXT_ROW),\n    );\n});",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "For rows except the last two, rwc_inc_left of two rows down (NEXT_STEP is 2, whereas NEXT_ROW is 1) is constrained to be new_value, which is the possibly decremented value of rwc_inc_left of the current row, as before. For the last two rows, there is no constraint imposed. We can fill in the table with this information again. The constraint that the sum of rw_counter and rwc_inc_left stays constant is the same as before, so we fill that in as well. Here we gave the value of rw_counter in the second row the value Z, which is arbitrary and not a constraint."
      },
      {
        "type": "table",
        "headers": ["word", "word_index", "r/w", "is_row_end", "is_last", "rw_counter", "rwc_inc_left"],
        "rows": [
          ["0", "0", "r", "0", "0", "X", "Y"],
          ["0", "0", "w", "0", "0", "X + Y ‚àí Z", "Z"],
          ["0", "1", "r", "0", "0", "X", "Y"],
          ["0", "1", "w", "0", "0", "X + Y ‚àí Z", "Z"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["0", "31", "r", "1", "0", "X", "Y"],
          ["0", "31", "w", "1", "0", "X + Y ‚àí Z", "Z"],
          ["1", "0", "r", "0", "0", "X + 1", "Y ‚àí 1"],
          ["1", "0", "w", "0", "0", "X + Y ‚àí Z + 1", "Z ‚àí 1"],
          ["1", "1", "r", "0", "0", "X + 1", "Y ‚àí 1"],
          ["1", "1", "w", "0", "0", "X + Y ‚àí Z + 1", "Z ‚àí 1"],
          ["...", "...", "...", "...", "...", "...", "..."],
          ["1", "31", "r", "1", "0", "X + 1", "Y ‚àí 1"],
          ["1", "31", "w", "1", "1", "X + Y ‚àí Z + 1", "Z ‚àí 1"]
       ]
      },
      {
      "type": "text",
      "text": "Implications for the EVM circuit"
      },
      {
      "type": "text",
      "text": "Using the notation from the above example, the EVM circuit fixes X, as this is the current rw_counter at the start of the copy operation. The value of Y is copy_rwc_inc, which is used in the state transition to obtain the correct rw_counter for the next operation and ultimately constrain the number of nonpadding entries available in the rw table."
      },
      {
      "type": "text",
      "text": "As we could see, this value can be chosen arbitrarily. By choosing a value that is larger than the actual number of read and write lookups done for the copy event, an adversary will cause an insufficient number of padding rows to be enforced in the rw table. They will then be able to insert additional rows between the reads and writes done by the copy event and the next legitimate reads and writes. This could include arbitrary writes to storage, including in other contexts."
      },
      {
      "type": "text",
      "text": "Another value that can be chosen arbitrarily, and independently of Y, is Z, the rw_counter of the first write performed by the copy event. This enables another variant with which an adversary could insert malicious entries into the rw table, even if Y is set to the intended value. They could repeat the same MCOPY operation twice, and in such a way that during writes done during the copy operation, the previous values are also the same. In that case, the writes looked up by the two MCOPYs will only differ in possibly the rw_counter. The adversary can then actually use the same rw_counter (by setting Z to the same value), looking up the same entry in the rw table twice. Thus, the number of distinct write lookups done by the two copy events will be half of the intended and counted number. This frees up rows in the rw table that can be used for malicious writes."
      },
      {
      "type": "text",
      "text": "Note that choosability of Z also means that writes can potentially happen in a different order than intended; for example by having two MCOPYs but the writes of the first are performed at the time of the second MCOPY and vice versa."
      },
      {
      "type": "code",
      "code": "// Adding additional rw operation\nstate.memory_write_word(exec_step, 0x20u64.into(), Word::from(4247u64))?;\n\nOk(CopyEvent {\n    src_type: CopyDataType::Memory,\n    // use call_id as src id for memory --> memory type.",
      "language": "rust",
      "description": "This change to gen_copy_event adds an additional memory write when generating the data for the MCOPY execution step."
      },
      {
      "type": "code",
      "code": "(self.is_source_rw() as u64 + self.is_destination_rw() as u64) *\n(self.full_length() / 32) + 1",
      "language": "rust",
      "description": "Change to CopyEvent::rw_counter_delta to increase the value of copy_rwc_inc by one."
      }
    ],
    "impact": "For transactions involving execution of MCOPY instructions of nonzero length, an adversary can insert arbitrary malicious writes to the rw table. The correct ordering of reads and writes is also not ensured for MCOPY. This could allow an attacker to make arbitrary writes to storage, including in other contexts.",
    "recommendation": "It should be ensured that the read and write rwc_inc_left countdowns match up and end with 1. Concretely, rwc_inc_left for the last read must be one bigger than rwc_inc_left for the first write, and rwc_inc_left for the last write must be 1.\n\nCurrently, there are essentially two constraints: rwc_inc_left[i+2] = rwc_inc_left - (1 if last byte of a word, else 0) and rw_counter[i+1] + rwc_inc_left[i+1] = rw_counter[i] + rwc_inc_left[i]. In this notation, rwc_inc_left[i] refers to the value of the rwc_inc_counter column in the i-th row of the copy event. The latter constraint can be rewritten and split up in three cases by plugging in the first one:\n\n1. For the first read and write, rw_counter[1] - rw_counter[0] = rwc_inc_left[0] - rwc_inc_left[1].\n2. When at the last byte of a word, rw_counter[i+2] = rw_counter[i] + 1.\n3. When not at the last byte of a word, rw_counter[i+2] = rw_counter[i].\n\nTo fix this issue, we suggest to add for the memory-to-memory case the constraints:\n\nA. Constrain rwc_inc_left[0] = 2 * rwc_inc_left[1]. In other words, conditional on being on the first row of a copy event that is memory-to-memory, constrain rwc_inc_left to be twice the value of rwc_inc_left in the next row.\n\nB. Constrain the last row's rwc_inc_left to be 1.\n\nThis ensures that the rw counter delta used back in the EVM circuit will be 2*n, and the actual reads and writes looked up by the copy circuit will use rw counters from rw_counter[0] through rw_counter[0] + 2*n - 1. There is thus no way anymore to look up a different write or to obtain an incorrect rw counter delta.",
    "auditFirm": "Zellic",
    "publishDate": "06/05/2024",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf"
    }
  },
  {
    "title": "Lack of constraints specific to transient storage and transaction receipts in the state circuit",
    "source":"Zellic",
    "date":"05-06-2024",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Malte Leip", "Mohit Sharma", "Zellic"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits",
        "commit_hash": "7f47a75e334754d4a73b95ea57450333ef992cc7"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL-3.2",
    "target_file": "State circuit",
    "content": [
      {
        "type": "text",
        "text": "In the state circuit, constraints specific to entries of the rw table with tag RwTableTag::AccountTransientStorage and RwTableTag::TxReceipt are missing. The two most important constraints missing due to this were the following:"
      },
      {
        "type": "text",
        "text": "1. Constraining the initial_value column to be zero in the case of RwTableTag::AccountTransientStorage"
      },
      {
        "type": "text",
        "text": "2. Constraining the state_root column not to have changed from the previous row in both cases"
      },
      {
        "type": "text",
        "text": "Even though constraints specific to AccountTransientStorage and TxReceipt are missing, the general constraints still apply. These include the following:"
      },
      {
        "type": "text",
        "text": "‚Ä¢ Constraining not_first_access"
      },
      {
        "type": "text",
        "text": "‚Ä¢ Constraining the value at a first access read to be initial_value"
      },
      {
        "type": "text",
        "text": "‚Ä¢ Constraining the value at other reads to be the value in the previous row"
      }
    ],
    "impact": "The missing constraint for initial_value to be zero for AccountTransientStorage means that an adversary may set any value. This will then result in the first read of that slot to read this value chosen by the adversary. In some applications, smart contracts may rely critically on transient storage slots being initialized as zero.\n\nLack of constraints for the state_root column implies an adversary can arbitrarily change the value of state_root in rows of type AccountTransientStorage or TxReceipt. Such a change could then correspond to updating any data stored in the state root, such as the storage of any smart contract address or any account state data.",
    "recommendation": "Implement the missing constraints for AccountTransientStorage and TxReceipt rows in the state circuit.",
    "auditFirm": "Zellic",
    "publishDate": "06/05/2024",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Source address is not constrained for ErrorOOGMemoryCopyGadget, allowing illegitimate reverts on MCOPY",
    "source":"Zellic",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Malte Leip", "Mohit Sharma", "Zellic"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits",
        "commit_hash": "7f47a75e334754d4a73b95ea57450333ef992cc7"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL-3.3",
    "target_file": "EVM circuit",
    "content": [
      {
        "type": "text",
        "text": "The EVM circuits ErrorOOGMemoryCopyGadget gadget is used to constrain reverts due to running out of gas on a memory copy operation. Let us consider this snippet from ErrorOOGMemoryCopyGadget::configure in zkevm-circuits/src/evm_circuit/execution/error_oog_memory_copy.rs:"
      },
      {
        "type": "code",
        "code": "let dst_memory_addr = MemoryExpandedAddressGadget::construct_self(cb);\n// src can also be possible to overflow for mcopy.\nlet src_memory_addr = MemoryExpandedAddressGadget::construct_self(cb);\ncb.stack_pop(dst_memory_addr.offset_rlc());\ncb.stack_pop(src_memory_addr.offset_rlc());\ncb.stack_pop(dst_memory_addr.length_rlc());\n// ...\ncb.require_equal(\n    // for mcopy, both dst_memory_addr and dst_memory_addr likely overflow.\n    \"Memory address is overflow or gas left is less than cost\",\n    or::expr([\n        dst_memory_addr.overflow(),\n        src_memory_addr.overflow(),\n        insufficient_gas.expr(),\n    ]),\n    1.expr(),\n);",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "The length for src_memory_addr is never constrained, so an attacker can set it to anything. The implementation for MemoryExpandedAddressGadget::overflow and the relevant constraints are as follows."
      },
      {
        "type": "code",
        "code": "/// Check if overflow.\npub(crate) fn overflow(&self) -> Expression<F> {\n    not::expr(self.within_range())\n}\n\n/// Check if within range.\npub(crate) fn within_range(&self) -> Expression<F> {\n    or::expr([\n        self.length_is_zero.expr(),\n        and::expr([\n            self.sum_lt_cap.expr(),\n            self.sum_within_u64.expr(),\n            not::expr(self.offset_length_sum.carry().as_ref().unwrap()),\n        ]),\n    ])\n}\n\nfn construct_self(cb: &mut EVMConstraintBuilder<F>) -> Self {\n    let offset = cb.query_word_rlc();\n    let length = cb.query_word_rlc();\n    let sum = cb.query_word_rlc();\n    let sum_lt_cap = LtGadget::construct(\n        cb,\n        from_bytes::expr(&sum.cells[..N_BYTES_U64]),\n        (MAX_EXPANDED_MEMORY_ADDRESS + 1).expr(),\n    );\n    let sum_overflow_hi = sum::expr(&sum.cells[N_BYTES_U64..]);\n    let sum_within_u64 = IsZeroGadget::construct(cb, sum_overflow_hi);\n    let length_is_zero = IsZeroGadget::construct(cb, sum::expr(&length.cells));\n    let offset_length_sum = AddWordsGadget::construct(cb, [offset, length], sum);\n    Self {\n        length_is_zero,\n        offset_length_sum,\n        sum_lt_cap,\n        sum_within_u64,\n    }\n}",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "When length can be set to an arbitrary value, an arbitrary value for sum = offset + length can be arranged, in particular a value larger than 2^64 ‚àí 1. Thus, it can be arranged that sum_within_u64 is false, making within_range return false, and thus making overflow return true."
      },
      {
        "type": "text",
        "text": "This means an attacker can prove an execution where arbitrary MCOPYs of their choice incorrectly fail due to being out of gas."
      }
    ],
    "impact": "An attacker can prove execution of a transaction where MCOPYs of their choice might incorrectly revert. There are some scenarios in which an attacker can profit from such reverts. One scenario would be in cases where a caller wishes to use a feature the callee may or may not support, so the caller wraps the call in a try block, falling back to some default behavior in the case that the call reverted. Some examples of this are here and here. Another scenario would be cases in which something negative for user A is caused by a transaction submitted by a third party B, for example in the case of liquidation of collaterals for a loan or opening of a commitment that shows that user A lost a bet.",
    "recommendation": "Constrain the length used in src_memory_addr to be equal to the length in dst_memory_addr (which is in turn already constrained to be the length popped from the stack).",
    "auditFirm": "Zellic",
    "publishDate": "06/05/2024",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Step transition for end_tx not constrained",
    "source":"Zellic",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Malte Leip", "Mohit Sharma", "Zellic"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits",
        "commit_hash": "7f47a75e334754d4a73b95ea57450333ef992cc7"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL-3.4",
    "target_file": "EVM circuit",
    "content": [
      {
        "type": "text",
        "text": "The EVM circuit, which constrains the actual execution of instruction in the EVM, is organized around steps. For each step, a StepState is stored, containing the following data:"
      },
      {
        "type": "code",
        "code": "pub(crate) struct StepState<F> {\n    /// The execution state selector for the step\n    pub(crate) execution_state: DynamicSelectorHalf<F>,\n    /// The Read/Write counter\n    pub(crate) rw_counter: Cell<F>,\n    /// The unique identifier of call in the whole proof, using the\n    /// `rw_counter` at the call step.\n    pub(crate) call_id: Cell<F>,\n    /// The transaction id of this transaction within the block.\n    pub(crate) tx_id: Cell<F>,\n    /// Whether the call is root call\n    pub(crate) is_root: Cell<F>,\n    /// Whether the call is a create call\n    pub(crate) is_create: Cell<F>,\n    /// The block number the state currently is in. This is particularly\n    /// important as multiple blocks can be assigned and proven in a single\n    /// circuit instance.\n    pub(crate) block_number: Cell<F>,\n    /// Denotes the hash of the bytecode for the current call.\n    /// In the case of a contract creation root call, this denotes the hash of\n    /// the tx calldata.\n    /// In the case of a contract creation internal call, this denotes the hash\n    /// of the chunk of bytes from caller's memory that represent the\n    /// contract init code.\n    pub(crate) code_hash: Cell<F>,\n    /// The program counter\n    pub(crate) program_counter: Cell<F>,\n    /// The stack pointer\n    pub(crate) stack_pointer: Cell<F>,\n    /// The amount of gas left\n    pub(crate) gas_left: Cell<F>,\n    /// Memory size in words (32 bytes)\n    pub(crate) memory_word_size: Cell<F>,\n    /// The counter for reversible writes\n    pub(crate) reversible_write_counter: Cell<F>,\n    /// The counter for log index\n    pub(crate) log_id: Cell<F>,\n    /// Whether this is end_tx. Boolean.\n    pub(crate) end_tx: Cell<F>,\n}",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "To constrain these values from one step to the next, the individual gadgets for EVM instructions (as well as, e.g., block end) create a StepStateTransition, which stores the transition for most of the StepState fields. A transition could be a change to an absolute value or a delta to be added to the previous value."
      },
      {
        "type": "code",
        "code": "pub(crate) struct StepStateTransition<F: Field> {\n    pub(crate) rw_counter: Transition<Expression<F>>,\n    pub(crate) call_id: Transition<Expression<F>>,\n    pub(crate) is_root: Transition<Expression<F>>,\n    pub(crate) is_create: Transition<Expression<F>>,\n    pub(crate) code_hash: Transition<Expression<F>>,\n    pub(crate) program_counter: Transition<Expression<F>>,\n    pub(crate) stack_pointer: Transition<Expression<F>>,\n    pub(crate) gas_left: Transition<Expression<F>>,\n    pub(crate) memory_word_size: Transition<Expression<F>>,\n    pub(crate) reversible_write_counter: Transition<Expression<F>>,\n    pub(crate) log_id: Transition<Expression<F>>,\n    pub(crate) end_tx: Transition<Expression<F>>,\n}\n\npub(crate) enum Transition<T> {\n    Same,\n    Delta(T),\n    To(T),\n    Any,\n}",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "They then call the require_step_state_transition function of the EVMConstraintBuilder, defined in zkevm-circuits/src/evm_circuit/util/constraint_builder.rs, which constrains the StepState to transition to the next step as given by the StepStateTransition:"
      },
      {
        "type": "code",
        "code": "pub(crate) fn require_step_state_transition(\n    &mut self,\n    step_state_transition: StepStateTransition<F>,\n) {\n    macro_rules! constrain {\n        ($name:tt) => {\n            match step_state_transition.$name {\n                Transition::Same => self.require_equal(\n                    concat!(\"State transition (same) constraint of \",\n                    stringify!($name)),\n                    self.next.state.$name.expr(),\n                    self.curr.state.$name.expr(),\n                ),\n                Transition::Delta(delta) => self.require_equal(\n                    concat!(\"State transition (delta) constraint of \",\n                    stringify!($name)),\n                    self.next.state.$name.expr(),\n                    self.curr.state.$name.expr() + delta,\n                ),\n                Transition::To(to) => self.require_equal(\n                    concat!(\"State transition (to) constraint of \",\n                    stringify!($name)),\n                    self.next.state.$name.expr(),\n                    to,\n                ),\n                _ => {}\n            }\n        };\n    }\n    constrain!(rw_counter);\n    constrain!(call_id);\n    constrain!(is_root);\n    constrain!(is_create);\n    constrain!(code_hash);\n    constrain!(program_counter);\n    constrain!(stack_pointer);\n    constrain!(gas_left);\n    constrain!(memory_word_size);\n    constrain!(reversible_write_counter);\n    constrain!(log_id);\n}",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "However, constrain!(end_tx) is missing here. There are thus no constraints added that constrain the next steps's end_tx value based on the transition and the current steps end_tx."
      }
    ],
    "impact": "Unless otherwise prevented, it appears likely that the missing constraints allow ending transactions at any step by setting the end_tx field to true and the execution_state dynamic selector to EndTx. In practice, this could be used for example by taking a flash loan and then ending the transaction without paying it back. In the other direction, it may be possible to continue execution past instructions such as STOP that should end the transaction.",
    "recommendation": "Add the constraints for end_tx:\n\n```rust\nconstrain!(rw_counter);\nconstrain!(call_id);\nconstrain!(is_root);\nconstrain!(is_create);\nconstrain!(code_hash);\nconstrain!(program_counter);\nconstrain!(stack_pointer);\nconstrain!(gas_left);\nconstrain!(memory_word_size);\nconstrain!(reversible_write_counter);\nconstrain!(log_id);\nconstrain!(end_tx);\n```",
    "auditFirm": "Zellic",
    "publishDate": "06/05/2024",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Completeness issue for some out-of-gas cases for MCOPY",
    "source":"Zellic",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Malte Leip", "Mohit Sharma", "Zellic"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits",
        "commit_hash": "7f47a75e334754d4a73b95ea57450333ef992cc7"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf",
    "severity": "Medium",
    "difficulty": "Medium",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL-3.5",
    "target_file": "EVM circuit",
    "content": [
      {
        "type": "text",
        "text": "Reverts due to being out of gas during memory copy operations are handled by the EVM circuit's ErrorOOGMemoryCopyGadget. However, the gas costs of MCOPY instructions are not calculated correctly."
      },
      {
        "type": "text",
        "text": "In the MCopyGadget, the gas cost is calculated as follows:"
      },
      {
        "type": "code",
        "code": "let memory_expansion = MemoryExpansionGadget::construct(\n    cb,\n    [\n        memory_src_address.end_offset(),\n        memory_dest_address.end_offset(),\n    ],\n);\n\nlet memory_copier_gas = MemoryCopierGasGadget::construct(\n    cb,\n    memory_src_address.length(),\n    memory_expansion.gas_cost(),\n);\n\n// dynamic cost + constant cost\nlet gas_cost = memory_copier_gas.gas_cost() +\n    OpcodeId::MCOPY.constant_gas_cost().expr();",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "The above gas-cost calculation corresponds to the Ethereum specification. However, in the ErrorOOGMemoryCopyGadget, we have this:"
      },
      {
        "type": "code",
        "code": "let memory_expansion = MemoryExpansionGadget::construct(cb, [dst_memory_addr.end_offset()]);\nlet memory_copier_gas = MemoryCopierGasGadget::construct(\n    cb,\n    dst_memory_addr.length(),\n    memory_expansion.gas_cost(),\n);\n\nlet constant_gas_cost = select::expr(\n    is_extcodecopy.expr(),\n    // According to EIP-2929, EXTCODECOPY constant gas cost is different for cold and warm\n    // accounts.\n    select::expr(\n        is_warm.expr(),\n        GasCost::WARM_ACCESS.expr(),\n        GasCost::COLD_ACCOUNT_ACCESS.expr(),\n    ),\n    // Constant gas cost is same for CALLDATACOPY, CODECOPY and RETURNDATACOPY.\n    OpcodeId::CALLDATACOPY.constant_gas_cost().expr(),\n);\n\nlet insufficient_gas = LtGadget::construct(\n    cb,\n    cb.curr.state.gas_left.expr(),\n    constant_gas_cost + memory_copier_gas.gas_cost(),\n);\n\ncb.require_equal(\n    // for mcopy, both dst_memory_addr and dst_memory_addr likely overflow.\n    \"Memory address is overflow or gas left is less than cost\",\n    or::expr([\n        dst_memory_addr.overflow(),\n        src_memory_addr.overflow(),\n        insufficient_gas.expr(),\n    ]),\n    1.expr(),\n);",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "Note that memory expansion only takes into account the destination, not the source. According to the Ethereum specification, not only writes but also reads cause memory expansion. An MCOPY operation of nonzero length from a very high memory address to a low memory address will thus cause memory expansion, causing an out-of-gas error (as long as the source address was high enough). However, the ErrorOOGMemoryCopyGadget will not consider this memory expansion and thereby calculate a too small memory_copier_gas.gas_cost(), which then makes insufficient_gas false, making it impossible to satisfy the constraint at the end of the snippet above, unless the addresses are so large to also overflow."
      },
      {
        "type": "text",
        "text": "We confirmed this issue with the following test:"
      },
      {
        "type": "code",
        "code": "#[test]\nfn zellic_mcopy_out_of_gas() {\n    let src_offset = Word::from(0x1000000);\n    let dest_offset = Word::from(0x0);\n    let length = Word::from(0x20);\n    let mut code = Bytecode::default();\n    code.append(&bytecode! {\n        PUSH32(length)\n        PUSH32(src_offset)\n        PUSH32(dest_offset)\n        MCOPY\n        STOP\n    });\n    let ctx = TestContext::<3, 1>::new(\n        None,\n        |accs| {\n            accs[0]\n            .address(address!(\"0x000000000000000000000000000000000000cafe\"))\n            .code(code);\n            accs[1]\n            .address(address!(\"0x0000000000000000000000000000000000000010\"))\n            .balance(Word::from(1u64 << 20));\n        },\n        |mut txs, accs| {\n            txs[0]\n            .to(accs[0].address)\n            .from(accs[1].address)\n            .gas(1_000_000.into());\n        },\n        |block, _tx| block.number(0x1111111),\n    )\n    .unwrap();\n\n    CircuitTestBuilder::new_from_test_ctx(ctx)\n    .params(CircuitsParams {\n        max_copy_rows: 1750,\n        ..Default::default()\n    })\n    .run();\n}",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "As expected, trying to run this test fails because of the Memory address is overflow or gas left is less than cost constraint:"
      },
      {
        "type": "code",
        "code": "[2024-05-27T20:49:00Z INFO halo2_proofs::dev] MockProver synthesize took 245.328931ms\n[2024-05-27T20:49:00Z DEBUG halo2_proofs::dev] regions.len() = 18\nthread 'evm_circuit::execution::mcopy::test::zellic_mcopy_out_of_gas' panicked at zkevm-circuits/src/test_util.rs:99:17:\nassertion `left == right` failed\nleft: Err([ConstraintCaseDebug {\n    constraint: Constraint {\n        gate: Gate {\n            index: 381,\n            name: \"ErrorOutOfGasMemoryCopy\",\n        },\n        index: 51,\n        name: \"ErrorOutOfGasMemoryCopy: Memory address is overflow or gas left is less than cost\",\n    },\n    location: InRegion {\n        region: Region 15 ('Execution step region1_0'),\n        offset: 22,\n    },\n    cell_values: [\n        (\n            DebugVirtualCell {\n                name: \"\",\n                column: DebugColumn {\n                    column_type: Advice,\n                    index: 71,\n                    annotation: \"EVM_q_step\",\n                },\n                rotation: 0,\n            },\n            \"1\",\n        ),\n        (\n            DebugVirtualCell {\n                name: \"\",\n                column: DebugColumn {\n                    column_type: Fixed,\n                    index: 20,\n                    annotation: \"\",\n                },\n                rotation: 0,\n            },\n            \"1\",\n        ),\n    ],\n}])\nright: Ok(())",
        "language": "rust"
      }
    ],
    "impact": "It will not be possible to prove blocks in which an MCOPY reverts due to an out of gas error that was solely caused by memory expansion caused by the reads from the source. While it appears unlikely that such reverts appear in benign transactions, it cannot be ruled out that such a completeness issue could be used as a denial-of-service vector.",
    "recommendation": "In the MCOPY case, make the calculation of memory_expansion in ErrorOOGMemoryCopyGadget::configure correspond to the calculation done in MCopyGadget::configure by extending the list passed as the addresses argument to MemoryExpansionGadget::construct with src_memory_addr.end_offset().",
    "auditFirm": "Zellic",
    "publishDate": "06/05/2024",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Incorrect gas-cost calculation for MCOPY out-of-gas test cases",
    "source":"Zellic",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Malte Leip", "Mohit Sharma", "Zellic"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits",
        "commit_hash": "7f47a75e334754d4a73b95ea57450333ef992cc7"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL-3.6",
    "target_file": "EVM circuit tests",
    "content": [
      {
        "type": "text",
        "text": "In zkevm-circuits/src/evm_circuit/execution/error_oog_memory_copy.rs, the tests::TestingData::new_for_mcopy function is used to generate test cases for MCOPY, generating some bytecode to perform an MCOPY and calculating the gas costs."
      },
      {
        "type": "code",
        "code": "pub fn new_for_mcopy(\n    src_offset: u64,\n    dst_offset: u64,\n    copy_size: u64,\n    gas_cost: Option<u64>,\n) -> Self {\n    let bytecode = bytecode! {\n        PUSH32(copy_size)\n        PUSH32(src_offset)\n        PUSH32(dst_offset)\n        MCOPY\n    };\n    let gas_cost = gas_cost.unwrap_or_else(|| {\n        let cur_memory_word_size = (src_offset + 31) / 32;\n        let memory_word_size = (dst_offset + copy_size + 31) / 32;\n        OpcodeId::PUSH32.constant_gas_cost().0 * 3\n        + memory_copier_gas_cost(\n            cur_memory_word_size,\n            memory_word_size,\n            copy_size,\n            GasCost::COPY.as_u64(),\n        )\n    });\n    Self { bytecode, gas_cost }\n}",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "The function memory_copier_gas_cost expects as arguments the current memory size in words, the memory size in words after expansion, the number of bytes to copy, and the amount of gas used per word copied. The first two arguments are incorrect, however."
      }
    ],
    "impact": "Test cases using this function can behave in unintended ways (for example, panic) in some instances due to the incorrect gas calculation.",
    "recommendation": "For the shown bytecode, no writes to memory have been performed before MCOPY, so the current memory size should be zero words. The new memory size will then be the maximum of (src_offset + copy_size + 31) / 32 and (dst_offset + copy_size + 31) / 32 if copy_size is nonzero and zero if copy_size is zero.",
    "auditFirm": "Zellic",
    "publishDate": "06/05/2024",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Improvements possible for testing out-of-gas on MCOPY",
    "source":"Zellic",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Malte Leip", "Mohit Sharma", "Zellic"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits",
        "commit_hash": "7f47a75e334754d4a73b95ea57450333ef992cc7"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Code Maturity",
    "finding_id": "TOB-SCROLL-3.7",
    "target_file": "EVM circuit",
    "content": [
      {
        "type": "text",
        "text": "The EVM circuit has some tests to test out-of-gas errors being handled by the ErrorOOGMemoryCopyGadget on MCOPY execution, given by the following test function:"
      },
      {
        "type": "code",
        "code": "#[test]\nfn test_oog_memory_copy_for_mcopy() {\n    for (src_offset, dest_offset, copy_size) in TESTING_MCOPY_PARIS {\n        let testing_data =\n            TestingData::new_for_mcopy(*src_offset, *dest_offset, *copy_size, None);\n        test_root(&testing_data);\n        test_internal(&testing_data);\n    }\n}",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "This function first uses TestingData::new_for_mcopy to obtain a TestingData struct, containing bytecode executing an MCOPY instruction as well as the calculated gas cost. Then test_root and test_internal are called, which perform the actual test. In the former case, the bytecode including the MCOPY will be executed directly (at the top level of the transaction), and in the latter case, it will be executed one level lower, with a wrapper contract calling the bytecode to be tested. In both cases, the amount of gas is adjusted so that it should be just one gas too little to execute the MCOPY instruction:"
      },
      {
        "type": "code",
        "code": "fn test_root(testing_data: &TestingData) {\n    let gas_cost = GasCost::TX\n        .0\n        // Decrease expected gas cost (by 1) to trigger out of gas error.\n        .checked_add(testing_data.gas_cost - 1)\n        .unwrap_or(MOCK_BLOCK_GAS_LIMIT);\n    let gas_cost = if gas_cost > MOCK_BLOCK_GAS_LIMIT {\n        MOCK_BLOCK_GAS_LIMIT\n    } else {\n        gas_cost\n    };\n    let ctx = TestContext::<2, 1>::new(\n        None,\n        account_0_code_account_1_no_code(testing_data.bytecode.clone()),\n        |mut txs, accs| {\n            txs[0]\n                .from(accs[1].address)\n                .to(accs[0].address)\n                .gas(gas_cost.into());\n        },\n        |block, _tx| block.number(0xcafe_u64),\n    )\n    .unwrap();\n\n    CircuitTestBuilder::new_from_test_ctx(ctx)\n        .params(CircuitsParams {\n            max_copy_rows: 1750,\n            ..Default::default()\n        })\n        .run();\n}\n\nfn test_internal(testing_data: &TestingData) {\n    // ...\n    // Code A calls code B.\n    let code_a = bytecode! {\n        // populate memory in A's context.\n        PUSH8(U256::from_big_endian(&rand_bytes(8)))\n        PUSH1(0x00) // offset\n        MSTORE\n        // call ADDR_B.\n        PUSH1(0x00) // retLength\n        PUSH1(0x00) // retOffset\n        PUSH32(0x00) // argsLength\n        PUSH32(0x20) // argsOffset\n        PUSH1(0x00) // value\n        PUSH32(addr_b.to_word()) // addr\n        // Decrease expected gas cost (by 1) to trigger out of gas error.\n        PUSH32(gas_cost_b - 1) // gas\n        CALL\n        STOP\n    };\n    // ...\n}",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "If we run this test with RUST_BACKTRACE=1 RUST_LOG=trace cargo test test_oog_memory_copy_for_mcopy -- --nocapture, we can also see in the debug output that an out-of-memory error happens, as seen here for the very last test case:"
      },
      {
        "type": "code",
        "code": "[2024-06-04T18:40:55Z TRACE zkevm_circuits::evm_circuit::execution]\nassign_exec_step offset: 48 state ErrorOutOfGasMemoryCopy step: ExecStep {\n    call_index: 1, rw_indices: [(Stack, 22), (Stack, 23), (Stack, 24),\n    (CallContext, 49), (CallContext, 50), (CallContext, 51), (CallContext, 52),\n    (CallContext, 53), (CallContext, 54), (CallContext, 55), (CallContext, 56),\n    (CallContext, 57), (CallContext, 58), (CallContext, 59), (CallContext, 60),\n    (CallContext, 61), (CallContext, 62)], copy_rw_counter_delta: 0,\n    execution_state: ErrorOutOfGasMemoryCopy, rw_counter: 95, program_counter:\n    99, stack_pointer: 1021, gas_left: 14, gas_cost: 42, memory_size: 0,\n    reversible_write_counter: 0, reversible_write_counter_delta: 0, log_id:\n    0, opcode: Some(MCOPY), block_num: 0, aux_data: None } call: Call { id:\n    50, is_root: false, is_create: false, code_hash:\n    69088479414407603174779605424463024523545942567839557216382057906686480814179,\n    rw_counter_end_of_reversion: 111, caller_id: 1, depth: 2, caller_address:\n    0x000000000000000000000000000000000cafe111, callee_address:\n    0x000000000000000000000000000000000cafe222, code_address:\n    Some(0x000000000000000000000000000000000cafe222), call_data_offset: 0,\n    call_data_length: 0, return_data_offset: 0, return_data_length: 0,\n    last_callee_id: 0, last_callee_return_data_offset: 0,\n    last_callee_return_data_length: 0, value: 0, is_success: false,\n    is_persistent: false, is_static: false }\n[2024-06-04T18:40:55Z DEBUG\nzkevm_circuits::evm_circuit::execution::error_oog_memory_copy]\nErrorOutOfGasMemoryCopy: opcode = MCOPY, gas_left = 14, gas_cost = 42",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "However, the way these tests are run does not check that an out-of-gas error actually happens on the MCOPY."
      },
      {
        "type": "text",
        "text": "We verified this by changing the amount of gas available to be sufficient:"
      },
      {
        "type": "code",
        "code": "fn test_root(testing_data: &TestingData) {\n    let gas_cost = GasCost::TX\n        .0\n        // Decrease expected gas cost (by 1) to trigger out of gas error.\n        .checked_add(testing_data.gas_cost - 1)\n        .checked_add(testing_data.gas_cost + 100000)\n        .unwrap_or(MOCK_BLOCK_GAS_LIMIT);\n    let gas_cost = if gas_cost > MOCK_BLOCK_GAS_LIMIT {\n        MOCK_BLOCK_GAS_LIMIT\n    } else {\n        gas_cost\n    };\n    // ...\n}\n\nfn test_internal(testing_data: &TestingData) {\n    // ...\n    // Code A calls code B.\n    let code_a = bytecode! {\n        // populate memory in A's context.\n        PUSH8(U256::from_big_endian(&rand_bytes(8)))\n        PUSH1(0x00) // offset\n        MSTORE\n        // call ADDR_B.\n        PUSH1(0x00) // retLength\n        PUSH1(0x00) // retOffset\n        PUSH32(0x00) // argsLength\n        PUSH32(0x20) // argsOffset\n        PUSH1(0x00) // value\n        PUSH32(addr_b.to_word()) // addr\n        // Decrease expected gas cost (by 1) to trigger out of gas error.\n        PUSH32(gas_cost_b - 1) // gas\n        PUSH32(gas_cost_b + 100000) // gas\n        CALL\n        STOP\n    };\n    // ...\n}",
        "language": "rust"
      },
      {
        "type": "text",
        "text": "The tests still pass. However, no out-of-gas error occurs:"
      },
      {
        "type": "code",
        "code": "[2024-06-04T18:46:28Z TRACE zkevm_circuits::evm_circuit::execution]\nassign_exec_step offset: 48 state MCOPY step: ExecStep { call_index: 1,\nrw_indices: [(Stack, 22), (Stack, 23), (Stack, 24), (Memory, 2), (Memory,\n3), (Memory, 4), (Memory, 5), (Memory, 6), (Memory, 7), (Memory, 8),\n(Memory, 9)], copy_rw_counter_delta: 8, execution_state: MCOPY,\nrw_counter: 95, program_counter: 99, stack_pointer: 1021, gas_left:\n100015, gas_cost: 42, memory_size: 0, reversible_write_counter: 0,\nreversible_write_counter_delta: 0, log_id: 0, opcode: Some(MCOPY),\nblock_num: 0, aux_data: None } call: Call { id: 50, is_root: false,\nis_create: false, code_hash:\n69088479414407603174779605424463024523545942567839557216382057906686480814179,\nrw_counter_end_of_reversion: 0, caller_id: 1, depth: 2, caller_address:\n0x000000000000000000000000000000000cafe111, callee_address:\n0x000000000000000000000000000000000cafe222, code_address:\nSome(0x000000000000000000000000000000000cafe222), call_data_offset: 0,\ncall_data_length: 0, return_data_offset: 0, return_data_length: 0,\nlast_callee_id: 0, last_callee_return_data_offset: 0,\nlast_callee_return_data_length: 0, value: 0, is_success: true,\nis_persistent: true, is_static: false }\n[2024-06-04T18:46:28Z TRACE zkevm_circuits::evm_circuit::execution]\nassign_exec_step offset: 50 state STOP step: ExecStep { call_index: 1,\nrw_indices: [(CallContext, 49), (CallContext, 50), (CallContext, 51),\n(CallContext, 52), (CallContext, 53), (CallContext, 54), (CallContext, 55),\n(CallContext, 56), (CallContext, 57), (CallContext, 58), (CallContext, 59),\n(CallContext, 60), (CallContext, 61)], copy_rw_counter_delta: 0,\nexecution_state: STOP, rw_counter: 106, program_counter: 100,\nstack_pointer: 1024, gas_left: 99973, gas_cost: 0, memory_size: 288,\nreversible_write_counter: 0, reversible_write_counter_delta: 0, log_id:\n0, opcode: Some(STOP), block_num: 0, aux_data: None } call: Call { id:\n50, is_root: false, is_create: false, code_hash:\n69088479414407603174779605424463024523545942567839557216382057906686480814179,\nrw_counter_end_of_reversion: 0, caller_id: 1, depth: 2, caller_address:\n0x000000000000000000000000000000000cafe111, callee_address:\n0x000000000000000000000000000000000cafe222, code_address:\nSome(0x000000000000000000000000000000000cafe222), call_data_offset: 0,\ncall_data_length: 0, return_data_offset: 0, return_data_length: 0,\nlast_callee_id: 0, last_callee_return_data_offset: 0,\nlast_callee_return_data_length: 0, value: 0, is_success: true,\nis_persistent: true, is_static: false }",
        "language": "rust"
      }
    ],
    "impact": "Should the gas-cost calculation done by TestingData::new_for_mcopy be correct, these tests will test that the assignments to the ErrorOOGMemoryCopyGadget satisfy the constraints. However, should TestingData::new_for_mcopy return an incorrect gas cost that is too high, then these tests will not actually use the ErrorOOGMemoryCopyGadget. Those constraints will thus not be tested. Furthermore, the current tests do not ensure that the gas costs calculated inside the circuit match those calculated by TestingData::new_for_mcopy.\n\nNote that Finding 3.6. precisely discusses a bug in the gas-cost calculation by TestingData::new_for_mcopy.",
    "recommendation": "We recommend to enhance the testing code in the following way. Firstly, the bytecode is run twice. Once with available gas set to testing_data.gas_cost - 1 and once with testing_data.gas_cost. Secondly, the testing code checks whether the test actually did reach an out-of-gas error on the MCOPY instruction. The test should then only succeed if all of the following are true:\n1. Both runs succeeded, as in the constraints were satisfied.\n2. The first run reached an out-of-gas error on the MCOPY instruction.\n3. The second run did not reach an out-of-gas error on the MCOPY instruction.\n\nThis will ensure that the gas-cost calculation done by TestingData::new_for_mcopy matches the calculation done in circuit in the cases tested and that the ErrorOOGMemoryCopyGadget is indeed tested.",
    "auditFirm": "Zellic",
    "publishDate": "06/05/2024",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/2024-06-%20Scroll%20zkEVM%20-%20Zellic%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Poseidon Hash's outputs are taken from capacity",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Cryptography",
    "finding_id": "TOB-SCROLL-1.1",
    "target_file": "Poseidon Circuit, src/hash.rs",
    "content": [
      {
        "type": "text",
        "text": "Sponge-based hash functions are based on (disregarding padding for brevity)"
      },
      {
        "type": "text",
        "text": "‚Ä¢ A state of t = r + c field elements"
      },
      {
        "type": "text",
        "text": "‚Ä¢ A permutation œÄ on F^t_p"
      },
      {
        "type": "text",
        "text": "To hash the input, the state is initialized to zero and the input is first divided into chunks of r elements. Then the inputs are repeatedly fed into the first r elements of the state, then a permutation is applied. This continues until the input is fully incorporated."
      },
      {
        "type": "text",
        "text": "Then, until the output is fully retrieved, the first r elements of the state are taken out, applying the permutation if the output is not full yet. The"
      },
      {
        "type": "text",
        "text": "However, in this implementation of Poseidon, which uses t = 3, r = 2, c = 1 with the output being a single field element, takes the said output from the capacity, i.e. the last c = 1 element, rather than from the rate, i.e. the first r elements."
      }
    ],
    "impact": "The construction of the hash does not match the definition of the sponge-based hash construction. Therefore, the implemented Poseidon hash function may not directly benefit from the previous cryptanalysis of Poseidon and other sponge-based hash functions.",
    "recommendation": "More research on the security of the Poseidon hash when the outputs are taken from the capacity, as well as research on how other projects have implemented the Poseidon hash should be conducted. We note that the permutation used for the sponge is up to specification.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"mpt_only being true leads to overconstrained circuits",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf",
    "severity": "High",
    "difficulty": "Low",
    "type": "Overconstrained Circuits",
    "finding_id": "TOB-SCROLL-1.2",
    "target_file": "Poseidon Circuit, src/hash.rs",
    "content": [
      {
        "type": "text",
        "text": "The Poseidon table supports two modes of hashing - a MPT mode for hashing two field elements, and a Variable Length mode for hashing arbitrary length inputs. The SpongeChip gets mpt_only as an struct element, which denotes whether the chip will be purely used for MPT purposes."
      },
      {
        "type": "text",
        "text": "Depending on whether mpt_only is true, the custom rows padded at the beginning of the table changes. If it's true, there is only one custom row filled with zeroes. If not, there are two rows, with one additional row representing a hash of an empty message."
      },
      {
        "type": "text",
        "text": "However, due to incorrect ordering of logic, the custom gate is enabled in not only offset 0, but also offset 1."
      },
      {
        "type": "code",
        "code": "config.s_custom.enable(region, 1)?;\nif self.mpt_only {\n    return Ok(1);\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "This means that the selector is incorrectly enabled on offset 1."
      },
      {
        "type": "text",
        "text": "The fact that a certain row is a custom row is represented with a selector, and it is constrained that a custom row should have 0 as the hash inputs and control value."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"custom row\", |meta| {\n    let s_enable = meta.query_selector(s_custom);\n    vec![\n        s_enable.clone() * meta.query_advice(hash_inp[0], Rotation::cur()),\n        s_enable.clone() * meta.query_advice(hash_inp[1], Rotation::cur()),\n        s_enable * meta.query_advice(control, Rotation::cur()),\n    ]\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In the case where mpt_only is true, the values of hash_inp[0], hash_inp[1] in offset 1 are the first two field elements that are used for hashing. Since these two values are overconstrained to be equal to 0, any hashing attempt with the two input values not equaling 0 will fail the ZKP verification. However, we did not find an instance where mpt_only is true in our current audit scope."
      },
      {
        "type": "text",
        "text": "A proof of concept can be done by using the tests in hash.rs, but using the chip construction with mpt_only set to true."
      }
    ],
    "impact": "Any hashing attempt with the two input values not equaling 0 will fail the ZKP verification.",
    "recommendation": "Change the order of the two logic, as follows.\nif self.mpt_only {\n    return Ok(1);\n}\nconfig.s_custom.enable(region, 1)?;",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"padding_shift is underconstrained in the bytecode circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL-1.3",
    "target_file": "Bytecode Circuit, zkevm-circuits/src/bytecode_circuit/to_poseidon_hash.rs",
    "content": [
      {
        "type": "text",
        "text": "To apply the Poseidon hash to the bytecode, a circuit is required to"
      },
      {
        "type": "text",
        "text": "‚Ä¢ put together 31 bytes into a field element"
      },
      {
        "type": "text",
        "text": "‚Ä¢ take two field elements and put it into a Poseidon width"
      },
      {
        "type": "text",
        "text": "For the first part, the constraint system is set roughly as follows."
      },
      {
        "type": "text",
        "text": "‚Ä¢ If it is the 31st byte or the very last byte, it is a \"field border\""
      },
      {
        "type": "text",
        "text": "‚Ä¢ The field_input column accumulates the bytes into a field element, i.e. field_input = byte * padding_shift if is_field_border_prev else field_input_prev + byte * padding_shift"
      },
      {
        "type": "text",
        "text": "‚Ä¢ The padding_shift is the powers of 256, i.e. if not is_field_border_prev padding_shift = padding_shift_prev / 256"
      },
      {
        "type": "text",
        "text": "‚Ä¢ If it is the 31st byte, the padding_shift = 1"
      },
      {
        "type": "text",
        "text": "The last constraint is not enough, as we also need to constrain padding_shift = 1 also when it is the very last byte, or at least have some way to constrain padding_shift for the last chunk of the bytecode, which might not be exactly 31 bytes."
      },
      {
        "type": "text",
        "text": "This vulnerability can be verified by modifying assign_extended_row and unroll_to_hash_input so that the padding_shift values for the last chunk of the bytecode is modified."
      },
      {
        "type": "code",
        "code": "let bytes_in_field_index_inv_f\n    = F::from((BYTES_IN_FIELD - bytes_in_field_index) as u64)\n    .invert()\n    .unwrap_or(F::zero());\nlet mut padding_shift_f = F::from(256 as u64)\n    .pow_vartime([(BYTES_IN_FIELD - bytes_in_field_index) as u64]);\nlet vuln = F::from(13371337 as u64);\nif code_index / 31 == code_length / 31 {\n    padding_shift_f = padding_shift_f * vuln;\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "code",
        "code": "let vuln = F::from(13371337 as u64);\nlet (msgs, _) = code\n    .chain(std::iter::repeat(0))\n    .take(fl_cnt * BYTES_IN_FIELD)\n    .fold((Vec::new(), Vec::new()), |(mut msgs, mut cache), bt| {\n        cache.push(bt);\n        if cache.len() == BYTES_IN_FIELD {\n            let mut buf: [u8; 64] = [0; 64];\n            U256::from_big_endian(&cache).to_little_endian(&mut\n                buf[0..32]);\n            let ret = F::from_bytes_wide(&buf);\n            if msgs.len() == fl_cnt - 1 {\n                msgs.push(ret * vuln);\n            }\n            else {\n                msgs.push(F::from_bytes_wide(&buf));\n            }\n            cache.clear();\n        }\n        (msgs, cache)\n    });",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "As of now, the padding_shift for the very last byte is not constrained at all, unless the length of the bytecode is a multiple of 31. By setting padding_shift for the last byte appropriately, the last field element for the Poseidon hash can be set to any field element. For example, this may lead to two different bytecodes hashing to the same field element.",
    "recommendation": "We recommend to add a constraint to the padding_shift for the last chunk of the bytecode. We note that constraining padding_shift = 1 when it is the field border leads to different field values being mapped for the final chunk of the bytecode than the current implementation. For example, the final chunk of 0x01 will map to 1, rather than the current implementation's value of pow(256, 30).",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Missing range checks in MulAdd chip",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL-1.4",
    "target_file": "MulAdd Chip, gadgets/src/mul_add.rs",
    "content": [
      {
        "type": "text",
        "text": "The MulAdd chip checks the following relation: a * b + c = d (mod 2^256). To perform this calculation, the chip has to break up each number into smaller pieces (limbs) which vary in size from 64-bit to 128-bit. There are also auxillary elements in the chip used for carry where each limb is constrained to be 8-bit in size."
      },
      {
        "type": "text",
        "text": "As the field-element size in Halo2 is 254 bit, each of these limbs must have additional range checks to ensure that these limbs are properly constructed. Currently, there are no range checks on any of the individual elements used in the MulAdd chip."
      },
      {
        "type": "text",
        "text": "Following is a list of elements used by the circuits and the appropriate ranges checks that need to be performed:"
      },
      {
        "type": "text",
        "text": "‚Ä¢ a_limb0 - a_limb3: [0, 2^64)"
      },
      {
        "type": "text",
        "text": "‚Ä¢ b_limb0 - b_limb3: [0, 2^64)"
      },
      {
        "type": "text",
        "text": "‚Ä¢ c_lo, c_hi: [0, 2^128)"
      },
      {
        "type": "text",
        "text": "‚Ä¢ d_lo, d_hi: [0, 2^128)"
      },
      {
        "type": "text",
        "text": "‚Ä¢ carry_lo0 - carry_lo8: [0, 2^8)"
      },
      {
        "type": "text",
        "text": "‚Ä¢ carry_hi0 - carry_hi8: [0, 2^8)"
      },
      {
        "type": "text",
        "text": "By allowing values beyond the intended range into these elements, one can pass the constraints used in the MulAdd chip with incorrect values."
      },
      {
        "type": "text",
        "text": "As an example, one of the constraints checked in the chip is:"
      },
      {
        "type": "text",
        "text": "t0 = a0 ¬∑ b0"
      },
      {
        "type": "text",
        "text": "t1 = a0b1 + a1b0"
      },
      {
        "type": "text",
        "text": "t0 + t12^64 + clo = dlo + carry_lo2^128"
      },
      {
        "type": "text",
        "text": "Without the proper range checks on carry_lo, one can generate a fake proof for any values of a, b, c and d by calculate and assigning the appropriate value to the limbs of carry_lo."
      }
    ],
    "impact": "By allowing values beyond the intended range into these elements, one can pass the constraints used in the MulAdd chip with incorrect values.",
    "recommendation": "We recommend using the RangeCheckGadget to constrain the elements used in the chip to their expected values as mentioned above.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Incorrect calculation of overflow value in MulAdd chip",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf",
    "severity": "Low",
    "difficulty": "Low",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL-1.5",
    "target_file": "MulAdd Chip, gadgets/src/mul_add.rs",
    "content": [
      {
        "type": "text",
        "text": "The MulAdd chip has an additional output which calculates if there was any overflow in the calculation of a * b + c:"
      },
      {
        "type": "code",
        "code": "overflow = carry_hi_expr.clone()\n+ a_limbs[1].clone() * b_limbs[3].clone()\n+ a_limbs[2].clone() * b_limbs[2].clone()\n+ a_limbs[3].clone() * b_limbs[1].clone()\n+ a_limbs[2].clone() * b_limbs[3].clone()\n+ a_limbs[3].clone() * b_limbs[2].clone()\n+ a_limbs[3].clone() * b_limbs[3].clone();",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The actual formula to calculate this value is"
      },
      {
        "type": "text",
        "text": "(a1b3 + a2b2 + a3b1) + (a2b3 + a3b2) ‚àó 2^64 + (a3b3) ‚àó 2^128"
      },
      {
        "type": "text",
        "text": "In the implementation, the third term is written as a3 ‚àó b2 when it should be a3 ‚àó b1"
      }
    ],
    "impact": "Within the zkevm circuits, the overflow parameter is only used in exp_circuit.rs as a parity check mul gadget. There, the overflow is tested to be either zero or non-zero. As the mistake in the implementation only affects the correctness of the value of the overflow, there is no security impact. In the future, if the exact value of the overflow is used as part of another circuit, this may cause correctness issues.",
    "recommendation": "To fix the mistake the implementation of overflow calculation.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"ExpCircuit has a under-constrained exponentiation algorithm",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL-1.6",
    "target_file": "ExpCircuit, zkevm-circuits/src/exp-circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The ExpCircuit is used to calculate and check the results of the EXP opcode from the EVM. Using the variables from the implementation, the following formula is checked:"
      },
      {
        "type": "text",
        "text": "base^exponent = exponentiation (mod 2^256)"
      },
      {
        "type": "text",
        "text": "The circuit calculates the result using the exponentiation by squaring method. A pseudo-code of the algorithm is as follows:"
      },
      {
        "type": "code",
        "code": "# MulAdd(a, b, c) = a * b + c = d\nif is_odd(exponent):\n    constrain: MulAdd(2, exponent/2, 1) = exponent'\n    result' = result * base\nelse:\n    constrain: MulAdd(2, exponent, 0) = exponent\n    result' = result * result",
        "language": "python",
        "description": ""
      },
      {
        "type": "text",
        "text": "When the parity check on the exponent is odd, there are no checks to ensure that the previous exponent was even. However, this is not an security issue as it only effects the efficiency of the algorithm but not the correctness."
      },
      {
        "type": "text",
        "text": "For the case when the exponent is even, there are no constraint checks on the first argument to the MulAdd chip to ensure that a = 2. With a specific assignment of witness values, a malicious prover can prove the calculation of a incorrect exponentiation from the circuit."
      },
      {
        "type": "text",
        "text": "An example of a malicious witness assignment for the ExpTable can be seen below:"
      },
      {
        "type": "code",
        "code": "base exp res p_a p_b p_c p_d m_a m_b m_d\n5 12 15625 1 11 1 12 3125 5 15625\n5 11 3125 1 10 1 11 625 5 3125\n5 10 625 5 2 0 10 25 25 625\n5 2 25 5 5 25",
        "language": "text",
        "description": ""
      },
      {
        "type": "text",
        "text": "The column exp denotes the running exponent value and the column res represents the running value of exponentiation."
      },
      {
        "type": "text",
        "text": "Here, we can see that an attacker can incorrectly calculate the result that 5^12 = 15625 due to the under-constrained circuits."
      }
    ],
    "impact": "An attacker can incorrectly calculate the result that 5^12 = 15625 due to the under-constrained circuits.",
    "recommendation": "We recommend adding a constraint to check that the first argument to the parity check MulAdd gadget is 2 when the parity is even (c = 0).",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Bytecode Tag should be constrained to a boolean in BytecodeCircuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf",
    "severity": "Low",
    "difficulty": "Low",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL-1.7",
    "target_file": "Bytecode Circuit, zkevm-circuits/src/circuits.rs",
    "content": [
      {
        "type": "text",
        "text": "The tag value in the BytecodeTable is used to determine whether a byte is a header (tag = 0) or code (tag = 1). This tag is used in selectors such as is_header and is_byte to enable or disable certain constraints."
      },
      {
        "type": "text",
        "text": "These selectors make use of boolean expressions such as and::expr, or::expr and not::expr applied on the tag column and other selector columns. These expressions have the invariant that the inputs to these must be either 0 or 1. If that is not the case, it can lead to unintended results."
      },
      {
        "type": "text",
        "text": "The is_header selector is calculated as not(tag):"
      },
      {
        "type": "code",
        "code": "let is_header = |meta: &mut VirtualCells<F>| {\n    not::expr(meta.query_advice(bytecode_table.tag, Rotation::cur()))\n};",
        "language": "rust",
        "description": ""
      },
      {
        "type": "code",
        "code": "pub mod not {\n    ///) Returns an expression that represents the NOT of the given expression.\n    pub fn expr<F: FieldExt, E: Expr<F>>(b: E) -> Expression<F> {\n        1.expr() - b.expr()\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In the normal usecase, is_header is true/non-zero when tag = 0. However, if the value of tag is 2, then is_header is also non-zero and it acts as true."
      },
      {
        "type": "text",
        "text": "Another unintended result happens when these selectors are multiplied with actual witness values as in the case of lookups:"
      },
      {
        "type": "code",
        "code": "meta.lookup_any(\n    \"push_data_size_table_lookup(cur.value, cur.push_data_size)\",\n    |meta| {\n        let enable = and::expr(vec![\n            // ...)\n            is_byte(meta),\n        ]);\n        // ...)\n        for i in 0..PUSH_TABLE_WIDTH {\n            constraints.push((\n                enable.clone() * meta.query_advice(lookup_columns[i], Rotation::cur()),\n                meta.query_fixed(push_table[i], Rotation::cur()),\n            ))\n        }\n    },\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The is_byte expression directly uses the value of the tag, so we can control the value of enable to be arbitrary. This allows us to assign any value we want to the first column of the lookup query, which will allow us to bypass the lookup check."
      }
    ],
    "impact": "In the case of the bytecode circuit, we were unable to find any particular way to make invalid bytecode pass the constraints because of the large number of constraints on each row.",
    "recommendation": "As a proactive measure, we recommend using the require_boolean constraint to ensure that the value of bytecode_table.tag is 0 or 1, as it violates the invariants expected by the boolean expressions used in the selectors.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Redundant boolean constraint in Batched IsZero",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Overconstrained Circuits",
    "finding_id": "TOB-SCROLL-1.8",
    "target_file": "BatchedIsZeroChip, gadgets/src/batched_is_zero.rs",
    "content": [
      {
        "type": "text",
        "text": "The BatchedIsZero chip takes in as input a list of values and a nonempty_witness and sets the is_zero to be 1 if all the input values are zero, and 0 otherwise."
      },
      {
        "type": "text",
        "text": "Currently, there is a constraint that checks that the value of is_zero is a boolean, i.e it is 0 or 1. We show that it is not necessary to have this constraint as it is implicitly checked by the other two constraints in the chip."
      },
      {
        "type": "text",
        "text": "1. is_zero is 0 if there is any non-zero value: This constraint multiplies is_zero with all the values, and ensures that all the results are 0. If there is any non-zero value, then is_zero must be 0, or else this constraint will fail."
      },
      {
        "type": "text",
        "text": "2. is_zero is 1 if values are all zero: This constraint calculates (1 - is_zero) * PROD(1 - value * nonzero_witness). We know from the previous constraint that if there are any non-zero values, then is_zero must be equal to 0. This means that all the values are 0, and the terms in the product evaluate to 1. Therefore, the only possible value for is_zero which satisfies the constraint is 1."
      },
      {
        "type": "text",
        "text": "This shows that the value of is_zero can only be 0/1 based on the two constraints mentioned above."
      }
    ],
    "impact": "",
    "recommendation": "We suggest removing this redundant constraint to reduce the total number of constraints, but we also understand if you would like to keep this constraint to maintain the clarity of the circuit implementation.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Redundant boolean constraint in Exponentiation Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Overconstrained Circuits",
    "finding_id": "TOB-SCROLL-1.9",
    "target_file": "ExpCircuit, zkevm-circuits/src/exp-circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "There is a constraint in the ExpCircuit which ensures that the columns is_step is always boolean."
      },
      {
        "type": "code",
        "code": "// is_step is boolean.\ncb.require_boolean(\n    \"is_step is boolean\",\n    meta.query_fixed(exp_table.is_step, Rotation::cur()),\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "is_step is a Fixed Column whose values cannot be changed during witness synthesis and proving. Thus, this constraint is redundant and can be removed."
      }
    ],
    "impact": "",
    "recommendation": "We recommend removing this prover time constraint and instead adding a assert to ensure that the correct values are assigned to the is_step column during circuit compilation.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Non-trivial rotation incorrectly handled in ComparatorChip",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf",
    "severity": "Medium",
    "difficulty": "Low",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL-1.10",
    "target_file": "gadgets/src/comparator.rs",
    "content": [
      {
        "type": "text",
        "text": "The expr function returns the Expression<F> for whether lhs < rhs or lhs == rhs on the rotation."
      },
      {
        "type": "code",
        "code": "impl<F: Field, const N_BYTES: usize> ComparatorConfig<F, N_BYTES> {\n    ///) Returns (lt, eq) for a comparison between lhs and rhs.\n    pub fn expr(\n        &self,\n        meta: &mut VirtualCells<F>,\n        rotation: Option<Rotation>,\n    ) -> (Expression<F>, Expression<F>) {\n        (\n            self.lt_chip.config.is_lt(meta, rotation),\n            self.eq_chip.config.is_equal_expression.clone(),\n        )\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "It can be seen that the eq_chip result doesn't handle the rotation at all - so incorrect results will be returned for non-trivial rotation."
      }
    ],
    "impact": "In the case where the eq_chip result is used for incorrect rotation, incorrect Expression<F> will be used.",
    "recommendation": "We recommend either fixing the implementation of expr, or thoroughly checking and documenting the fact that the latter eq_chip result should not be used for a non-trivial rotation.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Field representation dependent implementation in LtChip",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL-1.11",
    "target_file": "gadgets/src/less_than.rs",
    "content": [
      {
        "type": "text",
        "text": "The assignment logic in the LtChip assumes that the field's to_repr returns a little-endian representation."
      },
      {
        "type": "code",
        "code": "let diff = (lhs - rhs) + (if lt { config.range } else { F::zero() });\nlet diff_bytes = diff.to_repr();\nfor (idx, diff_column) in config.diff.iter().enumerate() {\n    region.assign_advice(\n        || format!(\"lt chip: diff byte {}\", idx),\n        *diff_column,\n        offset,\n        || Value::known(F::from(diff_bytes[idx] as u64)),\n    )?;\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "However, it is documented that the endianness is implementation specific."
      },
      {
        "type": "code",
        "code": "///) Converts an element of the prime field into the standard byte representation for\n///) this field.\n///)\n///) The endianness of the byte representation is implementation-specific. Generic\n///) encodings of field elements should be treated as opaque.\nfn to_repr(&self) -> Self::Repr;",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "The current implementation cannot be used for fields or field implementations that return big-endian bytes.",
    "recommendation": "We recommend either fixing the implementation, or documenting this finding.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic%20-%20Part%201%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"RLP Circuit data table's byte_rev_idx is underconstrained",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Medium",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.1",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "The RlpFsmDataTable consists of seven advice columns and aims to map (tx_id, format, byte_idx) to (byte_rev_idx, byte_value, bytes_rlc, gas_cost_acc)."
      },
      {
        "type": "code",
        "code": "///)) Data table allows us a lookup argument from the RLP circuit to check\nthe byte value at an index\n///)) while decoding a tx of a given format.\n#)derive(Clone, Copy, Debug)]\npub struct RlpFsmDataTable {\n    ///)) Transaction index in the batch of txs.\n    pub tx_id: Column<Advice>,\n    ///)) Format of the tx being decoded.\n    pub format: Column<Advice>,\n    ///)) The index of the current byte.\n    pub byte_idx: Column<Advice>,\n    ///)) The reverse index at this byte.\n    pub byte_rev_idx: Column<Advice>,\n    ///)) The byte value at this index.\n    pub byte_value: Column<Advice>,\n    ///)) The accumulated Random Linear Combination up until (including) the\n    pub bytes_rlc: Column<Advice>,\n    ///)) The accumulated gas cost up until (including) the current byte.\n    pub gas_cost_acc: Column<Advice>,\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "There are various checks on this table, and one of them specifies what should happen when the instance (tx_id, format) changes."
      },
      {
        "type": "code",
        "code": "/) if (tx_id' =) tx_id and format' !) format) or (tx_id' !) tx_id and\ntx_id' !) 0)\ncb.condition(\n    sum:)expr([\n        /) case 1\n        and:)expr([\n            tx_id_check_in_dt.is_equal_expression.expr(),\n            not:)expr(format_check_in_dt.is_equal_expression.expr()),\n        ]),\n        /) case 2\n        and:)expr([\n            not:)expr(is_padding_in_dt.expr(Rotation:)next())(meta)),\n            not:)expr(tx_id_check_in_dt.is_equal_expression.expr()),\n        ]),\n    ]),\n    |cb| {\n        /) byte_rev_idx =) 1\n        cb.require_equal(\n            \"byte_rev_idx is 1 at the last index\",\n            meta.query_advice(data_table.byte_rev_idx, Rotation:)cur()),\n            1.expr(),\n        );\n        /) byte_idx' =) 1\n        cb.require_equal(\n            \"byte_idx resets to 1 for new format\",\n            meta.query_advice(data_table.byte_idx, Rotation:)next()),\n            1.expr(),\n        );\n        /) bytes_rlc' =) byte_value'\n        cb.require_equal(\n            \"bytes_value and bytes_rlc are equal at the first index\",\n            meta.query_advice(data_table.byte_value, Rotation:)next()),\n            meta.query_advice(data_table.bytes_rlc, Rotation:)next()),\n        );\n    },\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "Here, in the case where tx_id' =) tx_id and format' !) format, or tx_id' !) tx_id and tx_id' !) 0, it is constrained that the current byte_rev_idx should be 1. However, this condition misses the final byte of the final transaction ID, where tx_id' !) tx_id and tx_id' =) 0 as the next transaction is a padding. This implies that the final byte of the final transaction ID may not have byte_rev_idx =) 1, breaking the desired properties over the byte_rev_idx for the entire final transaction ID."
      }
    ],
    "impact": "The RlpFsmDataTable is used for a lookup, and this byte_rev_idx is also used later for various constraints. Using potentially incorrect values for byte_rev_idx may lead to further issues.",
    "recommendation": "The condition can be simply modified to tx_id' =) tx_id and format' !) format, or tx_id' !) tx_id.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Missing range check for byte values in RLP Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.2",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "There is a check for the byte_value in the data table to be within a byte range."
      },
      {
        "type": "code",
        "code": "meta.lookup_any(\"byte value check\", |meta| {\n    let cond = and:)expr([\n        meta.query_fixed(q_enabled, Rotation:)cur()),\n        is_padding_in_dt.expr(Rotation:)cur())(meta),\n    ]);\n    vec![meta.query_advice(data_table.byte_value, Rotation:)cur())]\n        .into_iter()\n        .zip(range256_table.table_exprs(meta).into_iter())\n        .map(|(arg, table)| (cond.expr() * arg, table))\n        .collect()\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "However, with the condition applied, it actually only checks that the padding rows have byte_value within the byte range. This means that the actual data rows' byte_values are never range checked properly."
      }
    ],
    "impact": "The byte_values are never range checked to be within [0, 256) range, which is a needed check.",
    "recommendation": "Change the condition to let cond = and:)expr([ meta.query_fixed(q_enabled, Rotation:)cur()), not:)expr(is_padding_in_dt.expr(Rotation:)cur())(meta)), ]);",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"The tag_length is never checked to be no more than max_length",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Medium",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.3",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "The max_length is used to define the maximum length of each tag, and it is also used to decide the base to use to accumulate the byte values. However, there is no check that the tag_length is no more than max_length."
      }
    ],
    "impact": "The tag_length may be over max_length ‚Äî so inputs that do not fit the desired specifications may pass all the constraints in the circuit.",
    "recommendation": "We recommend to add a constraint that checks tag_length <) max_length.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Missing range checks for the LtChip",
    "source":"Zellic Inc. x KALOS",
    "date":"07/31/2023",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.4",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs, Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The LtChip itself does not constrain that the diff columns are within the byte range and delegates this check to the circuits using this chip."
      },
      {
        "type": "code",
        "code": "///)) Config for the Lt chip.\n#)derive(Clone, Copy, Debug)]\npub struct LtConfig<F, const N_BYTES: usize> {\n    ///)) Denotes the lt outcome. If lhs < rhs then lt =) 1, otherwise lt =) 0.\n    pub lt: Column<Advice>,\n    ///)) Denotes the bytes representation of the difference between lhs and rhs.\n    ///)) Note that the range of each byte is not checked by this config.\n    pub diff: [Column<Advice>; N_BYTES],\n    ///)) Denotes the range within which both lhs and rhs lie.\n    pub range: F,\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "However, this is missing in the RLP circuits."
      },
      {
        "type": "text",
        "text": "For the ComparatorConfig, it is also important to check that the left hand side and the right hand side are all within the specified range."
      },
      {
        "type": "code",
        "code": "///)) Tx id must be no greater than cum_num_txs\ntx_id_cmp_cum_num_txs: ComparatorConfig<F, 2>,",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "Therefore, in the Tx Circuit, it should be checked that tx_id and cum_num_txs are within 16 bits."
      }
    ],
    "impact": "The missing range check on diff breaks the functionalities of the LtChip, so using LtChip does not actually constrain the comparison properly.",
    "recommendation": "We recommend to add the needed range checks for safe usage of the comparison gadgets.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Missing check in the initialization on the state machine in RLP Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.5",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "In the RLP state machine initialization, the byte_idx is checked to be 1, and the tag is checked to be either TxType or BeginList."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"sm init\", |meta| {\n    let mut cb = BaseConstraintBuilder:)default();\n    let tag = tag_expr(meta);\n    constrain_eq!(meta, cb, byte_idx, 1.expr());\n    cb.require_zero(\n        \"tag =) TxType or tag =) BeginList\",\n        (tag.expr() - TxType.expr()) * (tag - BeginList.expr()),\n    );\n    cb.gate(meta.query_fixed(q_first, Rotation:)cur()))\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "There is a missing check that the initial state should be DecodeTagStart."
      },
      {
        "type": "text",
        "text": "There is also no check that the initial tx_id is 1."
      }
    ],
    "impact": "This missing check allows us to start the decoding with states like Bytes. This may potentially lead to allowing invalid RLP decodings.",
    "recommendation": "We recommend to implement a check that the initial state is DecodeTagStart and that the initial tx_id is 1.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Transition to new RLP instance in the state machine is underconstrained in RLP Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.6",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "In the state machine, in the case where depth =) 1, state' !) End, and is_tag_end =) True, the machine regards this as the transition between two RLP instances. It then constrains that the"
      },
      {
        "type": "text",
        "text": "‚Ä¢ next byte_idx is 1,"
      },
      {
        "type": "text",
        "text": "‚Ä¢ next depth is 0, and"
      },
      {
        "type": "text",
        "text": "‚Ä¢ next state is DecodeTagStart"
      },
      {
        "type": "text",
        "text": "as well as that either tx_id' = tx_id + 1 or format' = format + 1."
      },
      {
        "type": "text",
        "text": "It also constrains the tag_next column of the current row to be either TxType or BeginList."
      },
      {
        "type": "code",
        "code": "cb.condition(\n    meta.query_advice(transit_to_new_rlp_instance, Rotation:)cur()),\n    |cb| {\n        let tx_id = meta.query_advice(rlp_table.tx_id, Rotation:)cur());\n        let tx_id_next = meta.query_advice(rlp_table.tx_id, Rotation:)next());\n        let format = meta.query_advice(rlp_table.format, Rotation:)cur());\n        let format_next = meta.query_advice(rlp_table.format, Rotation:)next());\n        let tag_next = tag_next_expr(meta);\n        /) state transition.\n        update_state!(meta, cb, byte_idx, 1);\n        update_state!(meta, cb, depth, 0);\n        update_state!(meta, cb, state, DecodeTagStart);\n        cb.require_zero(\n            \"(tx_id' =) tx_id + 1) or (format' =) format + 1)\",\n            (tx_id_next - tx_id - 1.expr()) * (format_next - format - 1.expr()),\n        );\n        cb.require_zero(\n            \"tag =) TxType or tag =) BeginList\",\n            (tag_next.expr() - TxType.expr()) * (tag_next.expr() - BeginList.expr()),\n        );\n    },\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "There are two issues. First, the constraint on (tx_id', format') is weak, as it allows cases like (tx_id', format') = (tx_id - 1, format + 1). The constraint on tag_next is also weak, as there are no constraints on the next offset's tag ‚Äî it should constrain that tag' is either TxType or BeginList instead."
      }
    ],
    "impact": "This underconstraint may allow the same transaction to appear twice in the state machine and the first tag for a new RLP instance to not be equal to TxType or BeginList.",
    "recommendation": "We recommend to implement proper checks for (tx_id', format') as well as tag' for the transition.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Equality between tag_value and the final tag_value_acc not checked",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.7",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "In the Bytes state in the state machine, the byte values are accumulated over a column tag_value_acc. The final value of this tag_value_acc is the actual tag_value, which should be stored in the table for other use. However, in the Bytes => DecodeTagStart case where tag_index = tag_length, there is no check that tag_value = tag_value_acc."
      },
      {
        "type": "code",
        "code": "/) Bytes => DecodeTagStart\ncb.condition(tidx_eq_tlen, |cb| {\n    /) assertions\n    emit_rlp_tag!(meta, cb, tag_expr(meta), false);\n    /) state transitions.\n    update_state!(meta, cb, tag, tag_next_expr(meta));\n    update_state!(meta, cb, state, State:)DecodeTagStart);\n    constrain_unchanged_fields!(meta, cb; rlp_table.tx_id, rlp_table.format, depth);\n});",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "Since tag_value is actually not constrained, the value that is actually in the RlpFsmRlpTable is not constrained.",
    "recommendation": "We recommend adding the check that tag_value is equal to tag_value_acc.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Missing do_not_emit! constraints",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.8",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "The do_not_emit! macro is used to force is_output = false. This is used in various places where the current row does not represent a full tag value. However, in the DecodeTagStart => LongList transition, this check is missing."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"state transition: DecodeTagStart => LongList\", |meta| {\n    let mut cb = BaseConstraintBuilder:)default();\n    let (bv_gt_0xf8, bv_eq_0xf8) = byte_value_gte_0xf8.expr(meta, None);\n    let cond = and:)expr([\n        sum:)expr([bv_gt_0xf8, bv_eq_0xf8]),\n        not:)expr(is_tag_end_expr(meta)),\n    ]);\n    cb.condition(cond.expr(), |cb| {\n        /) assertions.\n        constrain_eq!(meta, cb, is_tag_begin, true);\n        /) state transitions\n        update_state!(meta, cb, tag_length, byte_value_expr(meta) - 0xf7.expr());\n        update_state!(meta, cb, tag_idx, 1);\n        update_state!(meta, cb, tag_value_acc, byte_value_next_expr(meta));\n        update_state!(meta, cb, state, State:)LongList);\n        constrain_unchanged_fields!(meta, cb; rlp_table.tx_id, rlp_table.format, tag, tag_next);\n    });\n    cb.gate(and:)expr([\n        meta.query_fixed(q_enabled, Rotation:)cur()),\n        is_decode_tag_start(meta),\n    ]))\n});",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "In this case, the is_output is not constrained to be false, so the RlpFsmRlpTable may have invalid rows with is_output turned on, even though it should be turned off.",
    "recommendation": "We recommend adding a do_not_emit! macro in this case as well.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"The state machine is not constrained to end at End",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.9",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "There are no constraints that the state machine ends with the state End."
      }
    ],
    "impact": "The state machine at the final transaction does not necessarily have to move to the End state. This means that the checks for the Case 4 in the DecodeTagStart => DecodeTagStart case can be potentially skipped ‚Äî which includes the RLC, gas cost, and byte_rev_idx checks.",
    "recommendation": "We recommend adding a fixed column q_last, implementing the assign logic, and adding the constraint that the state is End if q_last is enabled.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Enum definition is inconsistent with the circuit layout",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Code Maturity",
    "finding_id": "TOB-SCROLL2-1.10",
    "target_file": "Tx Circuit, witness/tx.rs",
    "content": [
      {
        "type": "text",
        "text": "The Tx Circuit layout is composed of the fixed part with the transaction-related values of fixed size, followed by the dynamic part with the transaction calldata, which is not of fixed size. The layout for the fixed part is shown in the witness/tx.rs file's table_assignments_fixed."
      },
      {
        "type": "code",
        "code": "[\n    Value:)known(F:)from(self.id as u64)),\n    Value:)known(F:)from(TxContextFieldTag:)Nonce as u64)), /) 2\n    Value:)known(F:)zero()),\n    Value:)known(F:)from(self.nonce)),\n],\n[\n    Value:)known(F:)from(self.id as u64)),\n    Value:)known(F:)from(TxContextFieldTag:)Gas as u64)), /) 4\n    Value:)known(F:)zero()),\n    Value:)known(F:)from(self.gas)),\n],\n[\n    Value:)known(F:)from(self.id as u64)),\n    Value:)known(F:)from(TxContextFieldTag:)GasPrice as u64)), /) 3\n    Value:)known(F:)zero()),\n    challenges\n    .evm_word()\n    .map(|challenge| rlc:)value(&self.gas_price.to_le_bytes(), challenge)),\n],\n[\n    Value:)known(F:)from(self.id as u64)),\n    Value:)known(F:)from(TxContextFieldTag:)CallerAddress as u64)), /) 5\n    Value:)known(F:)zero()),\n    Value:)known(self.caller_address.to_scalar().unwrap()),\n],\n...)))",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The issue here is that the order of the enum TxContextFieldTag matches the layout order in the circuit, except for the case of TxContextFieldTag:)Gas and TxContextFieldTag:)GasPrice."
      },
      {
        "type": "text",
        "text": "The usage of the enums as an offset in the circuit can be seen in the circuit logic, as shown below."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"is_padding_tx\", |meta| {\n    let is_tag_caller_addr = is_caller_addr(meta);\n    let mut cb = BaseConstraintBuilder:)default();\n    /) the offset between CallerAddress and BlockNumber\n    let offset = usize:)from(BlockNumber) - usize:)from(CallerAddress);\n    /) if tag =) CallerAddress\n    cb.condition(is_tag_caller_addr.expr(), |cb| {\n        cb.require_equal(\n            \"is_padding_tx = true if caller_address = 0\",\n            meta.query_advice(is_padding_tx, Rotation(offset as i32)),\n            value_is_zero.expr(Rotation:)cur())(meta),\n        );\n    });\n    cb.gate(meta.query_fixed(q_enable, Rotation:)cur()))\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "Therefore, for code quality, it is recommended to keep consistency between the actual offsets in the circuit layout and the TxContextFieldTag enum."
      }
    ],
    "impact": "",
    "recommendation": "Swap the order of Gas and GasPrice in the layout or the enum so that it is consistent.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"The first row of each Tx in the calldata section is underconstrained in Tx Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.11",
    "target_file": "Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The Tx Circuit layout's latter part deals with the calldata of each transaction."
      },
      {
        "type": "text",
        "text": "It constrains"
      },
      {
        "type": "text",
        "text": "‚Ä¢ is_final is boolean"
      },
      {
        "type": "text",
        "text": "‚Ä¢ if is_final is false"
      },
      {
        "type": "text",
        "text": "‚Äì index' = index + 1 and tx_id' = tx_id"
      },
      {
        "type": "text",
        "text": "‚Äì calldata_gas_cost_acc' = calldata_gas_cost + (value' =) 0 ? 4 : 16)"
      },
      {
        "type": "text",
        "text": "‚Ä¢ if is_final is true"
      },
      {
        "type": "text",
        "text": "‚Äì tx_id' !) tx_id"
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"tx call data bytes\", |meta| {\n    let mut cb = BaseConstraintBuilder:)default();\n    let is_final_cur = meta.query_advice(is_final, Rotation:)cur());\n    cb.require_boolean(\"is_final is boolean\", is_final_cur.clone());\n    /) checks for any row, except the final call data byte.\n    cb.condition(not::expr(is_final_cur.clone()), |cb| {\n        cb.require_equal(\n            \"index:)next =) index:)cur + 1\",\n            meta.query_advice(tx_table.index, Rotation:)next()),\n            meta.query_advice(tx_table.index, Rotation:)cur()) + 1.expr(),\n        );\n        cb.require_equal(\n            \"tx_id:)next =) tx_id:)cur\",\n            tx_id_unchanged.is_equal_expression.clone(),\n            1.expr(),\n        );\n        let value_next_is_zero = value_is_zero.expr(Rotation:)next())(meta);\n        let gas_cost_next = select::expr(value_next_is_zero, 4.expr(), 16.expr());\n        /) call data gas cost accumulator check.\n        cb.require_equal(\n            \"calldata_gas_cost_acc:)next =) calldata_gas_cost:)cur + gas_cost_next\",\n            meta.query_advice(calldata_gas_cost_acc, Rotation:)next()),\n            meta.query_advice(calldata_gas_cost_acc, Rotation:)cur()) + gas_cost_next,\n        );\n    });\n    /) on the final call data byte, tx_id must change.\n    cb.condition(is_final_cur, |cb| {\n        cb.require_zero(\n            \"tx_id changes at is_final =) 1\",\n            tx_id_unchanged.is_equal_expression.clone(),\n        );\n    });\n    cb.gate(and::expr(vec![\n        meta.query_fixed(q_enable, Rotation:)cur()),\n        meta.query_advice(is_calldata, Rotation:)cur()),\n        not::expr(tx_id_is_zero.expr(Rotation:)cur())(meta)),\n    ]))\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The issue here is that there is no constraint for the first row of the new transaction. To be exact, there is no constraint that index = 0 and calldata_gas_cost_acc = (value =) 0 ? 4 : 16) for the first row of the transaction."
      }
    ],
    "impact": "The index and calldata_gas_cost can be maliciously changed for the first row, which may lead to the values in the mentioned columns to be incorrect.",
    "recommendation": "We recommend adding the necessary constraints for the first row.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"The sv_address is not constrained to be equal throughout a single transaction",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.12",
    "target_file": "Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The sv_address is intended to be the column representing the signer's address."
      },
      {
        "type": "text",
        "text": "The first constraint on this column is that it is equal to the caller address in the case where the address is nonzero and the transaction type is not L1Msg. Note that this is checked on the offset of CallerAddress."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\n    \"caller address =) sv_address if it's not zero and tx_type !) L1Msg\",\n    |meta| {\n        let mut cb = BaseConstraintBuilder:)default();\n        cb.condition(not::expr(value_is_zero.expr(Rotation::cur())(meta)),\n        |cb| {\n            cb.require_equal(\n                \"caller address =) sv_address\",\n                meta.query_advice(tx_table.value, Rotation::cur()),\n                meta.query_advice(sv_address, Rotation::cur()),\n            );\n        });\n        cb.gate(and::expr([\n            meta.query_fixed(q_enable, Rotation::cur()),\n            meta.query_advice(is_caller_address, Rotation::cur()),\n            not::expr(meta.query_advice(is_l1_msg, Rotation::cur())),\n        ]))\n    },\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The second constraint on this column is the lookup to the sig circuit. This shows that the sv_address is the recovered address from the ECDSA signature. Note that this is checked on the offset of ChainId."
      },
      {
        "type": "code",
        "code": "meta.lookup_any(\"Sig table lookup\", |meta| {\n    let enabled = and::expr([\n        // use is_l1_msg_col instead of is_l1_msg(meta) because it has\n        // lower degree\n        not::expr(meta.query_advice(is_l1_msg_col, Rotation::cur())),\n        // lookup to sig table on the ChainID row because we have an\n        // indicator of degree 1\n        // for ChainID and ChainID is not far from (msg_hash_rlc, sig_v,\n        // ...)\n        meta.query_advice(is_chain_id, Rotation::cur()),\n    ]);\n    let msg_hash_rlc = meta.query_advice(tx_table.value, Rotation(6));\n    let chain_id = meta.query_advice(tx_table.value, Rotation::cur());\n    let sig_v = meta.query_advice(tx_table.value, Rotation(1));\n    let sig_r = meta.query_advice(tx_table.value, Rotation(2));\n    let sig_s = meta.query_advice(tx_table.value, Rotation(3));\n    let sv_address = meta.query_advice(sv_address, Rotation::cur());\n    let v = is_eip155(meta) * (sig_v.expr() - 2.expr() * chain_id - 35.expr())\n        + is_pre_eip155(meta) * (sig_v.expr() - 27.expr());\n    let input_exprs = vec![\n        1.expr(), // q_enable = true\n        msg_hash_rlc, // msg_hash_rlc\n        v, // sig_v\n        sig_r, // sig_r\n        sig_s, // sig_s\n        sv_address,\n        1.expr(), // is_valid\n    ];\n    // LookupTable::table_exprs is not used here since `is_valid` not used\n    // by evm circuit.\n    let table_exprs = vec![\n        meta.query_fixed(sig_table.q_enable, Rotation::cur()),\n        // msg_hash_rlc not needed to be looked up for tx circuit?\n        meta.query_advice(sig_table.msg_hash_rlc, Rotation::cur()),\n        meta.query_advice(sig_table.sig_v, Rotation::cur()),\n        meta.query_advice(sig_table.sig_r_rlc, Rotation::cur()),\n        meta.query_advice(sig_table.sig_s_rlc, Rotation::cur()),\n        meta.query_advice(sig_table.recovered_addr, Rotation::cur()),\n        meta.query_advice(sig_table.is_valid, Rotation::cur()),\n    ];\n    input_exprs\n        .into_iter()\n        .zip(table_exprs.into_iter())\n        .map(|(input, table)| (input * enabled.expr(), table))\n        .collect()\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The offset of the sv_address that is checked in the two constraints are different, and there are no constraints to enforce that these two sv_address values are equal. In other words, there are no constraints to check that the sv_address value is equal throughout the rows that represent the same transaction."
      }
    ],
    "impact": "An attacker may use different addresses for the caller address and the ECDSA signature's recovered address. Depending on the exact logic of the other circuits, this could lead to arbitrary contract calls without proper ECDSA signatures.",
    "recommendation": "We recommend adding the check that sv_address is equal throughout the rows of the same transaction.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Block number constraints are incorrect in PI circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.13",
    "target_file": "PI Circuit, pi_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The block table is composed of a fixed column tag and advice columns index and value."
      },
      {
        "type": "code",
        "code": "///)) Table with Block header fields\n#)derive(Clone, Debug)]\npub struct BlockTable {\n    ///)) Tag\n    pub tag: Column<Fixed>,\n    ///)) Index\n    pub index: Column<Advice>,\n    ///)) Value\n    pub value: Column<Advice>,\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "Here, the index column is the block number corresponding to the row. The assignments for this table are shown in witness/block.rs."
      },
      {
        "type": "code",
        "code": "[\n    vec![\n        [\n            Value::known(F::from(BlockContextFieldTag::Coinbase as u64)),\n            Value::known(current_block_number),\n            Value::known(self.coinbase.to_scalar().unwrap()),\n        ],\n        [\n            Value::known(F::from(BlockContextFieldTag::Timestamp as u64)),\n            Value::known(current_block_number),\n            Value::known(self.timestamp.to_scalar().unwrap()),\n        ],\n        [\n            Value::known(F::from(BlockContextFieldTag::Number as u64)),\n            Value::known(current_block_number),\n            Value::known(current_block_number),\n        ],\n        [\n            Value::known(F::from(BlockContextFieldTag::Difficulty as u64)),\n            Value::known(current_block_number),\n            randomness.map(|rand| rlc::value(&self.difficulty.to_le_bytes(), rand)),\n        ],\n        [\n            Value::known(F::from(BlockContextFieldTag::GasLimit as u64)),\n            Value::known(current_block_number),\n            Value::known(F::from(self.gas_limit)),\n        ],\n        [\n            Value::known(F::from(BlockContextFieldTag::BaseFee as u64)),\n            Value::known(current_block_number),\n            randomness\n                .map(|randomness| rlc::value(&self.base_fee.to_le_bytes(), randomness)),\n        ],\n        [\n            Value::known(F::from(BlockContextFieldTag::ChainId as u64)),\n            Value::known(current_block_number),\n            Value::known(F::from(self.chain_id)),\n        ],\n        [\n            Value::known(F::from(BlockContextFieldTag::NumTxs as u64)),\n            Value::known(current_block_number),\n            Value::known(F::from(num_txs as u64)),\n        ],\n        [\n            Value::known(F::from(BlockContextFieldTag::CumNumTxs as u64)),\n            Value::known(current_block_number),\n            Value::known(F::from(cum_num_txs as u64)),\n        ],\n    ],\n    self.block_hash_assignments(randomness),\n]",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "To constrain the block number, two checks are needed."
      },
      {
        "type": "text",
        "text": "‚Ä¢ The index values for these rows are equal."
      },
      {
        "type": "text",
        "text": "‚Ä¢ The index value is equal to the value column's value in the BlockContextFieldTag::Number row."
      },
      {
        "type": "text",
        "text": "However, this is incorrectly done."
      },
      {
        "type": "code",
        "code": "for (row, tag) in block_ctx\n    .table_assignments(num_txs, cum_num_txs, challenges)\n    .into_iter()\n    .zip(tag.iter())\n{\n    region.assign_fixed(\n        || format!(\"block table row {offset}\"),\n        self.block_table.tag,\n        offset,\n        || row[0],\n    )?;\n    // index_cells of same block are equal to block_number.\n    let mut index_cells = vec![];\n    let mut block_number_cell = None;\n    for (column, value) in block_table_columns.iter().zip_eq(&row[1..]) {\n        let cell = region.assign_advice(\n            || format!(\"block table row {offset}\"),\n            *column,\n            offset,\n            || *value,\n        )?;\n        if *tag == Number && *column == self.block_table.value {\n            block_number_cell = Some(cell.clone());\n        }\n        if *column == self.block_table.index {\n            index_cells.push(cell.clone());\n        }\n        if *column == self.block_table.value {\n            block_value_cells.push(cell);\n        }\n    }\n    for i in 0..(index_cells.len() - 1) {\n        region.constrain_equal(index_cells[i].cell(), index_cells[i + 1].cell())?;\n    }\n    if *tag == Number {\n        region.constrain_equal(\n            block_number_cell.unwrap().cell(),\n            index_cells[0].cell(),\n        )?;\n    }\n    ...)\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "Here, the index_cells array and block_number_cell is taken for every single row, and the equality constraints between the cells are added. This means that the equality constraints between the index_cells are not actually properly being done, as this array is created for every row, not for every block."
      }
    ],
    "impact": "The block table's index column may not be equal to the block number.",
    "recommendation": "We recommend taking the declaration of the index_cells array and the block_number_cell as well as the equality constraints outside the for loop of the table assignments.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Missing constraint for the first tx_id in Tx Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.14",
    "target_file": "Tx Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "For the tx_id column, the constraints are that"
      },
      {
        "type": "text",
        "text": "‚Ä¢ if tag' = Nonce, then tx_id' = tx_id + 1, and"
      },
      {
        "type": "text",
        "text": "‚Ä¢ if tag' != Nonce, then tx_id' = tx_id."
      },
      {
        "type": "text",
        "text": "While the transitions of the tx_id column are correct, there is no check that the first tx_id is equal to 1 in the Tx Circuit."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"tx_id transition\", |meta| {\n    let mut cb = BaseConstraintBuilder::default();\n    // if tag_next == Nonce, then tx_id' = tx_id + 1\n    cb.condition(tag_bits.value_equals(Nonce, Rotation::next())(meta), |cb| {\n        cb.require_equal(\n            \"tx_id increments\",\n            meta.query_advice(tx_table.tx_id, Rotation::next()),\n            meta.query_advice(tx_table.tx_id, Rotation::cur()) + 1.expr(),\n        );\n    });\n    // if tag_next != Nonce, then tx_id' = tx_id, tx_type' = tx_type\n    cb.condition(\n        not::expr(tag_bits.value_equals(Nonce, Rotation::next())(meta)),\n        |cb| {\n            cb.require_equal(\n                \"tx_id does not change\",\n                meta.query_advice(tx_table.tx_id, Rotation::next()),\n                meta.query_advice(tx_table.tx_id, Rotation::cur()),\n            );\n            cb.require_equal(\n                \"tx_type does not change\",\n                meta.query_advice(tx_type, Rotation::next()),\n                meta.query_advice(tx_type, Rotation::cur()),\n            );\n        },\n    );\n    cb.gate(and::expr([\n        meta.query_fixed(q_enable, Rotation::cur()),\n        not::expr(meta.query_advice(is_calldata, Rotation::next())),\n    ]))\n});",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "The first tx_id value is not guaranteed to be 1, so tx_id can start with an arbitrary value.",
    "recommendation": "We recommend adding the check for the first tx_id.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"The CallDataRLC value in the fixed assignments is not validated against the actual calldata in Tx Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.15",
    "target_file": "Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The fixed part of the Tx Circuit layout includes the row representing the CallDataRLC, which is the random linear combination of the calldata bytes. This value is also checked from the RLP circuit as well."
      },
      {
        "type": "text",
        "text": "The dynamic part of the Tx Circuit layout includes the raw calldata bytes for each transaction."
      },
      {
        "type": "text",
        "text": "The issue is that while there are checks for the CallDataGasCost and CallDataLength via lookups, there is no check the CallDataRLC value is actually equal to the RLC of the bytes in the calldata section."
      }
    ],
    "impact": "The actual calldata used can be different from the one in the RLP circuit or the fixed part of the Tx Circuit.",
    "recommendation": "We recommend adding the check of the consistency between the CallDataRLC and the calldata part of the Tx Circuit layout via a lookup argument.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"The OneHot encoding gadget has incorrect constraints",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL2-1.16",
    "target_file": "MPT Circuit, gadgets/one_hot.rs",
    "content": [
      {
        "type": "text",
        "text": "The OneHot gadget has a previous helper function that returns the enum type represented by the one-hot encoding at the previous row."
      },
      {
        "type": "code",
        "code": "impl<T: IntoEnumIterator + Hash + Eq> OneHot<T> {\n    // ...\n    pub fn previous<F: FieldExt>(&self) -> Query<F> {\n        T::iter().enumerate().fold(Query::zero(), |acc, (i, t)| {\n            acc.clone()\n                + Query::from(u64::try_from(i).unwrap())\n                    * self\n                        .columns\n                        .get(&t)\n                        .map_or_else(BinaryQuery::zero,\n                            BinaryColumn::current)\n        })\n    }\n    // ...\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "However, this implementation is incorrect as it queries the value of the binary columns representing the one-hot encoding at the current row."
      }
    ],
    "impact": "The OneHot gadget is used to maintain the validity of the transitions between various proof types in the MPT Circuit. For example, cb.condition(!is_start, |cb| { cb.assert_equal( \"proof type does not change\", proof_type.current(), proof_type.previous(), ); this incorrect constraint can be used to generate invalid proofs in the MPT Circuit.",
    "recommendation": "We recommend fixing the incorrect constraint by using BinaryColumn::previous to query the previous row.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"The BinaryColumn gadget is missing boolean constraint check",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.17",
    "target_file": "MPT Circuit, constraint_builder/binary_column.rs",
    "content": [
      {
        "type": "text",
        "text": "The BinaryColumn gadget is used by the OneHot encoding gadget to store information about the ProofType and SegmentType of each row. This gadget also assumes that the binary column exposed by the gadget only contains boolean (0/1) values."
      },
      {
        "type": "text",
        "text": "However, no such constraint exists in the BinaryColumn gadget to check this assumption:"
      },
      {
        "type": "code",
        "code": "impl BinaryColumn {\n    // ...\n    pub fn configure<F: FieldExt>(\n        cs: &mut ConstraintSystem<F>,\n        _cb: &mut ConstraintBuilder<F>,\n    ) -> Self {\n        let advice_column = cs.advice_column();\n        // TODO: constrain to be binary here...\n        // cb.add_constraint()\n        Self(advice_column)\n    }\n}",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "By assigning nonboolean values to the binary columns, one can generate inconsistent results returned by the queries to the OneHot gadget. This can lead to incorrect proof generation in the MPT Circuit, which makes use of these gadgets.",
    "recommendation": "We recommend adding a boolean constraint on the advice column in the BinaryColumn gadget.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Missing range check for address values in MPT Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.18",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "In the MPT Circuit, the account address is used to calculate the MPT key where account data is stored in the state trie:"
      },
      {
        "type": "code",
        "code": "impl MptUpdateConfig {\n    pub fn configure<F: FieldExt>(//...)/) {\n        // ...\n        cb.condition(is_start.clone().and(cb.every_row_selector()),\n            |cb| {\n                let [address, address_high, ..] = intermediate_values;\n                let [old_hash_rlc, new_hash_rlc, ..]\n                    = second_phase_intermediate_values;\n                let address_low: Query<F> = (address.current()\n                    - address_high.current() * (1 << 32))\n                    * (1 << 32)\n                    * (1 << 32)\n                    * (1 << 32);\n                cb.poseidon_lookup(\n                    \"account mpt key = h(address_high, address_low)\",\n                    [address_high.current(), address_low, key.current()],\n                    poseidon,\n                );\n                //...)\n            }\n        }\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "There need to be range checks on the various values of address:"
      },
      {
        "type": "text",
        "text": "‚Ä¢ The address needs to be range checked to be within 20 bytes or 160 bits"
      },
      {
        "type": "text",
        "text": "‚Ä¢ The address_high must be range checked to be within 16 bytes or 128 bits."
      },
      {
        "type": "text",
        "text": "‚Ä¢ The calculated value of address_low (before the multiplication by 2^96) must be range checked to be within 4 bytes or 32 bits."
      }
    ],
    "impact": "Without the necessary range checks, one can calculate multiple combinations of address_low and address_high for the same value of address. This results in multiple MPT keys for a single address, which leads to a invalid state trie.",
    "recommendation": "We recommend adding the appropriate range checks to the intermediate columns as mentioned above.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Incorrect assertion for account hash traces in Proof::check",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL2-1.19",
    "target_file": "MPT Circuit, types.rs",
    "content": [
      {
        "type": "text",
        "text": "The Proof::check function ensures that the account hash traces that are used as intermediate witnesses for the MPT circuit are generated correctly. One of the assertions in this function contains a typo:"
      },
      {
        "type": "code",
        "code": "impl Proof {\n    fn check(&self) {\n        // ...\n        assert_eq!(\n            hash(\n                hash(Fr::one(), self.leafs[0].unwrap().key),\n                self.leafs[0].unwrap().value_hash\n            ),\n            self.old_account_hash_traces[5][2],\n        );\n        assert_eq!(\n            hash(\n                hash(Fr::one(), self.leafs[1].unwrap().key),\n                self.leafs[1].unwrap().value_hash\n            ),\n            self.new_account_hash_traces[5][2],\n        );\n        // ...\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "If we looked at account_hash_traces where these traces are generated, we see that the left-hand side of the assertion is actually equal to the entry account_hash_traces[6][2]:"
      },
      {
        "type": "code",
        "code": "fn account_hash_traces(address: Address, account: AccountData,\nstorage_root: Fr) -> [[Fr; 3]; 7] {\n    let account_key = account_key(address);\n    let h5 = hash(Fr::one(), account_key);\n    let poseidon_codehash = big_uint_to_fr(&account.poseidon_code_hash);\n    let account_hash = hash(h4, poseidon_codehash);\n    // ...\n    account_hash_traces[5] = [Fr::one(), account_key, h5];\n    account_hash_traces[6] = [h5, account_hash, hash(h5, account_hash)];\n}",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "As this function is not used anywhere, there is no security impact. However, we recommend fixing this for code maturity as it may be used in tests in the future.",
    "recommendation": "Change the right-hand side of the assertion to the correct index.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Implementations of RlcLookup trait are not consistent",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Informational",
    "difficulty": "Low",
    "type": "Code Maturity",
    "finding_id": "TOB-SCROLL2-1.20",
    "target_file": "MPT Circuit",
    "content": [
      {
        "type": "text",
        "text": "The MPT Circuit uses the RlcLookup trait to perform lookups about the RLC values of various witnesses. This trait is defined in byte_representation.rs:"
      },
      {
        "type": "code",
        "code": "pub trait RlcLookup {\n    fn lookup<F: FieldExt>(&self) -> [Query<F>; 3];\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "This lookup trait is implemented by two gadgets: ByteRepresentation and CanonicalRepresentation:"
      },
      {
        "type": "code",
        "code": "impl RlcLookup for ByteRepresentationConfig {\n    fn lookup<F: FieldExt>(&self) -> [Query<F>; 3] {\n        [\n            self.value.current(),\n            self.index.current(),\n            self.rlc.current(),\n        ]\n    }\n}\n\nimpl RlcLookup for CanonicalRepresentationConfig {\n    fn lookup<F: FieldExt>(&self) -> [Query<F>; 3] {\n        [\n            self.value.current(),\n            self.rlc.current(),\n            self.index.current(),\n        ]\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "While both of these gadgets implement the same lookup trait, they have a different order of columns. Not only that, but the definition of value is different ‚Äî while value in the ByteRepresentationConfig is the value of the accumulated bytes so far, the value in the CanonicalRepresentationConfig is the value of the entire field element."
      },
      {
        "type": "text",
        "text": "This lookup trait is used in word_rlc.rs with a implicit assumption that the RlcLookup is implemented by the ByteRepresentationConfig."
      }
    ],
    "impact": "While there are no wrong lookups performed currently, there is a chance that future changes to the code may introduce security issues due to incorrect assumptions on the structure of the RlcLookup.",
    "recommendation": "We recommend introducing distinct traits for these two different lookups to remove the ambiguity and improve code maturity.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Missing constraints for new account in configure_balance",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.21",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "Within configure_balance in the MPT circuit, with segment type AccountLeaf3 and path type ExtensionNew, there should be a constraint that ensures that the sibling is equal to 0."
      },
      {
        "type": "text",
        "text": "This corresponds to the case when we are creating a new entry in the accounts trie and we are assigning the balance of the account as the first entry."
      }
    ],
    "impact": "Without this constraint, there may be soundness issues when updating the balance of a new address.",
    "recommendation": "We recommend adding a check to constraint the sibling (i.e., nonce/codesize) to be equal to 0.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Missing constraints in configure_empty_storage",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.22",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "There should be a check to ensure that the old_hash and new_hash are the same for an empty storage entry. This is similar to the case in configure_empty_account where the same thing is in fact constrained:"
      },
      {
        "type": "code",
        "code": "fn configure_empty_account<F: FieldExt>(// .../) */) {\n    // ...\n    cb.assert_equal(\n        \"hash doesn't change for empty account\",\n        config.old_hash.current(),\n        config.new_hash.current(),\n    );\n    // ...\n}",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "This may lead to soundness issues when proving that storage does not exist.",
    "recommendation": "We recommend adding a check to constrain the equality of the old and the new hash.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Enforcing padding rows in MPT circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Medium",
    "difficulty": "Low",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.23",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "The configure_empty_storage and configure_empty_account use the following check to determine if the current row is the final segment."
      },
      {
        "type": "code",
        "code": "let is_final_segment\n    = config.segment_type.next_matches(&[SegmentType::Start]);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In the case that the current proof is the last proof in the MPT table, this assumes that the rows after the last proof are populated with the appropriate padding rows."
      },
      {
        "type": "text",
        "text": "However, there are no constraints to ensure that these padding rows have been assigned properly at the end of the MPT circuit."
      }
    ],
    "impact": "Without this constraint, there may be soundness issues for MPTProofType::StorageDoesNotExist and MPTProofType::AccountDoesNotExist.",
    "recommendation": "We recommend adding checks in the circuit to ensure that the padding rows have been assigned following the algorithm in assign_padding_row.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Incorrect constraints in configure_nonce",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.24",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "In configure_nonce, when the segment type is AccountLeaf3 and the path type is Common, there is a missed check on the size of the new nonce. This is because the old value of the nonce is mistakenly checked (see [1])."
      },
      {
        "type": "text",
        "text": "Additionally, there is another incorrect check when the path type is ExtensionNew where the old nonce is range checked instead of the new nonce (see [2])."
      },
      {
        "type": "code",
        "code": "fn configure_nonce(// .../) */) {\n    // ...\n    SegmentType::AccountLeaf3 => {\n        // ...\n        cb.condition(\n            config.path_type.current_matches(&[PathType::Common]),\n            |cb| {\n                cb.add_lookup(\n                    \"new nonce is 8 bytes\",\n                    [config.old_value.current(),\n                    Query::from(7)], // [1] Typo.\n                    bytes.lookup(),\n                );\n                // ...\n            }\n        );\n        cb.condition(\n            config.path_type.current_matches(&[PathType::ExtensionNew]),\n            |cb| {\n                cb.add_lookup(\n                    \"new nonce is 8 bytes\",\n                    [config.old_value.current(),\n                    Query::from(7)], // [2] Typo\n                    bytes.lookup(),\n                );\n                // ...\n            },\n        );\n    }\n    // ...\n}",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "As the nonce values are not range checked properly, proofs about accounts with invalid nonces can be generated. This could potentially lead to denial-of-service attacks on addresses.",
    "recommendation": "Fix the typos to range check the correct nonce values.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Conflicting constraints in configure_code_size",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Low",
    "difficulty": "Low",
    "type": "Coding Mistakes",
    "finding_id": "TOB-SCROLL2-1.25",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "In configure_code_size, the first line ensures that the only possible path types that can be proved are PathType::Start and PathType::Common."
      },
      {
        "type": "code",
        "code": "fn configure_code_size<F: FieldExt>(\n    cb: &mut ConstraintBuilder<F>,\n    config: &MptUpdateConfig,\n    bytes: &impl BytesLookup,\n) {\n    cb.assert(\n        \"new accounts have balance or nonce set first\",\n        config\n            .path_type\n            .current_matches(&[PathType::Start, PathType::Common]),\n    );\n    // ...\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "However, later on in the function, there are constraints that are conditioned on the current path type being either PathType::ExtensionOld or PathType::ExtensionNew."
      },
      {
        "type": "text",
        "text": "These two above-mentioned constraints are contradictory, and the code later on will never be executed as these conditions cannot be true."
      },
      {
        "type": "text",
        "text": "A similar issue also exists in configure_poseidon_code_hash."
      }
    ],
    "impact": "If this is intended behavior, then the above-mentioned constraints are dead code and add to unnecessary code complexity.",
    "recommendation": "We recommend removing those constraints if they are not necessary.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"ByteRepresentation::index is not properly constrained",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Medium",
    "difficulty": "Low",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.26",
    "target_file": "MPT Circuit, gadgets/byte_representation.rs",
    "content": [
      {
        "type": "text",
        "text": "In the ByteRepresentation gadget, there is a constraint which ensures that the index always increases by 1 or is 0. The expected behavior is that it constrains the value of index to be 0 at the first row."
      },
      {
        "type": "code",
        "code": "impl ByteRepresentationConfig {\n    pub fn configure<F: FieldExt>(// .../) */) -> Self {\n        let [value, index, byte] = cb.advice_columns(cs);\n        let [rlc] = cb.second_phase_advice_columns(cs);\n        let index_is_zero = IsZeroGadget::configure(cs, cb, index);\n        cb.assert_zero(\n            \"index increases by 1 or resets to 0\",\n            index.current() * (index.current() - index.previous() - 1),\n        );\n",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "At the first row, a rotation to the previous row will wrap around to the last row of the table, which includes the blinding factors in Halo2. This lets the value of the index be controlled by values in the last row of the table."
      }
    ],
    "impact": "Instead of the index being set to 0 in the first row, a prover can arbitrary non-zero value depending on the contents of the last row of the table.",
    "recommendation": "We recommend adding a selector which enables a constraint to constrain that index = 0 at the first row.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Miscellaneous typos in comments and constraint descriptions",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Code Maturity",
    "finding_id": "TOB-SCROLL2-1.27",
    "target_file": "MPT Circuit",
    "content": [
      {
        "type": "text",
        "text": "In byte_representation.rs, the following constraints have incorrect comments. They should have (index != 0)."
      },
      {
        "type": "code",
        "code": "cb.assert_equal(\n    \"current value = previous value * 256 * (index == 0) + byte\",\n    value.current(),\n    value.previous() * 256 * !index_is_zero.current() + byte.current(),\n);\n\ncb.assert_equal(\n    \"current rlc = previous rlc * randomness * (index == 0) + byte\",\n    rlc.current(),\n    rlc.previous() * randomness.query() * !index_is_zero.current() + byte.current(),\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In mpt_update.rs, the function configure_code_size has the following constraint. The description is incorrect, as it actually checks that the balance is 0."
      },
      {
        "type": "code",
        "code": "cb.assert_zero(\n    \"nonce and code size are 0 for ExtensionNew balance update\",\n    config.sibling.current(),\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In mpt_update.rs, the following constraint has an incorrect description. The constraint checks new_value, but the comment mentions old_value."
      },
      {
        "type": "code",
        "code": "cb.condition(!is_start, |cb| {\n    // ...\n    cb.assert_equal(\n        // typo\n        \"old_value does not change\",\n        new_value.current(),\n        new_value.previous(),\n    );\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In account.rs, the computation of old_root and new_root are incorrect."
      },
      {
        "type": "code",
        "code": "impl AccountProof {\n    pub fn old_root(&self) -> Fr {\n        self.trie_rows\n            .old_root(|| self.old_leaf.hash(self.storage.new_root()))\n            // old_root, but uses new_root to hash\n    }\n    pub fn new_root(&self) -> Fr {\n        self.trie_rows\n            .new_root(|| self.new_leaf.hash(self.storage.old_root()))\n            // new_root, but uses old_root to hash\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "There is also a typo in implementing From<&SMTTrace> for AccountProof."
      },
      {
        "type": "code",
        "code": "impl From<&SMTTrace> for AccountProof {\n    fn from(trace: &SMTTrace) -> Self {\n        let address = Address::from(trace.address.0);\n        let [old_path, new_path] = &trace.account_path;\n        let old_leaf = old_path.leaf;\n        let new_leaf = new_path.leaf;\n        let trie_rows = TrieRows::new(\n            account_key(address),\n            &new_path.path, // here - might be old_path.path\n            &new_path.path,\n            old_path.leaf,\n            new_path.leaf,\n        );\n        // ...)\n    }\n}",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "",
    "recommendation": "We recommend fixing these mistakes for better code maturity.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"ChainId is not mapped to it's corresponding RLP Tag in Tx Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.28",
    "target_file": "Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "In the Tx Circuit, the TxFieldTag values in the tag_bits column are mapped to their respective RLP Tag values using the following map:"
      },
      {
        "type": "code",
        "code": "let rlp_tag_map: Vec<(Expression<F>, RlpTag)> = vec![\n    (is_nonce(meta), Tag::Nonce.into()),\n    (is_gas_price(meta), Tag::GasPrice.into()),\n    // ...)\n    (is_caller_addr(meta), Tag::Sender.into()),\n    (is_tx_gas_cost(meta), GasCost),\n    // tx tags which correspond to Null\n    (is_null(meta), Null),\n    (is_create(meta), Null),\n    // ...)\n    (is_block_num(meta), Null),\n    (is_chain_id_expr(meta), Null),\n];",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In this map, the values which do not have a corresponding RLP Tag are set to Null. Here, chain_id is incorrectly set to Null even though it is part of the RLP encoded transaction (Tag::ChainId)."
      },
      {
        "type": "text",
        "text": "The rlp_tag values are used to lookup into the RLP table to ensure that the appropriate values are being hashed for verifying the transaction signature."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"sign tag lookup into RLP table condition\", |meta| {\n    let mut cb = BaseConstraintBuilder::default();\n    let is_tag_in_tx_sign = sum::expr([\n        is_nonce(meta),\n        is_gas_price(meta),\n        is_gas(meta),\n        is_to(meta),\n        is_value(meta),\n        is_data_rlc(meta),\n        is_sign_length(meta),\n        is_sign_rlc(meta),\n    ]);\n    cb.require_equal(\n        \"condition\",\n        is_tag_in_tx_sign,\n        meta.query_advice(\n            lookup_conditions[&LookupCondition::RlpSignTag],\n            Rotation::cur(),\n        ),\n    );",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "As the Chain ID is missing from these lookup checks, one can forge the Chain ID value for a given transaction with a existing signature."
      }
    ],
    "impact": "As the Chain ID is missing from these lookup checks, one can forge the Chain ID value for a given transaction with a existing signature.",
    "recommendation": "We recommend adding the mapping from TxFieldTag::ChainID to the RLP Tag Tag::ChainId. We also recommend ensuring that the Chain ID value in the Tx Table is looked up into the RLP Table using the above mapping.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Highest tx_id must be equal to cum_num_txs in Tx Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "High",
    "difficulty": "Medium",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.29",
    "target_file": "Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "In the Tx Circuit, there is a check to ensure that tx_id is less than the cum_num_txs value which is looked up from the block table."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"tx_id <= cum_num_txs\", |meta| {\n    let mut cb = BaseConstraintBuilder::default();\n    let (lt_expr, eq_expr) = tx_id_cmp_cum_num_txs.expr(meta, None);\n    cb.condition(is_block_num(meta), |cb| {\n        cb.require_equal(\"lt or eq\", sum::expr([lt_expr, eq_expr]),\n        true.expr());\n    });\n    cb.gate(and::expr([\n        meta.query_fixed(q_enable, Rotation::cur()),\n        not::expr(meta.query_advice(is_padding_tx, Rotation::cur())),\n    ]))\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In a valid block, the largest value of tx_id also must be equal to the value of cum_num_txs. Currently, there is no constraint which ensures this."
      }
    ],
    "impact": "The cum_num_txs value can be set to be much larger than the actual set of tx_ids.",
    "recommendation": "We recommend adding a constraint to check that the tx_id of the last non-padding transaction in the Tx Circuit is equal to the cum_num_txs.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Multiple RLP encodings share the same RLC value",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "TOB-SCROLL2-1.30",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "The value of a RLP Tag is calculated using the Random Linear Combination (RLC) of it's constituent bytes. The formula to calculate this is bytes_rlc(i+1) == bytes_rlc(i) * r + byte_value(i+1) where r is the challenge value used to calculate the RLC."
      },
      {
        "type": "text",
        "text": "One issue with this formula is that one can prepend a tag with a arbitrary number of zeroes, and this won't change the value of the RLC calculated. This means that in the context of the circuit: RLP([0x00, 0xff]) == RLP([0x00, 0x00, 0xff])."
      }
    ],
    "impact": "This allows an adversary to add zero bytes to existing fields in a RLP encoded signing data for a transaction without changing the RLCed value in the circuit.",
    "recommendation": "We recommend adding a additional column, tag_length, which contains the number of bytes in a RLP Tag. The combination of (bytes_rlc, tag_length) will always correspond to unique RLP tags.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll%20zkEVM%20circuits-%20KALOSxZellic-%20Part%202%20-%20Audit%20Report.pdf"
    }
  },
  {
    "title":"Poseidon Hash's outputs are taken from capacity",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/poseidon-circuit/",
        "commit_hash": "poseidon-circuit: e51701111f24c32405248a2e5beb85ef2218c726"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: f3ebc6af0e5049d2f45259ef79741f9c7d7794e1"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Cryptography",
    "finding_id": "ZELLIC-SCROLL-3.1",
    "target_file": "Poseidon Circuit, src/hash.rs",
    "content": [
      {
        "type": "text",
        "text": "Sponge-based hash functions are based on (disregarding padding for brevity):\n‚Ä¢ A state of t = r + c field elements\n‚Ä¢ A permutation œÄ on F^t_p"
      },
      {
        "type": "text",
        "text": "To hash the input, the state is initialized to zero and the input is first divided into chunks of r elements. Then the inputs are repeatedly fed into the first r elements of the state, then a permutation is applied. This continues until the input is fully incorporated. Then, until the output is fully retrieved, the first r elements of the state are taken out, applying the permutation if the output is not full yet."
      },
      {
        "type": "text",
        "text": "However, in this implementation of Poseidon, which uses t = 3, r = 2, c = 1 with the output being a single field element, takes the said output from the capacity, i.e. the last c = 1 element, rather than from the rate, i.e. the first r elements."
      }
    ],
    "impact": "The construction of the hash does not match the definition of the sponge-based hash construction. Therefore, the implemented Poseidon hash function may not directly benefit from the previous cryptanalysis of Poseidon and other sponge-based hash functions.",
    "recommendation": "More research on the security of the Poseidon hash when the outputs are taken from the capacity, as well as research on how other projects have implemented the Poseidon hash should be conducted. We note that the permutation used for the sponge is up to specification.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf"
    }
  },
  {
    "title":"mpt_only being true leads to overconstrained circuits",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/poseidon-circuit/",
        "commit_hash": "poseidon-circuit: e51701111f24c32405248a2e5beb85ef2218c726"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: f3ebc6af0e5049d2f45259ef79741f9c7d7794e1"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf",
    "severity": "High",
    "difficulty": "Low",
    "type": "Overconstrained Circuits",
    "finding_id": "ZELLIC-SCROLL-3.2",
    "target_file": "Poseidon Circuit, src/hash.rs",
    "content": [
      {
        "type": "text",
        "text": "The Poseidon table supports two modes of hashing - a MPT mode for hashing two field elements, and a Variable Length mode for hashing arbitrary length inputs. The SpongeChip gets mpt_only as an struct element, which denotes whether the chip will be purely used for MPT purposes."
      },
      {
        "type": "text",
        "text": "Depending on whether mpt_only is true, the custom rows padded at the beginning of the table changes. If it's true, there is only one custom row filled with zeroes. If not, there are two rows, with one additional row representing a hash of an empty message."
      },
      {
        "type": "text",
        "text": "However, due to incorrect ordering of logic, the custom gate is enabled in not only offset 0, but also offset 1."
      },
      {
        "type": "code",
        "code": "config.s_custom.enable(region, 1)?;\nif self.mpt_only {\n    return Ok(1);\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "This means that the selector is incorrectly enabled on offset 1."
      }
    ],
    "impact": "The fact that a certain row is a custom row is represented with a selector, and it is constrained that a custom row should have 0 as the hash inputs and control value.\n\nmeta.create_gate(\"custom row\", |meta| {\n    let s_enable = meta.query_selector(s_custom);\n    vec![\n        s_enable.clone() * meta.query_advice(hash_inp[0], Rotation::cur()),\n        s_enable.clone() * meta.query_advice(hash_inp[1], Rotation::cur()),\n        s_enable * meta.query_advice(control, Rotation::cur()),\n    ]\n});\n\nIn the case where mpt_only is true, the values of hash_inp[0], hash_inp[1] in offset 1 are the first two field elements that are used for hashing. Since these two values are overconstrained to be equal to 0, any hashing attempt with the two input values not equaling 0 will fail the ZKP verification. However, we did not find an instance where mpt_only is true in our current audit scope.",
    "recommendation": "Change the order of the two logic, as follows.\n\nif self.mpt_only {\n    return Ok(1);\n}\nconfig.s_custom.enable(region, 1)?;",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf"
    }
  },
  {
    "title":"padding_shift is underconstrained in the bytecode circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/poseidon-circuit/",
        "commit_hash": "poseidon-circuit: e51701111f24c32405248a2e5beb85ef2218c726"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: f3ebc6af0e5049d2f45259ef79741f9c7d7794e1"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "ZELLIC-SCROLL-3.3",
    "target_file": "Bytecode Circuit, zkevm-circuits/src/bytecode_circuit/to_poseidon_hash.rs",
    "content": [
      {
        "type": "text",
        "text": "To apply the Poseidon hash to the bytecode, a circuit is required to:\n‚Ä¢ put together 31 bytes into a field element\n‚Ä¢ take two field elements and put it into a Poseidon width"
      },
      {
        "type": "text",
        "text": "For the first part, the constraint system is set roughly as follows.\n‚Ä¢ If it is the 31st byte or the very last byte, it is a \"field border\"\n‚Ä¢ The field_input column accumulates the bytes into a field element, i.e. field_input = byte * padding_shift if is_field_border_prev else field_input_prev + byte * padding_shift\n‚Ä¢ The padding_shift is the powers of 256, i.e. if not is_field_border_prev padding_shift = padding_shift_prev / 256\n‚Ä¢ If it is the 31st byte, the padding_shift = 1"
      },
      {
        "type": "text",
        "text": "The last constraint is not enough, as we also need to constrain padding_shift = 1 also when it is the very last byte, or at least have some way to constrain padding_shift for the last chunk of the bytecode, which might not be exactly 31 bytes."
      },
      {
        "type": "text",
        "text": "This vulnerability can be verified by modifying assign_extended_row and unroll_to_hash_input so that the padding_shift values for the last chunk of the bytecode is modified."
      },
      {
        "type": "code",
        "code": "let bytes_in_field_index_inv_f\n= F::from((BYTES_IN_FIELD - bytes_in_field_index) as u64)\n.invert()\n.unwrap_or(F::zero());\nlet mut padding_shift_f = F::from(256 as u64)\n.pow_vartime([(BYTES_IN_FIELD - bytes_in_field_index) as u64]);\nlet vuln = F::from(13371337 as u64);\nif code_index / 31 == code_length / 31 {\n    padding_shift_f = padding_shift_f * vuln;\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "code",
        "code": "let vuln = F::from(13371337 as u64);\nlet (msgs, _) = code\n.chain(std::iter::repeat(0))\n.take(fl_cnt * BYTES_IN_FIELD)\n.fold((Vec::new(), Vec::new()), |(mut msgs, mut cache), bt| {\n    cache.push(bt);\n    if cache.len() == BYTES_IN_FIELD {\n        let mut buf: [u8; 64] = [0; 64];\n        U256::from_big_endian(&cache).to_little_endian(&mut\n        buf[0..32]);\n        let ret = F::from_bytes_wide(&buf);\n        if msgs.len() == fl_cnt - 1 {\n            msgs.push(ret * vuln);\n        }\n        else {\n            msgs.push(F::from_bytes_wide(&buf));\n        }\n        cache.clear();\n    }\n    (msgs, cache)\n});",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "As of now, the padding_shift for the very last byte is not constrained at all, unless the length of the bytecode is a multiple of 31. By setting padding_shift for the last byte appropriately, the last field element for the Poseidon hash can be set to any field element. For example, this may lead to two different bytecodes hashing to the same field element.",
    "recommendation": "We recommend to add a constraint to the padding_shift for the last chunk of the bytecode.\n\nWe note that constraining padding_shift = 1 when it is the field border leads to different field values being mapped for the final chunk of the bytecode than the current implementation. For example, the final chunk of 0x01 will map to 1, rather than the current implementation's value of pow(256, 30).",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Missing range checks in MulAdd chip",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/poseidon-circuit/",
        "commit_hash": "poseidon-circuit: e51701111f24c32405248a2e5beb85ef2218c726"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: f3ebc6af0e5049d2f45259ef79741f9c7d7794e1"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "ZELLIC-SCROLL-3.4",
    "target_file": "MulAdd Chip, gadgets/src/mul_add.rs",
    "content": [
      {
        "type": "text",
        "text": "The MulAdd chip checks the following relation: a * b + c = d (mod 2^256). To perform this calculation, the chip has to break up each number into smaller pieces (limbs) which vary in size from 64-bit to 128-bit. There are also auxillary elements in the chip used for carry where each limb is constrained to be 8-bit in size."
      },
      {
        "type": "text",
        "text": "As the field-element size in Halo2 is 254 bit, each of these limbs must have additional range checks to ensure that these limbs are properly constructed. Currently, there are no range checks on any of the individual elements used in the MulAdd chip."
      },
      {
        "type": "text",
        "text": "Following is a list of elements used by the circuits and the appropriate ranges checks that need to be performed:\n‚Ä¢ a_limb0 - a_limb3: [0, 2^64)\n‚Ä¢ b_limb0 - b_limb3: [0, 2^64)\n‚Ä¢ c_lo, c_hi: [0, 2^128)\n‚Ä¢ d_lo, d_hi: [0, 2^128)\n‚Ä¢ carry_lo0 - carry_lo8: [0, 2^8)\n‚Ä¢ carry_hi0 - carry_hi8: [0, 2^8)"
      }
    ],
    "impact": "By allowing values beyond the intended range into these elements, one can pass the constraints used in the MulAdd chip with incorrect values.\n\nAs an example, one of the constraints checked in the chip is:\nt‚ÇÄ = a‚ÇÄ ¬∑ b‚ÇÄ\nt‚ÇÅ = a‚ÇÄb‚ÇÅ + a‚ÇÅb‚ÇÄ\nt‚ÇÄ + t‚ÇÅ2^64 + c_lo = d_lo + carry_lo2^128\n\nWithout the proper range checks on carry_lo, one can generate a fake proof for any values of a, b, c and d by calculate and assigning the appropriate value to the limbs of carry_lo.",
    "recommendation": "We recommend using the RangeCheckGadget to constrain the elements used in the chip to their expected values as mentioned above.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Incorrect calculation of overflow value in MulAdd chip",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/poseidon-circuit/",
        "commit_hash": "poseidon-circuit: e51701111f24c32405248a2e5beb85ef2218c726"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: f3ebc6af0e5049d2f45259ef79741f9c7d7794e1"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf",
    "severity": "Low",
    "difficulty": "Low",
    "type": "Coding Mistakes",
    "finding_id": "ZELLIC-SCROLL-3.5",
    "target_file": "MulAdd Chip, gadgets/src/mul_add.rs",
    "content": [
      {
        "type": "text",
        "text": "The MulAdd chip has an additional output which calculates if there was any overflow in the calculation of a * b + c:"
      },
      {
        "type": "code",
        "code": "overflow = carry_hi_expr.clone()\n+ a_limbs[1].clone() * b_limbs[3].clone()\n+ a_limbs[2].clone() * b_limbs[2].clone()\n+ a_limbs[3].clone() * b_limbs[2].clone()\n+ a_limbs[2].clone() * b_limbs[3].clone()\n+ a_limbs[3].clone() * b_limbs[2].clone()\n+ a_limbs[3].clone() * b_limbs[3].clone();",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The actual formula to calculate this value is\n(a1b3 + a2b2 + a3b1) + (a2b3 + a3b2) ‚àó 2^64 + (a3b3) ‚àó 2^128"
      },
      {
        "type": "text",
        "text": "In the implementation, the third term is written as a3 ‚àó b2 when it should be a3 ‚àó b1"
      }
    ],
    "impact": "Within the zkevm circuits, the overflow parameter is only used in exp_circuit.rs as a parity check mul gadget. There, the overflow is tested to be either zero or non-zero. As the mistake in the implementation only affects the correctness of the value of the overflow, there is no security impact.\n\nIn the future, if the exact value of the overflow is used as part of another circuit, this may cause correctness issues.",
    "recommendation": "To fix the mistake the implementation of overflow calculation.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf"
    }
  },
  {
    "title":"ExpCircuit has a under-constrained exponentiation algorithm",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/poseidon-circuit/",
        "commit_hash": "poseidon-circuit: e51701111f24c32405248a2e5beb85ef2218c726"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: f3ebc6af0e5049d2f45259ef79741f9c7d7794e1"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "ZELLIC-SCROLL-3.6",
    "target_file": "ExpCircuit, zkevm-circuits/src/exp-circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The ExpCircuit is used to calculate and check the results of the EXP opcode from the EVM. Using the variables from the implementation, the following formula is checked:\nbase^exponent = exponentiation (mod 2^256)"
      },
      {
        "type": "text",
        "text": "The circuit calculates the result using the exponentiation by squaring method. A pseudo-code of the algorithm is as follows:"
      },
      {
        "type": "code",
        "code": "# MulAdd(a, b, c) = a * b + c = d\nif is_odd(exponent):\n    constrain: MulAdd(2, exponent/2, 1) => exponent'\n    result' = result * base\nelse:\n    constrain: MulAdd(2, exponent, 0) => exponent\n    result' = result * result",
        "language": "python",
        "description": ""
      },
      {
        "type": "text",
        "text": "When the parity check on the exponent is odd, there are no checks to ensure that the previous exponent was even. However, this is not an security issue as it only effects the efficiency of the algorithm but not the correctness."
      },
      {
        "type": "text",
        "text": "For the case when the exponent is even, there are no constraint checks on the first argument to the MulAdd chip to ensure that a = 2. With a specific assignment of witness values, a malicious prover can prove the calculation of a incorrect exponentiation from the circuit."
      }
    ],
    "impact": "An example of a malicious witness assignment for the ExpTable can be seen below:\n\nbase exp res p_a p_b p_c p_d m_a m_b m_d\n5 12 15625 1 11 1 12 3125 5 15625\n5 11 3125 1 10 1 11 625 5 3125\n5 10 625 5 2 0 10 25 25 625\n5 2 25 5 5 25\n\nThe column exp denotes the running exponent value and the column res represents the running value of exponentiation.\n\nHere, we can see that an attacker can incorrectly calculate the result that 5^12 = 15625 due to the under-constrained circuits.",
    "recommendation": "We recommend adding a constraint to check that the first argument to the parity check MulAdd gadget is 2 when the parity is even (c = 0).",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Bytecode Tag should be constrained to a boolean in BytecodeCircuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/poseidon-circuit/",
        "commit_hash": "poseidon-circuit: e51701111f24c32405248a2e5beb85ef2218c726"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: f3ebc6af0e5049d2f45259ef79741f9c7d7794e1"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf",
    "severity": "Low",
    "difficulty": "Low",
    "type": "Underconstrained Circuits",
    "finding_id": "ZELLIC-SCROLL-3.7",
    "target_file": "Bytecode Circuit, zkevm-circuits/src/circuits.rs",
    "content": [
      {
        "type": "text",
        "text": "The tag value in the BytecodeTable is used to determine whether a byte is a header (tag = 0) or code (tag = 1). This tag is used in selectors such as is_header and is_byte to enable or disable certain constraints."
      },
      {
        "type": "text",
        "text": "These selectors make use of boolean expressions such as and::expr, or::expr and not::expr applied on the tag column and other selector columns. These expressions have the invariant that the inputs to these must be either 0 or 1. If that is not the case, it can lead to unintended results."
      },
      {
        "type": "text",
        "text": "The is_header selector is calculated as not(tag):"
      },
      {
        "type": "code",
        "code": "let is_header = |meta: &mut VirtualCells<F>| {\n    not::expr(meta.query_advice(bytecode_table.tag, Rotation::cur()))\n};\n\npub mod not {\n    ///>) Returns an expression that represents the NOT of the given\n    /// expression.\n    pub fn expr<F: FieldExt, E: Expr<F>>(b: E) -> Expression<F> {\n        1.expr() - b.expr()\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In the normal usecase, is_header is true/non-zero when tag = 0. However, if the value of tag is 2, then is_header is also non-zero and it acts as true."
      },
      {
        "type": "text",
        "text": "Another unintended result happens when these selectors are multiplied with actual witness values as in the case of lookups:"
      },
      {
        "type": "code",
        "code": "meta.lookup_any(\n    \"push_data_size_table_lookup(cur.value, cur.push_data_size)\",\n    |meta| {\n        let enable = and::expr(vec![\n            // ...)\n            is_byte(meta),\n        ]);\n        // ...)\n        for i in 0..PUSH_TABLE_WIDTH {\n            constraints.push((\n                enable.clone() * meta.query_advice(lookup_columns[i],\n                Rotation::cur()),\n                meta.query_fixed(push_table[i], Rotation::cur()),\n            ))\n        }\n    },\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The is_byte expression directly uses the value of the tag, so we can control the value of enable to be arbitrary. This allows us to assign any value we want to the first column of the lookup query, which will allow us to bypass the lookup check."
      }
    ],
    "impact": "In the case of the bytecode circuit, we were unable to find any particular way to make invalid bytecode pass the constraints because of the large number of constraints on each row.",
    "recommendation": "As a proactive measure, we recommend using the require_boolean constraint to ensure that the value of bytecode_table.tag is 0 or 1, as it violates the invariants expected by the boolean expressions used in the selectors.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Redundant boolean constraint in Batched IsZero",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/poseidon-circuit/",
        "commit_hash": "poseidon-circuit: e51701111f24c32405248a2e5beb85ef2218c726"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: f3ebc6af0e5049d2f45259ef79741f9c7d7794e1"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Overconstrained Circuits",
    "finding_id": "ZELLIC-SCROLL-3.8",
    "target_file": "BatchedIsZeroChip, gadgets/src/batched_is_zero.rs",
    "content": [
      {
        "type": "text",
        "text": "The BatchedIsZero chip takes in as input a list of values and a nonempty_witness and sets the is_zero to be 1 if all the input values are zero, and 0 otherwise."
      },
      {
        "type": "text",
        "text": "Currently, there is a constraint that checks that the value of is_zero is a boolean, i.e it is 0 or 1. We show that it is not necessary to have this constraint as it is implicitly checked by the other two constraints in the chip."
      },
      {
        "type": "text",
        "text": "1. is_zero is 0 if there is any non-zero value: This constraint multiplies is_zero with all the values, and ensures that all the results are 0. If there is any non-zero value, then is_zero must be 0, or else this constraint will fail.\n2. is_zero is 1 if values are all zero: This constraint calculates (1 - is_zero) * PROD(1 - value * nonzero_witness). We know from the previous constraint that if there are any non-zero values, then is_zero must be equal to 0. This means that all the values are 0, and the terms in the product evaluate to 1. Therefore, the only possible value for is_zero which satisfies the constraint is 1."
      },
      {
        "type": "text",
        "text": "This shows that the value of is_zero can only be 0/1 based on the two constraints mentioned above."
      }
    ],
    "impact": "This is not a security issue. The redundant constraint only adds additional overhead to the circuit.",
    "recommendation": "We suggest removing this redundant constraint to reduce the total number of constraints, but we also understand if you would like to keep this constraint to maintain the clarity of the circuit implementation.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Redundant boolean constraint in Exponentiation Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/poseidon-circuit/",
        "commit_hash": "poseidon-circuit: e51701111f24c32405248a2e5beb85ef2218c726"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: f3ebc6af0e5049d2f45259ef79741f9c7d7794e1"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Overconstrained Circuits",
    "finding_id": "ZELLIC-SCROLL-3.9",
    "target_file": "ExpCircuit, zkevm-circuits/src/exp-circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "There is a constraint in the ExpCircuit which ensures that the columns is_step is always boolean."
      },
      {
        "type": "code",
        "code": "// is_step is boolean.\ncb.require_boolean(\n    \"is_step is boolean\",\n    meta.query_fixed(exp_table.is_step, Rotation::cur()),\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "is_step is a Fixed Column whose values cannot be changed during witness synthesis and proving. Thus, this constraint is redundant and can be removed."
      }
    ],
    "impact": "This is not a security issue. The redundant constraint only adds additional overhead to the circuit.",
    "recommendation": "We recommend removing this prover time constraint and instead adding a assert to ensure that the correct values are assigned to the is_step column during circuit compilation.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Non-trivial rotation incorrectly handled in ComparatorChip",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/poseidon-circuit/",
        "commit_hash": "poseidon-circuit: e51701111f24c32405248a2e5beb85ef2218c726"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: f3ebc6af0e5049d2f45259ef79741f9c7d7794e1"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf",
    "severity": "Medium",
    "difficulty": "Low",
    "type": "Coding Mistakes",
    "finding_id": "ZELLIC-SCROLL-3.10",
    "target_file": "gadgets/src/comparator.rs",
    "content": [
      {
        "type": "text",
        "text": "The expr function returns the Expression<F> for whether lhs < rhs or lhs == rhs on the rotation."
      },
      {
        "type": "code",
        "code": "impl<F: Field, const N_BYTES: usize> ComparatorConfig<F, N_BYTES> {\n    ///>) Returns (lt, eq) for a comparison between lhs and rhs.\n    pub fn expr(\n        &self,\n        meta: &mut VirtualCells<F>,\n        rotation: Option<Rotation>,\n    ) -> (Expression<F>, Expression<F>) {\n        (\n            self.lt_chip.config.is_lt(meta, rotation),\n            self.eq_chip.config.is_equal_expression.clone(),\n        )\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "It can be seen that the eq_chip result doesn't handle the rotation at all - so incorrect results will be returned for non-trivial rotation."
      }
    ],
    "impact": "In the case where the eq_chip result is used for incorrect rotation, incorrect Expression<F> will be used.",
    "recommendation": "We recommend either fixing the implementation of expr, or thoroughly checking and documenting the fact that the latter eq_chip result should not be used for a non-trivial rotation.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Field representation dependent implementation in LtChip",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/poseidon-circuit/",
        "commit_hash": "poseidon-circuit: e51701111f24c32405248a2e5beb85ef2218c726"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: f3ebc6af0e5049d2f45259ef79741f9c7d7794e1"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Coding Mistakes",
    "finding_id": "ZELLIC-SCROLL-3.11",
    "target_file": "gadgets/src/less_than.rs",
    "content": [
      {
        "type": "text",
        "text": "The assignment logic in the LtChip assumes that the field's to_repr returns a little-endian representation."
      },
      {
        "type": "code",
        "code": "let diff = (lhs - rhs) + (if lt { config.range } else { F::zero() });\nlet diff_bytes = diff.to_repr();\nfor (idx, diff_column) in config.diff.iter().enumerate() {\n    region.assign_advice(\n        || format!(\"lt chip: diff byte {}\", idx),\n        *diff_column,\n        offset,\n        || Value::known(F::from(diff_bytes[idx] as u64)),\n    )?;\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "However, it is documented that the endianness is implementation specific."
      },
      {
        "type": "code",
        "code": "///>) Converts an element of the prime field into the standard byte\n/// representation for\n///>) this field.\n///)\n///>) The endianness of the byte representation is implementation-specific.\n/// Generic\n///>) encodings of field elements should be treated as opaque.\nfn to_repr(&self) -> Self::Repr;",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "The current implementation cannot be used for fields or field implementations that return big-endian bytes.",
    "recommendation": "We recommend either fixing the implementation, or documenting this finding.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "05/16/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Audit_Report.pdf"
    }
  },
  {
    "title":"RLP Circuit data table's byte_rev_idx is underconstrained",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Medium",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.1",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "The RlpFsmDataTable consists of seven advice columns and aims to map (tx_id, format, byte_idx) to (byte_rev_idx, byte_value, bytes_rlc, gas_cost_acc)."
      },
      {
        "type": "code",
        "code": "///)) Data table allows us a lookup argument from the RLP circuit to check\n///)) the byte value at an index\n///)) while decoding a tx of a given format.\n#)derive(Clone, Copy, Debug)]\npub struct RlpFsmDataTable {\n///)) Transaction index in the batch of txs.\npub tx_id: Column<Advice>,\n///)) Format of the tx being decoded.\npub format: Column<Advice>,\n///)) The index of the current byte.\npub byte_idx: Column<Advice>,\n///)) The reverse index at this byte.\npub byte_rev_idx: Column<Advice>,\n///)) The byte value at this index.\npub byte_value: Column<Advice>,\n///)) The accumulated Random Linear Combination up until (including) the\ncurrent byte.\npub bytes_rlc: Column<Advice>,\n///)) The accumulated gas cost up until (including) the current byte.\npub gas_cost_acc: Column<Advice>,\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "There are various checks on this table, and one of them specifies what should happen when the instance (tx_id, format) changes."
      },
      {
        "type": "code",
        "code": "/) if (tx_id' =) tx_id and format' !) format) or (tx_id' !) tx_id and\ntx_id' !) 0)\ncb.condition(\n    sum:)expr([\n        /) case 1\n        and:)expr([\n            tx_id_check_in_dt.is_equal_expression.expr(),\n            not:)expr(format_check_in_dt.is_equal_expression.expr()),\n        ]),\n        /) case 2\n        and:)expr([\n            not:)expr(is_padding_in_dt.expr(Rotation:)next())(meta)),\n            not:)expr(tx_id_check_in_dt.is_equal_expression.expr()),\n        ]),\n    ]),\n    |cb| {\n        /) byte_rev_idx =) 1\n        cb.require_equal(\n            \"byte_rev_idx is 1 at the last index\",\n            meta.query_advice(data_table.byte_rev_idx, Rotation:)cur()),\n            1.expr(),\n        );\n        /) byte_idx' =) 1\n        cb.require_equal(\n            \"byte_idx resets to 1 for new format\",\n            meta.query_advice(data_table.byte_idx, Rotation:)next()),\n            1.expr(),\n        );\n        /) bytes_rlc' =) byte_value'\n        cb.require_equal(\n            \"bytes_value and bytes_rlc are equal at the first index\",\n            meta.query_advice(data_table.byte_value, Rotation:)next()),\n            meta.query_advice(data_table.bytes_rlc, Rotation:)next()),\n        );\n    },\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "Here, in the case where tx_id' =) tx_id and format' !) format, or tx_id' !) tx_id and tx_id' !) 0, it is constrained that the current byte_rev_idx should be 1. However, this condition misses the final byte of the final transaction ID, where tx_id' !) tx_id and tx_id' =) 0 as the next transaction is a padding. This implies that the final byte of the final transaction ID may not have byte_rev_idx =) 1, breaking the desired properties over the byte_rev_idx for the entire final transaction ID."
      }
    ],
    "impact": "The RlpFsmDataTable is used for a lookup, and this byte_rev_idx is also used later for various constraints. Using potentially incorrect values for byte_rev_idx may lead to further issues.",
    "recommendation": "The condition can be simply modified to tx_id' =) tx_id and format' !) format, or tx_id' !) tx_id.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Missing range check for byte values in RLP Circuit ",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.2",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "There is a check for the byte_value in the data table to be within a byte range."
      },
      {
        "type": "code",
        "code": "meta.lookup_any(\"byte value check\", |meta| {\n    let cond = and:)expr([\n        meta.query_fixed(q_enabled, Rotation:)cur()),\n        is_padding_in_dt.expr(Rotation:)cur())(meta),\n    ]);\n    vec![meta.query_advice(data_table.byte_value, Rotation:)cur())]\n    .into_iter()\n    .zip(range256_table.table_exprs(meta).into_iter())\n    .map(|(arg, table)| (cond.expr() * arg, table))\n    .collect()\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "However, with the condition applied, it actually only checks that the padding rows have byte_value within the byte range. This means that the actual data rows' byte_values are never range checked properly."
      }
    ],
    "impact": "The byte_values are never range checked to be within [0, 256) range, which is a needed check.",
    "recommendation": "Change the condition to\nlet cond = and:)expr([\n    meta.query_fixed(q_enabled, Rotation:)cur()),\n    not:)expr(is_padding_in_dt.expr(Rotation:)cur())(meta)),\n]);",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
    {
    "title":"The tag_length is never checked to be no more than max_length",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Medium",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.3",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "The max_length is used to define the maximum length of each tag, and it is also used to decide the base to use to accumulate the byte values. However, there is no check that the tag_length is no more than max_length."
      }
    ],
    "impact": "The tag_length may be over max_length ‚Äî so inputs that do not fit the desired specifications may pass all the constraints in the circuit.",
    "recommendation": "We recommend to add a constraint that checks tag_length <= max_length.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Missing range checks for the LtChip",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.4",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs, Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The LtChip itself does not constrain that the diff columns are within the byte range and delegates this check to the circuits using this chip."
      },
      {
        "type": "code",
        "code": "///)) Config for the Lt chip.\n#)derive(Clone, Copy, Debug)]\npub struct LtConfig<F, const N_BYTES: usize> {\n///)) Denotes the lt outcome. If lhs < rhs then lt =) 1, otherwise lt =)\n0.\npub lt: Column<Advice>,\n///)) Denotes the bytes representation of the difference between lhs and\nrhs.\n///)) Note that the range of each byte is not checked by this config.\npub diff: [Column<Advice>; N_BYTES],\n///)) Denotes the range within which both lhs and rhs lie.\npub range: F,\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "However, this is missing in the RLP circuits."
      },
      {
        "type": "text",
        "text": "For the ComparatorConfig, it is also important to check that the left hand side and the right hand side are all within the specified range."
      },
      {
        "type": "code",
        "code": "///)) Tx id must be no greater than cum_num_txs\ntx_id_cmp_cum_num_txs: ComparatorConfig<F, 2>,",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "Therefore, in the Tx Circuit, it should be checked that tx_id and cum_num_txs are within 16 bits."
      }
    ],
    "impact": "The missing range check on diff breaks the functionalities of the LtChip, so using LtChip does not actually constrain the comparison properly.",
    "recommendation": "We recommend to add the needed range checks for safe usage of the comparison gadgets.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Missing check in the initialization on the state machine in RLP Circuit",
    "source":"Zellic Inc. x KALOS",
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.5",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "In the RLP state machine initialization, the byte_idx is checked to be 1, and the tag is checked to be either TxType or BeginList."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"sm init\", |meta| {\n    let mut cb = BaseConstraintBuilder:)default();\n    let tag = tag_expr(meta);\n    constrain_eq!(meta, cb, byte_idx, 1.expr());\n    cb.require_zero(\n        \"tag =) TxType or tag =) BeginList\",\n        (tag.expr() - TxType.expr()) * (tag - BeginList.expr()),\n    );\n    cb.gate(meta.query_fixed(q_first, Rotation:)cur()))\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "There is a missing check that the initial state should be DecodeTagStart."
      },
      {
        "type": "text",
        "text": "There is also no check that the initial tx_id is 1."
      }
    ],
    "impact": "This missing check allows us to start the decoding with states like Bytes. This may potentially lead to allowing invalid RLP decodings.",
    "recommendation": "We recommend to implement a check that the initial state is DecodeTagStart and that the initial tx_id is 1.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Transition to new RLP instance in the state machine is underconstrained in RLP Circuit",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.6",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "In the state machine, in the case where depth == 1, state' != End, and is_tag_end == True, the machine regards this as the transition between two RLP instances. It then constrains that the"
      },
      {
        "type": "text",
        "text": "‚Ä¢ next byte_idx is 1,\n‚Ä¢ next depth is 0, and\n‚Ä¢ next state is DecodeTagStart"
      },
      {
        "type": "text",
        "text": "as well as that either tx_id' = tx_id + 1 or format' = format + 1."
      },
      {
        "type": "text",
        "text": "It also constrains the tag_next column of the current row to be either TxType or BeginList."
      },
      {
        "type": "code",
        "code": "cb.condition(\n    meta.query_advice(transit_to_new_rlp_instance, Rotation:)cur()),\n    |cb| {\n        let tx_id = meta.query_advice(rlp_table.tx_id, Rotation:)cur());\n        let tx_id_next = meta.query_advice(rlp_table.tx_id,\n        Rotation:)next());\n        let format = meta.query_advice(rlp_table.format,\n        Rotation:)cur());\n        let format_next = meta.query_advice(rlp_table.format,\n        Rotation:)next());\n        let tag_next = tag_next_expr(meta);\n        /) state transition.\n        update_state!(meta, cb, byte_idx, 1);\n        update_state!(meta, cb, depth, 0);\n        update_state!(meta, cb, state, DecodeTagStart);\n        cb.require_zero(\n            \"(tx_id' =) tx_id + 1) or (format' =) format + 1)\",\n            (tx_id_next - tx_id - 1.expr()) * (format_next - format\n            - 1.expr()),\n        );\n        cb.require_zero(\n            \"tag =) TxType or tag =) BeginList\",\n            (tag_next.expr() - TxType.expr())\n            * (tag_next.expr() - BeginList.expr()),\n        );\n    },\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "There are two issues. First, the constraint on (tx_id', format') is weak, as it allows cases like (tx_id', format') = (tx_id - 1, format + 1). The constraint on tag_next is also weak, as there are no constraints on the next offset's tag ‚Äî it should constrain that tag' is either TxType or BeginList instead."
      }
    ],
    "impact": "This underconstraint may allow the same transaction to appear twice in the state machine and the first tag for a new RLP instance to not be equal to TxType or BeginList.",
    "recommendation": "We recommend to implement proper checks for (tx_id', format') as well as tag' for the transition.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Equality between tag_value and the final tag_value_acc not checked",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.7",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "In the Bytes state in the state machine, the byte values are accumulated over a column tag_value_acc. The final value of this tag_value_acc is the actual tag_value, which should be stored in the table for other use. However, in the Bytes => DecodeTagStart case where tag_index = tag_length, there is no check that tag_value = tag_value_acc."
      },
      {
        "type": "code",
        "code": "/) Bytes => DecodeTagStart\ncb.condition(tidx_eq_tlen, |cb| {\n    /) assertions\n    emit_rlp_tag!(meta, cb, tag_expr(meta), false);\n    /) state transitions.\n    update_state!(meta, cb, tag, tag_next_expr(meta));\n    update_state!(meta, cb, state, State:)DecodeTagStart);\n    constrain_unchanged_fields!(meta, cb; rlp_table.tx_id,\n    rlp_table.format, depth);\n});",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "Since tag_value is actually not constrained, the value that is actually in the RlpFsmRlpTable is not constrained.",
    "recommendation": "We recommend adding the check that tag_value is equal to tag_value_acc.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Missing do_not_emit! constraints",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.8",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "The do_not_emit! macro is used to force is_output = false. This is used in various places where the current row does not represent a full tag value. However, in the DecodeTagStart => LongList transition, this check is missing."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"state transition: DecodeTagStart => LongList\", |meta| {\n    let mut cb = BaseConstraintBuilder:)default();\n    let (bv_gt_0xf8, bv_eq_0xf8) = byte_value_gte_0xf8.expr(meta, None);\n    let cond = and:)expr([\n        sum:)expr([bv_gt_0xf8, bv_eq_0xf8]),\n        not:)expr(is_tag_end_expr(meta)),\n    ]);\n    cb.condition(cond.expr(), |cb| {\n        /) assertions.\n        constrain_eq!(meta, cb, is_tag_begin, true);\n        /) state transitions\n        update_state!(meta, cb, tag_length, byte_value_expr(meta)\n        - 0xf7.expr());\n        update_state!(meta, cb, tag_idx, 1);\n        update_state!(meta, cb, tag_value_acc,\n        byte_value_next_expr(meta));\n        update_state!(meta, cb, state, State:)LongList);\n        constrain_unchanged_fields!(meta, cb; rlp_table.tx_id,\n        rlp_table.format, tag, tag_next);\n    });\n    cb.gate(and:)expr([\n        meta.query_fixed(q_enabled, Rotation:)cur()),\n        is_decode_tag_start(meta),\n    ]))\n});",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "In this case, the is_output is not constrained to be false, so the RlpFsmRlpTable may have invalid rows with is_output turned on, even though it should be turned off.",
    "recommendation": "We recommend adding a do_not_emit! macro in this case as well.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"The state machine is not constrained to end at End",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.9",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "There are no constraints that the state machine ends with the state End."
      }
    ],
    "impact": "The state machine at the final transaction does not necessarily have to move to the End state. This means that the checks for the Case 4 in the DecodeTagStart => DecodeTagStart case can be potentially skipped ‚Äî which includes the RLC, gas cost, and byte_rev_idx checks.",
    "recommendation": "We recommend adding a fixed column q_last, implementing the assign logic, and adding the constraint that the state is End if q_last is enabled.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Enum definition is inconsistent with the circuit layout",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Code Maturity",
    "finding_id": "SCROLL2-3.10",
    "target_file": "Tx Circuit, witness/tx.rs",
    "content": [
      {
        "type": "text",
        "text": "The Tx Circuit layout is composed of the fixed part with the transaction-related values of fixed size, followed by the dynamic part with the transaction calldata, which is not of fixed size. The layout for the fixed part is shown in the witness/tx.rs file's table_assignments_fixed."
      },
      {
        "type": "code",
        "code": "[\n    Value:)known(F:)from(self.id as u64)),\n    Value:)known(F:)from(TxContextFieldTag:)Nonce as u64)), /) 2\n    Value:)known(F:)zero()),\n    Value:)known(F:)from(self.nonce)),\n],\n[\n    Value:)known(F:)from(self.id as u64)),\n    Value:)known(F:)from(TxContextFieldTag:)Gas as u64)), /) 4\n    Value:)known(F:)zero()),\n    Value:)known(F:)from(self.gas)),\n],\n[\n    Value:)known(F:)from(self.id as u64)),\n    Value:)known(F:)from(TxContextFieldTag:)GasPrice as u64)), /) 3\n    Value:)known(F:)zero()),\n    challenges\n    .evm_word()\n    .map(|challenge| rlc:)value(&self.gas_price.to_le_bytes(),\n    challenge)),\n],\n[\n    Value:)known(F:)from(self.id as u64)),\n    Value:)known(F:)from(TxContextFieldTag:)CallerAddress as u64)), /) 5\n    Value:)known(F:)zero()),\n    Value:)known(self.caller_address.to_scalar().unwrap()),\n],\n...)))",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The issue here is that the order of the enum TxContextFieldTag matches the layout order in the circuit, except for the case of TxContextFieldTag:)Gas and TxContextFieldTag:)GasPrice."
      },
      {
        "type": "text",
        "text": "The usage of the enums as an offset in the circuit can be seen in the circuit logic, as shown below."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"is_padding_tx\", |meta| {\n    let is_tag_caller_addr = is_caller_addr(meta);\n    let mut cb = BaseConstraintBuilder:)default();\n    /) the offset between CallerAddress and BlockNumber\n    let offset = usize:)from(BlockNumber) - usize:)from(CallerAddress);\n    /) if tag =) CallerAddress\n    cb.condition(is_tag_caller_addr.expr(), |cb| {\n        cb.require_equal(\n            \"is_padding_tx = true if caller_address = 0\",\n            meta.query_advice(is_padding_tx, Rotation(offset as i32)),\n            value_is_zero.expr(Rotation:)cur())(meta),\n        );\n    });\n    cb.gate(meta.query_fixed(q_enable, Rotation:)cur()))\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "Therefore, for code quality, it is recommended to keep consistency between the actual offsets in the circuit layout and the TxContextFieldTag enum."
      }
    ],
    "impact": "This is an informational finding with no direct security impact. However, inconsistency between enum definition and actual circuit layout can lead to maintenance issues and potential bugs in the future.",
    "recommendation": "Swap the order of Gas and GasPrice in the layout or the enum so that it is consistent.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"The first row of each Tx in the calldata section is underconstrained in Tx Circuit",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.11",
    "target_file": "Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The Tx Circuit layout's latter part deals with the calldata of each transaction."
      },
      {
        "type": "text",
        "text": "It constrains\n‚Ä¢ is_final is boolean\n‚Ä¢ if is_final is false\n‚Äì index' = index + 1 and tx_id' = tx_id\n‚Äì calldata_gas_cost_acc' = calldata_gas_cost + (value' == 0 ? 4 : 16)\n‚Ä¢ if is_final is true\n‚Äì tx_id' != tx_id"
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"tx call data bytes\", |meta| {\n    let mut cb = BaseConstraintBuilder:)default();\n    let is_final_cur = meta.query_advice(is_final, Rotation:)cur());\n    cb.require_boolean(\"\n    is_final is boolean\n    \", is_final_cur.clone());\n    /) checks for any row, except the final call data byte.\n    cb.condition(not:)expr(is_final_cur.clone()), |cb| {\n        cb.require_equal(\n            \"index:)next =) index:)cur + 1\",\n            meta.query_advice(tx_table.index, Rotation:)next()),\n            meta.query_advice(tx_table.index, Rotation:)cur())\n            + 1.expr(),\n        );\n        cb.require_equal(\n            \"tx_id:)next =) tx_id:)cur\",\n            tx_id_unchanged.is_equal_expression.clone(),\n            1.expr(),\n        );\n        let value_next_is_zero\n        = value_is_zero.expr(Rotation:)next())(meta);\n        let gas_cost_next = select:)expr(value_next_is_zero, 4.expr(),\n        16.expr());\n        /) call data gas cost accumulator check.\n        cb.require_equal(\n            \"calldata_gas_cost_acc:)next =) calldata_gas_cost:)cur +\n            gas_cost_next\",\n            meta.query_advice(calldata_gas_cost_acc, Rotation:)next()),\n            meta.query_advice(calldata_gas_cost_acc, Rotation:)cur())\n            + gas_cost_next,\n        );\n    });\n    /) on the final call data byte, tx_id must change.\n    cb.condition(is_final_cur, |cb| {\n        cb.require_zero(\n            \"tx_id changes at is_final =) 1\",\n            tx_id_unchanged.is_equal_expression.clone(),\n        );\n    });\n    cb.gate(and:)expr(vec![\n        meta.query_fixed(q_enable, Rotation:)cur()),\n        meta.query_advice(is_calldata, Rotation:)cur()),\n        not:)expr(tx_id_is_zero.expr(Rotation:)cur())(meta)),\n    ]))\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The issue here is that there is no constraint for the first row of the new transaction. To be exact, there is no constraint that index = 0 and calldata_gas_cost_acc = (value == 0 ? 4 : 16) for the first row of the transaction."
      }
    ],
    "impact": "The index and calldata_gas_cost can be maliciously changed for the first row, which may lead to the values in the mentioned columns to be incorrect.",
    "recommendation": "We recommend adding the necessary constraints for the first row.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"The sv_address is not constrained to be equal throughout a single transaction",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.12",
    "target_file": "Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The sv_address is intended to be the column representing the signer's address."
      },
      {
        "type": "text",
        "text": "The first constraint on this column is that it is equal to the caller address in the case where the address is nonzero and the transaction type is not L1Msg. Note that this is checked on the offset of CallerAddress."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\n    \"caller address =) sv_address if it's not zero and tx_type !) L1Msg\",\n    |meta| {\n        let mut cb = BaseConstraintBuilder:)default();\n        cb.condition(not:)expr(value_is_zero.expr(Rotation:)cur())(meta)),\n        |cb| {\n            cb.require_equal(\n                \"caller address =) sv_address\",\n                meta.query_advice(tx_table.value, Rotation:)cur()),\n                meta.query_advice(sv_address, Rotation:)cur()),\n            );\n        });\n        cb.gate(and:)expr([\n            meta.query_fixed(q_enable, Rotation:)cur()),\n            meta.query_advice(is_caller_address, Rotation:)cur()),\n            not:)expr(meta.query_advice(is_l1_msg, Rotation:)cur())),\n        ]))\n    },\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The second constraint on this column is the lookup to the sig circuit. This shows that the sv_address is the recovered address from the ECDSA signature. Note that this is checked on the offset of ChainId."
      },
      {
        "type": "code",
        "code": "meta.lookup_any(\"Sig table lookup\", |meta| {\n    let enabled = and:)expr([\n        /) use is_l1_msg_col instead of is_l1_msg(meta) because it has\n        lower degree\n        not:)expr(meta.query_advice(is_l1_msg_col, Rotation:)cur())),\n        /) lookup to sig table on the ChainID row because we have an\n        indicator of degree 1\n        /) for ChainID and ChainID is not far from (msg_hash_rlc, sig_v,\n        /) ...)))\n        meta.query_advice(is_chain_id, Rotation:)cur()),\n    ]);\n    let msg_hash_rlc = meta.query_advice(tx_table.value, Rotation(6));\n    let chain_id = meta.query_advice(tx_table.value, Rotation:)cur());\n    let sig_v = meta.query_advice(tx_table.value, Rotation(1));\n    let sig_r = meta.query_advice(tx_table.value, Rotation(2));\n    let sig_s = meta.query_advice(tx_table.value, Rotation(3));\n    let sv_address = meta.query_advice(sv_address, Rotation:)cur());\n    let v = is_eip155(meta) * (sig_v.expr() - 2.expr() * chain_id\n    - 35.expr())\n    + is_pre_eip155(meta) * (sig_v.expr() - 27.expr());\n    let input_exprs = vec![\n        1.expr(), /) q_enable = true\n        msg_hash_rlc, /) msg_hash_rlc\n        v, /) sig_v\n        sig_r, /) sig_r\n        sig_s, /) sig_s\n        sv_address,\n        1.expr(), /) is_valid\n    ];\n    /) LookupTable:)table_exprs is not used here since `is_valid` not used\n    by evm circuit.\n    let table_exprs = vec![\n        meta.query_fixed(sig_table.q_enable, Rotation:)cur()),\n        /) msg_hash_rlc not needed to be looked up for tx circuit?\n        meta.query_advice(sig_table.msg_hash_rlc, Rotation:)cur()),\n        meta.query_advice(sig_table.sig_v, Rotation:)cur()),\n        meta.query_advice(sig_table.sig_r_rlc, Rotation:)cur()),\n        meta.query_advice(sig_table.sig_s_rlc, Rotation:)cur()),\n        meta.query_advice(sig_table.recovered_addr, Rotation:)cur()),\n        meta.query_advice(sig_table.is_valid, Rotation:)cur()),\n    ];\n    input_exprs\n    .into_iter()\n    .zip(table_exprs.into_iter())\n    .map(|(input, table)| (input * enabled.expr(), table))\n    .collect()\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "The offset of the sv_address that is checked in the two constraints are different, and there are no constraints to enforce that these two sv_address values are equal. In other words, there are no constraints to check that the sv_address value is equal throughout the rows that represent the same transaction."
      }
    ],
    "impact": "An attacker may use different addresses for the caller address and the ECDSA signature's recovered address. Depending on the exact logic of the other circuits, this could lead to arbitrary contract calls without proper ECDSA signatures.",
    "recommendation": "We recommend adding the check that sv_address is equal throughout the rows of the same transaction.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Block number constraints are incorrect in PI circuit",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.13",
    "target_file": "PI Circuit, pi_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The block table is composed of a fixed column tag and advice columns index and value."
      },
      {
        "type": "code",
        "code": "///)) Table with Block header fields\n#)derive(Clone, Debug)]\npub struct BlockTable {\n///)) Tag\npub tag: Column<Fixed>,\n///)) Index\npub index: Column<Advice>,\n///)) Value\npub value: Column<Advice>,\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "Here, the index column is the block number corresponding to the row. The assignments for this table are shown in witness/block.rs."
      },
      {
        "type": "code",
        "code": "[\n    vec![\n        [\n            Value:)known(F:)from(BlockContextFieldTag:)Coinbase as u64)),\n            Value:)known(current_block_number),\n            Value:)known(self.coinbase.to_scalar().unwrap()),\n        ],\n        [\n            Value:)known(F:)from(BlockContextFieldTag:)Timestamp as\n            u64)),\n            Value:)known(current_block_number),\n            Value:)known(self.timestamp.to_scalar().unwrap()),\n        ],\n        [\n            Value:)known(F:)from(BlockContextFieldTag:)Number as u64)),\n            Value:)known(current_block_number),\n            Value:)known(current_block_number),\n        ],\n        [\n            Value:)known(F:)from(BlockContextFieldTag:)Difficulty as\n            u64)),\n            Value:)known(current_block_number),\n            randomness.map(|rand|\n            rlc:)value(&self.difficulty.to_le_bytes(),\n            rand)),\n        ],\n        [\n            Value:)known(F:)from(BlockContextFieldTag:)GasLimit as u64)),\n            Value:)known(current_block_number),\n            Value:)known(F:)from(self.gas_limit)),\n        ],\n        [\n            Value:)known(F:)from(BlockContextFieldTag:)BaseFee as u64)),\n            Value:)known(current_block_number),\n            randomness\n            .map(|randomness|\n            rlc:)value(&self.base_fee.to_le_bytes(),\n            randomness)),\n        ],\n        [\n            Value:)known(F:)from(BlockContextFieldTag:)ChainId as u64)),\n            Value:)known(current_block_number),\n            Value:)known(F:)from(self.chain_id)),\n        ],\n        [\n            Value:)known(F:)from(BlockContextFieldTag:)NumTxs as u64)),\n            Value:)known(current_block_number),\n            Value:)known(F:)from(num_txs as u64)),\n        ],\n        [\n            Value:)known(F:)from(BlockContextFieldTag:)CumNumTxs as\n            u64)),\n            Value:)known(current_block_number),\n            Value:)known(F:)from(cum_num_txs as u64)),\n        ],\n    ],\n    self.block_hash_assignments(randomness),\n]",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "To constrain the block number, two checks are needed.\n‚Ä¢ The index values for these rows are equal.\n‚Ä¢ The index value is equal to the value column's value in the BlockContextFieldTag:)Number row."
      },
      {
        "type": "text",
        "text": "However, this is incorrectly done."
      },
      {
        "type": "code",
        "code": "for (row, tag) in block_ctx\n.table_assignments(num_txs, cum_num_txs, challenges)\n.into_iter()\n.zip(tag.iter())\n{\n    region.assign_fixed(\n        |) format!(\"block table row {offset}\"),\n        self.block_table.tag,\n        offset,\n        |) row[0],\n    )?;\n    /) index_cells of same block are equal to block_number.\n    let mut index_cells = vec![];\n    let mut block_number_cell = None;\n    for (column, value) in block_table_columns.iter().zip_eq(&row[1.)]) {\n        let cell = region.assign_advice(\n            |) format!(\"block table row {offset}\"),\n            *column,\n            offset,\n            |) *value,\n        )?;\n        if *tag =) Number &) *column =) self.block_table.value {\n            block_number_cell = Some(cell.clone());\n        }\n        if *column =) self.block_table.index {\n            index_cells.push(cell.clone());\n        }\n        if *column =) self.block_table.value {\n            block_value_cells.push(cell);\n        }\n    }\n    for i in 0.)(index_cells.len() - 1) {\n        region.constrain_equal(index_cells[i].cell(), index_cells[i\n        + 1].cell())?;\n    }\n    if *tag =) Number {\n        region.constrain_equal(\n            block_number_cell.unwrap().cell(),\n            index_cells[0].cell(),\n        )?;\n    }\n    ...)))\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "Here, the index_cells array and block_number_cell is taken for every single row, and the equality constraints between the cells are added. This means that the equality constraints between the index_cells are not actually properly being done, as this array is created for every row, not for every block."
      }
    ],
    "impact": "The block table's index column may not be equal to the block number.",
    "recommendation": "We recommend taking the declaration of the index_cells array and the block_number_cell as well as the equality constraints outside the for loop of the table assignments.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Missing constraint for the first tx_id in Tx Circuit",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.14",
    "target_file": "Tx Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "For the tx_id column, the constraints are that\n‚Ä¢ if tag' = Nonce, then tx_id' = tx_id + 1, and\n‚Ä¢ if tag' != Nonce, then tx_id' = tx_id."
      },
      {
        "type": "text",
        "text": "While the transitions of the tx_id column are correct, there is no check that the first tx_id is equal to 1 in the Tx Circuit."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"tx_id transition\", |meta| {\n    let mut cb = BaseConstraintBuilder:)default();\n    /) if tag_next =) Nonce, then tx_id' = tx_id + 1\n    cb.condition(tag_bits.value_equals(Nonce, Rotation:)next())(meta),\n    |cb| {\n        cb.require_equal(\n            \"tx_id increments\",\n            meta.query_advice(tx_table.tx_id, Rotation:)next()),\n            meta.query_advice(tx_table.tx_id, Rotation:)cur())\n            + 1.expr(),\n        );\n    });\n    /) if tag_next !) Nonce, then tx_id' = tx_id, tx_type' = tx_type\n    cb.condition(\n        not:)expr(tag_bits.value_equals(Nonce, Rotation:)next())(meta)),\n        |cb| {\n            cb.require_equal(\n                \"tx_id does not change\",\n                meta.query_advice(tx_table.tx_id, Rotation:)next()),\n                meta.query_advice(tx_table.tx_id, Rotation:)cur()),\n            );\n            cb.require_equal(\n                \"tx_type does not change\",\n                meta.query_advice(tx_type, Rotation:)next()),\n                meta.query_advice(tx_type, Rotation:)cur()),\n            );\n        },\n    );\n    cb.gate(and:)expr([\n        meta.query_fixed(q_enable, Rotation:)cur()),\n        not:)expr(meta.query_advice(is_calldata, Rotation:)next())),\n    ]))\n});",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "The first tx_id value is not guaranteed to be 1, so tx_id can start with an arbitrary value.",
    "recommendation": "We recommend adding the check for the first tx_id.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"The CallDataRLC value in the fixed assignments is not validated against the actual calldata in Tx Circuit",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.15",
    "target_file": "Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "The fixed part of the Tx Circuit layout includes the row representing the CallDataRLC, which is the random linear combination of the calldata bytes. This value is also checked from the RLP circuit as well."
      },
      {
        "type": "text",
        "text": "The dynamic part of the Tx Circuit layout includes the raw calldata bytes for each transaction."
      },
      {
        "type": "text",
        "text": "The issue is that while there are checks for the CallDataGasCost and CallDataLength via lookups, there is no check the CallDataRLC value is actually equal to the RLC of the bytes in the calldata section."
      }
    ],
    "impact": "The actual calldata used can be different from the one in the RLP circuit or the fixed part of the Tx Circuit.",
    "recommendation": "We recommend adding the check of the consistency between the CallDataRLC and the calldata part of the Tx Circuit layout via a lookup argument.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"The OneHot encoding gadget has incorrect constraints",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Coding Mistakes",
    "finding_id": "SCROLL2-3.16",
    "target_file": "MPT Circuit, gadgets/one_hot.rs",
    "content": [
      {
        "type": "text",
        "text": "The OneHot gadget has a previous helper function that returns the enum type represented by the one-hot encoding at the previous row."
      },
      {
        "type": "code",
        "code": "impl<T: IntoEnumIterator + Hash + Eq> OneHot<T> {\n    /) ...)))\n    pub fn previous<F: FieldExt>(&self) -> Query<F> {\n        T:)iter().enumerate().fold(Query:)zero(), |acc, (i, t)| {\n            acc.clone()\n            + Query:)from(u64:)try_from(i).unwrap())\n            * self\n            .columns\n            .get(&t)\n            .map_or_else(BinaryQuery:)zero,\n            BinaryColumn:)current)\n        })\n    }\n    /) ...)))\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "However, this implementation is incorrect as it queries the value of the binary columns representing the one-hot encoding at the current row."
      }
    ],
    "impact": "The OneHot gadget is used to maintain the validity of the transitions between various proof types in the MPT Circuit. For example,\n\ncb.condition(!is_start, |cb| {\n    cb.assert_equal(\n        \"proof type does not change\",\n        proof_type.current(),\n        proof_type.previous(),\n    );\nthis incorrect constraint can be used to generate invalid proofs in the MPT Circuit.",
    "recommendation": "We recommend fixing the incorrect constraint by using BinaryColumn:)previous to query the previous row.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"The BinaryColumn gadget is missing boolean constraint check",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "High",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.17",
    "target_file": "MPT Circuit, constraint_builder/binary_column.rs",
    "content": [
      {
        "type": "text",
        "text": "The BinaryColumn gadget is used by the OneHot encoding gadget to store information about the ProofType and SegmentType of each row. This gadget also assumes that the binary column exposed by the gadget only contains boolean (0/1) values."
      },
      {
        "type": "text",
        "text": "However, no such constraint exists in the BinaryColumn gadget to check this assumption:"
      },
      {
        "type": "code",
        "code": "impl BinaryColumn {\n    /) ...)))\n    pub fn configure<F: FieldExt>(\n        cs: &mut ConstraintSystem<F>,\n        _cb: &mut ConstraintBuilder<F>,\n    ) -> Self {\n        let advice_column = cs.advice_column();\n        /) TODO: constrain to be binary here...)))\n        /) cb.add_constraint()\n        Self(advice_column)\n    }\n}",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "By assigning nonboolean values to the binary columns, one can generate inconsistent results returned by the queries to the OneHot gadget. This can lead to incorrect proof generation in the MPT Circuit, which makes use of these gadgets.",
    "recommendation": "We recommend adding a boolean constraint on the advice column in the BinaryColumn gadget.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
    {
    "title":"Missing range check for address values in MPT Circuit",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.18",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "In the MPT Circuit, the account address is used to calculate the MPT key where account data is stored in the state trie:"
      },
      {
        "type": "code",
        "code": "impl MptUpdateConfig {\n    pub fn configure<F: FieldExt>(/*...*/) {\n        /* ... */\n        cb.condition(is_start.clone().and(cb.every_row_selector()),\n        |cb| {\n            let [address, address_high, ..] = intermediate_values;\n            let [old_hash_rlc, new_hash_rlc, ..] = second_phase_intermediate_values;\n            let address_low: Query<F> = (address.current()\n            - address_high.current() * (1 << 32))\n            * (1 << 32)\n            * (1 << 32)\n            * (1 << 32);\n            cb.poseidon_lookup(\n                \"account mpt key = h(address_high, address_low)\",\n                [address_high.current(), address_low, key.current()],\n                poseidon,\n            );\n            /*...*/\n        })\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "There need to be range checks on the various values of address:\n‚Ä¢ The address needs to be range checked to be within 20 bytes or 160 bits\n‚Ä¢ The address_high must be range checked to be within 16 bytes or 128 bits.\n‚Ä¢ The calculated value of address_low (before the multiplication by 2^96) must be range checked to be within 4 bytes or 32 bits."
      }
    ],
    "impact": "Without the necessary range checks, one can calculate multiple combinations of address_low and address_high for the same value of address. This results in multiple MPT keys for a single address, which leads to a invalid state trie.",
    "recommendation": "We recommend adding the appropriate range checks to the intermediate columns as mentioned above.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Incorrect assertion for account hash traces in Proof:)check",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Coding Mistakes",
    "finding_id": "SCROLL2-3.19",
    "target_file": "MPT Circuit, types.rs",
    "content": [
      {
        "type": "text",
        "text": "The Proof:)check function ensures that the account hash traces that are used as intermediate witnesses for the MPT circuit are generated correctly. One of the assertions in this function contains a typo:"
      },
      {
        "type": "code",
        "code": "impl Proof {\n    fn check(&self) {\n        /) ...)))\n        assert_eq!(\n            hash(\n                hash(Fr:)one(), self.leafs[0].unwrap().key),\n                self.leafs[0].unwrap().value_hash\n            ),\n            self.old_account_hash_traces[5][2],\n        );\n        assert_eq!(\n            hash(\n                hash(Fr:)one(), self.leafs[1].unwrap().key),\n                self.leafs[1].unwrap().value_hash\n            ),\n            self.new_account_hash_traces[5][2],\n        );\n        /) ...)))\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "If we looked at account_hash_traces where these traces are generated, we see that the left-hand side of the assertion is actually equal to the entry account_hash_traces[6][2]:"
      },
      {
        "type": "code",
        "code": "fn account_hash_traces(address: Address, account: AccountData,\nstorage_root: Fr) -> [[Fr; 3]; 7] {\n    let account_key = account_key(address);\n    let h5 = hash(Fr:)one(), account_key);\n    let poseidon_codehash = big_uint_to_fr(&account.poseidon_code_hash);\n    let account_hash = hash(h4, poseidon_codehash);\n    /) ...)))\n    account_hash_traces[5] = [Fr:)one(), account_key, h5];\n    account_hash_traces[6] = [h5, account_hash, hash(h5, account_hash)];\n}",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "As this function is not used anywhere, there is no security impact. However, we recommend fixing this for code maturity as it may be used in tests in the future.",
    "recommendation": "Change the right-hand side of the assertion to the correct index.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Implementations of RlcLookup trait are not consistent",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Informational",
    "difficulty": "Low",
    "type": "Code Maturity",
    "finding_id": "SCROLL2-3.20",
    "target_file": "MPT Circuit",
    "content": [
      {
        "type": "text",
        "text": "The MPT Circuit uses the RlcLookup trait to perform lookups about the RLC values of various witnesses. This trait is defined in byte_representation.rs:"
      },
      {
        "type": "code",
        "code": "pub trait RlcLookup {\n    fn lookup<F: FieldExt>(&self) -> [Query<F>; 3];\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "This lookup trait is implemented by two gadgets: ByteRepresentation and CanonicalRepresentation:"
      },
      {
        "type": "code",
        "code": "impl RlcLookup for ByteRepresentationConfig {\n    fn lookup<F: FieldExt>(&self) -> [Query<F>; 3] {\n        [\n            self.value.current(),\n            self.index.current(),\n            self.rlc.current(),\n        ]\n    }\n}\n\nimpl RlcLookup for CanonicalRepresentationConfig {\n    fn lookup<F: FieldExt>(&self) -> [Query<F>; 3] {\n        [\n            self.value.current(),\n            self.rlc.current(),\n            self.index.current(),\n        ]\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "While both of these gadgets implement the same lookup trait, they have a different order of columns. Not only that, but the definition of value is different ‚Äî while value in the ByteRepresentationConfig is the value of the accumulated bytes so far, the value in the CanonicalRepresentationConfig is the value of the entire field element."
      },
      {
        "type": "text",
        "text": "This lookup trait is used in word_rlc.rs with a implicit assumption that the RlcLookup is implemented by the ByteRepresentationConfig."
      }
    ],
    "impact": "While there are no wrong lookups performed currently, there is a chance that future changes to the code may introduce security issues due to incorrect assumptions on the structure of the RlcLookup.",
    "recommendation": "We recommend introducing distinct traits for these two different lookups to remove the ambiguity and improve code maturity.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Missing constraints for new account in configure_balance",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "High",
    "difficulty": "Medium",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.21",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "Within configure_balance in the MPT circuit, with segment type AccountLeaf3 and path type ExtensionNew, there should be a constraint that ensures that the sibling is equal to 0."
      },
      {
        "type": "text",
        "text": "This corresponds to the case when we are creating a new entry in the accounts trie and we are assigning the balance of the account as the first entry."
      }
    ],
    "impact": "Without this constraint, there may be soundness issues when updating the balance of a new address.",
    "recommendation": "We recommend adding a check to constraint the sibling (i.e., nonce/codesize) to be equal to 0.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Missing constraints in configure_empty_storage",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "Medium",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.22",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "There should be a check to ensure that the old_hash and new_hash are the same for an empty storage entry. This is similar to the case in configure_empty_account where the same thing is in fact constrained:"
      },
      {
        "type": "code",
        "code": "fn configure_empty_account<F: FieldExt>(/* ... */) {\n    /* ... */\n    cb.assert_equal(\n        \"hash doesn't change for empty account\",\n        config.old_hash.current(),\n        config.new_hash.current(),\n    );\n    /* ... */\n}",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "This may lead to soundness issues when proving that storage does not exist.",
    "recommendation": "We recommend adding a check to constrain the equality of the old and the new hash.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Enforcing padding rows in MPT circuit",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Medium",
    "difficulty": "Low",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.23",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "The configure_empty_storage and configure_empty_account use the following check to determine if the current row is the final segment."
      },
      {
        "type": "code",
        "code": "let is_final_segment\n= config.segment_type.next_matches(&[SegmentType::Start]);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In the case that the current proof is the last proof in the MPT table, this assumes that the rows after the last proof are populated with the appropriate padding rows."
      },
      {
        "type": "text",
        "text": "However, there are no constraints to ensure that these padding rows have been assigned properly at the end of the MPT circuit."
      }
    ],
    "impact": "Without this constraint, there may be soundness issues for MPTProofType::StorageDoesNotExist and MPTProofType::AccountDoesNotExist.",
    "recommendation": "We recommend adding checks in the circuit to ensure that the padding rows have been assigned following the algorithm in assign_padding_row.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Incorrect constraints in configure_nonce",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "High",
    "difficulty": "Medium",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.24",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "In configure_nonce, when the segment type is AccountLeaf3 and the path type is Common, there is a missed check on the size of the new nonce. This is because the old value of the nonce is mistakenly checked (see [1])."
      },
      {
        "type": "text",
        "text": "Additionally, there is another incorrect check when the path type is ExtensionNew where the old nonce is range checked instead of the new nonce (see [2])."
      },
      {
        "type": "code",
        "code": "fn configure_nonce(/* ... */) {\n    /* ... */\n    SegmentType::AccountLeaf3 => {\n        /* ... */\n        cb.condition(\n            config.path_type.current_matches(&[PathType::Common]),\n            |cb| {\n                cb.add_lookup(\n                    \"new nonce is 8 bytes\",\n                    [config.old_value.current(),\n                    Query::from(7)], // [1] Typo.\n                    bytes.lookup(),\n                );\n                /* ... */\n            }\n        );\n        cb.condition(\n            config.path_type.current_matches(&[PathType::ExtensionNew]),\n            |cb| {\n                cb.add_lookup(\n                    \"new nonce is 8 bytes\",\n                    [config.old_value.current(),\n                    Query::from(7)], // [2] Typo\n                    bytes.lookup(),\n                );\n                /* ... */\n            },\n        );\n    }\n    /* ... */\n}",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "As the nonce values are not range checked properly, proofs about accounts with invalid nonces can be generated. This could potentially lead to denial-of-service attacks on addresses.",
    "recommendation": "Fix the typos to range check the correct nonce values.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Conflicting constraints in configure_code_size",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Low",
    "difficulty": "Low",
    "type": "Coding Mistakes",
    "finding_id": "SCROLL2-3.25",
    "target_file": "MPT Circuit, gadgets/mpt_update.rs",
    "content": [
      {
        "type": "text",
        "text": "In configure_code_size, the first line ensures that the only possible path types that can be proved are PathType::Start and PathType::Common."
      },
      {
        "type": "code",
        "code": "fn configure_code_size<F: FieldExt>(\n    cb: &mut ConstraintBuilder<F>,\n    config: &MptUpdateConfig,\n    bytes: &impl BytesLookup,\n) {\n    cb.assert(\n        \"new accounts have balance or nonce set first\",\n        config\n        .path_type\n        .current_matches(&[PathType::Start, PathType::Common]),\n    );\n    /* ... */\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "However, later on in the function, there are constraints that are conditioned on the current path type being either PathType::ExtensionOld or PathType::ExtensionNew. These two above-mentioned constraints are contradictory, and the code later on will never be executed as these conditions cannot be true."
      },
      {
        "type": "text",
        "text": "A similar issue also exists in configure_poseidon_code_hash."
      }
    ],
    "impact": "If this is intended behavior, then the above-mentioned constraints are dead code and add to unnecessary code complexity.",
    "recommendation": "We recommend removing those constraints if they are not necessary.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"ByteRepresentation::index is not properly constrained",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Medium",
    "difficulty": "Low",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.26",
    "target_file": "MPT Circuit, gadgets/byte_representation.rs",
    "content": [
      {
        "type": "text",
        "text": "In the ByteRepresentation gadget, there is a constraint which ensures that the index always increases by 1 or is 0. The expected behavior is that it constrains the value of index to be 0 at the first row."
      },
      {
        "type": "code",
        "code": "impl ByteRepresentationConfig {\n    pub fn configure<F: FieldExt>(/* ... */) -> Self {\n        let [value, index, byte] = cb.advice_columns(cs);\n        let [rlc] = cb.second_phase_advice_columns(cs);\n        let index_is_zero = IsZeroGadget::configure(cs, cb, index);\n        cb.assert_zero(\n            \"index increases by 1 or resets to 0\",\n            index.current() * (index.current() - index.previous() - 1),\n        );",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "At the first row, a rotation to the previous row will wrap around to the last row of the table, which includes the blinding factors in Halo2. This lets the value of the index be controlled by values in the last row of the table."
      }
    ],
    "impact": "Instead of the index being set to 0 in the first row, a prover can arbitrary non-zero value depending on the contents of the last row of the table.",
    "recommendation": "We recommend adding a selector which enables a constraint to constrain that index = 0 at the first row.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Miscellaneous typos in comments and constraint descriptions",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Informational",
    "difficulty": "N/A",
    "type": "Code Maturity",
    "finding_id": "SCROLL2-3.27",
    "target_file": "MPT Circuit",
    "content": [
      {
        "type": "text",
        "text": "In byte_representation.rs, the following constraints have incorrect comments. They should have (index != 0)."
      },
      {
        "type": "code",
        "code": "cb.assert_equal(\n    \"current value = previous value * 256 * (index == 0) + byte\",\n    value.current(),\n    value.previous() * 256 * !index_is_zero.current() + byte.current(),\n);\ncb.assert_equal(\n    \"current rlc = previous rlc * randomness * (index == 0) + byte\",\n    rlc.current(),\n    rlc.previous() * randomness.query() * !index_is_zero.current()\n    + byte.current(),\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In mpt_update.rs, the function configure_code_size has the following constraint. The description is incorrect, as it actually checks that the balance is 0."
      },
      {
        "type": "code",
        "code": "cb.assert_zero(\n    \"nonce and code size are 0 for ExtensionNew balance update\",\n    config.sibling.current(),\n);",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In mpt_update.rs, the following constraint has an incorrect description. The constraint checks new_value, but the comment mentions old_value."
      },
      {
        "type": "code",
        "code": "cb.condition(!is_start, |cb| {\n    /* ... */\n    cb.assert_equal(\n        // typo\n        \"old_value does not change\",\n        new_value.current(),\n        new_value.previous(),\n    );\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In account.rs, the computation of old_root and new_root are incorrect."
      },
      {
        "type": "code",
        "code": "impl AccountProof {\n    pub fn old_root(&self) -> Fr {\n        self.trie_rows\n        .old_root(|| self.old_leaf.hash(self.storage.new_root()))\n        // old_root, but uses new_root to hash\n    }\n    pub fn new_root(&self) -> Fr {\n        self.trie_rows\n        .new_root(|| self.new_leaf.hash(self.storage.old_root()))\n        // new_root, but uses old_root to hash\n    }\n}",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "There is also a typo in implementing From<&SMTTrace> for AccountProof."
      },
      {
        "type": "code",
        "code": "impl From<&SMTTrace> for AccountProof {\n    fn from(trace: &SMTTrace) -> Self {\n        let address = Address::from(trace.address.0);\n        let [old_path, new_path] = &trace.account_path;\n        let old_leaf = old_path.leaf;\n        let new_leaf = new_path.leaf;\n        let trie_rows = TrieRows::new(\n            account_key(address),\n            &new_path.path, // here - might be old_path.path\n            &new_path.path,\n            old_path.leaf,\n            new_path.leaf,\n        );\n        /* ... */\n    }\n}",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "This is not a security issue. The typos only affect the readability and maintainability of the code.",
    "recommendation": "We recommend fixing these mistakes for better code maturity.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"ChainId is not mapped to it's corresponding RLP Tag in Tx Circuit",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "High",
    "difficulty": "Medium",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.28",
    "target_file": "Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "In the Tx Circuit, the TxFieldTag values in the tag_bits column are mapped to their respective RLP Tag values using the following map:"
      },
      {
        "type": "code",
        "code": "let rlp_tag_map: Vec<(Expression<F>, RlpTag)> = vec![\n    (is_nonce(meta), Tag::Nonce.into()),\n    (is_gas_price(meta), Tag::GasPrice.into()),\n    /* ... */\n    (is_caller_addr(meta), Tag::Sender.into()),\n    (is_tx_gas_cost(meta), GasCost),\n    // tx tags which correspond to Null\n    (is_null(meta), Null),\n    (is_create(meta), Null),\n    /* ... */\n    (is_block_num(meta), Null),\n    (is_chain_id_expr(meta), Null),\n];",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In this map, the values which do not have a corresponding RLP Tag are set to Null. Here, chain_id is incorrectly set to Null even though it is part of the RLP encoded transaction (Tag::ChainId)."
      },
      {
        "type": "text",
        "text": "The rlp_tag values are used to lookup into the RLP table to ensure that the appropriate values are being hashed for verifying the transaction signature."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"sign tag lookup into RLP table condition\", |meta| {\n    let mut cb = BaseConstraintBuilder::default();\n    let is_tag_in_tx_sign = sum::expr([\n        is_nonce(meta),\n        is_gas_price(meta),\n        is_gas(meta),\n        is_to(meta),\n        is_value(meta),\n        is_data_rlc(meta),\n        is_sign_length(meta),\n        is_sign_rlc(meta),\n    ]);\n    cb.require_equal(\n        \"condition\",\n        is_tag_in_tx_sign,\n        meta.query_advice(\n            lookup_conditions[&LookupCondition::RlpSignTag],\n            Rotation::cur(),\n        ),\n    );",
        "language": "rust",
        "description": ""
      }
    ],
    "impact": "As the Chain ID is missing from these lookup checks, one can forge the Chain ID value for a given transaction with a existing signature.",
    "recommendation": "We recommend adding the mapping from TxFieldTag::ChainID to the RLP Tag Tag::ChainId. We also recommend ensuring that the Chain ID value in the Tx Table is looked up into the RLP Table using the above mapping.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Highest tx_id must be equal to cum_num_txs in Tx Circuit",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "High",
    "difficulty": "Medium",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.29",
    "target_file": "Tx Circuit, tx_circuit.rs",
    "content": [
      {
        "type": "text",
        "text": "In the Tx Circuit, there is a check to ensure that tx_id is less than the cum_num_txs value which is looked up from the block table."
      },
      {
        "type": "code",
        "code": "meta.create_gate(\"tx_id <= cum_num_txs\", |meta| {\n    let mut cb = BaseConstraintBuilder::default();\n    let (lt_expr, eq_expr) = tx_id_cmp_cum_num_txs.expr(meta, None);\n    cb.condition(is_block_num(meta), |cb| {\n        cb.require_equal(\"lt or eq\", sum::expr([lt_expr, eq_expr]),\n        true.expr());\n    });\n    cb.gate(and::expr([\n        meta.query_fixed(q_enable, Rotation::cur()),\n        not::expr(meta.query_advice(is_padding_tx, Rotation::cur())),\n    ]))\n});",
        "language": "rust",
        "description": ""
      },
      {
        "type": "text",
        "text": "In a valid block, the largest value of tx_id also must be equal to the value of cum_num_txs. Currently, there is no constraint which ensures this."
      }
    ],
    "impact": "The cum_num_txs value can be set to be much larger than the actual set of tx_ids.",
    "recommendation": "We recommend adding a constraint to check that the tx_id of the last non-padding transaction in the Tx Circuit is equal to the cum_num_txs.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  },
  {
    "title":"Multiple RLP encodings share the same RLC value",
    "source":"Zellic Inc. x KALOS",
    
    "protocol":"Scroll ZKEVM",
    "protocol_type":"ZKEVM",
    "tags": [],
    "frameworks": [],
    "reported_by": ["Sampriti Panda", "Allen Roh"],
    "scope": [
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/mpt-circuit/",
        "commit_hash": "mpt-circuit: 9d129125bd792e906c30e56386424bc3ab5920ba"
      },
      {
        "name": "Scroll zkEVM Circuits",
        "description": "Type: Rust. Platform: halo2. ",
        "repository": "https://github.com/scroll-tech/zkevm-circuits/",
        "commit_hash": "zkevm-circuits: 25dd32aa316ec842ffe79bb8efe9f05f86edc33e"
      }
    ],
    "report_url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf",
    "severity": "Critical",
    "difficulty": "High",
    "type": "Underconstrained Circuits",
    "finding_id": "SCROLL2-3.30",
    "target_file": "RLP Circuit, rlp_circuit_fsm.rs",
    "content": [
      {
        "type": "text",
        "text": "The value of a RLP Tag is calculated using the Random Linear Combination (RLC) of it's constituent bytes. The formula to calculate this is bytes_rlc(i+1) == bytes_rlc(i) * r + byte_value(i+1) where r is the challenge value used to calculate the RLC."
      },
      {
        "type": "text",
        "text": "One issue with this formula is that one can prepend a tag with a arbitrary number of zeroes, and this won't change the value of the RLC calculated. This means that in the context of the circuit: RLP([0x00, 0xff]) == RLP([0x00, 0x00, 0xff])."
      }
    ],
    "impact": "This allows an adversary to add zero bytes to existing fields in a RLP encoded signing data for a transaction without changing the RLCed value in the circuit.",
    "recommendation": "We recommend adding a additional column, tag_length, which contains the number of bytes in a RLP Tag. The combination of (bytes_rlc, tag_length) will always correspond to unique RLP tags.",
    "auditFirm": "Zellic Inc. x KALOS",
    "publishDate": "07/31/2023",
    "reportSource": {
      "name": "Nullity00",
      "url": "https://github.com/nullity00/zk-security-reviews/blob/main/Scroll/Scroll_zkEVM_-_Part_2_-_Audit_Report.pdf"
    }
  }
]